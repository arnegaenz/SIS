<!doctype html>
<html lang="en">
  <head>
  <meta charset="utf-8" />
  <title>Cardholder Engagement Dashboard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <link rel="stylesheet" href="./sis-shared.css?v=navfix" />
  <link rel="stylesheet" href="./assets/css/sis.css">
  <link rel="stylesheet" href="./assets/css/funnel.css">
  <link rel="stylesheet" href="./assets/css/mobile.css">
  <link rel="stylesheet" href="./assets/css/filters.css">
  <script src="./assets/js/config.js"></script>
  <script src="./assets/js/passcode-gate.js"></script>
  <script defer src="./assets/js/sis.js"></script>
  <script defer src="./assets/js/nav.js"></script>
  <script type="module" defer src="./assets/js/data-cache.js?v=3"></script>
  <script defer src="./assets/js/filters.js?v=shared"></script>
  <script>
    document.addEventListener("DOMContentLoaded", function(){
      if (window.renderHeaderNav && !window.__sisHeaderNav_funnel_customer) {
        window.__sisHeaderNav_funnel_customer = true;
        window.renderHeaderNav({
          currentId: "funnel-customer",
          title: "Cardholder Engagement Dashboard",
          subtitle: "Track cardholder adoption and card-on-file success metrics."
        });
      }
    });
  </script>
  <style>
    * { box-sizing: border-box; }
    body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; }

    .funnel-header { margin-bottom: 12px; }
    .form-grid {
      display: flex; flex-wrap: wrap; gap: 6px; align-items: flex-end;
    }
    .form-grid--dates { margin-top: 8px; }
    .form-field {
      display: flex; flex-direction: column; gap: 6px;
      min-width: 160px; min-height: 54px;
    }
    .form-field label {
      font-size: 0.85rem; color: var(--muted, #64748b);
      letter-spacing: 0.03em; text-transform: uppercase; padding-left: 2px;
    }
    .form-select, .form-input {
      background: var(--input-bg, #fff); border: 1px solid var(--input-border, #cbd5e1);
      border-radius: 10px; color: var(--text, #0f172a);
      padding: 10px 12px; font-size: 0.92rem;
      min-width: 160px; height: 42px; line-height: 22px;
    }
    .form-select:focus, .form-input:focus {
      outline: none; border-color: var(--accent, #2563eb);
      box-shadow: 0 0 0 3px rgba(37,99,235,0.2);
    }
    .form-field-actions { min-width: 200px; }
    .form-actions { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
    @media (max-width: 767px) {
      .funnel-header .form-grid,
      .funnel-header .form-grid--dates {
        display: flex; flex-direction: column; width: 100%;
      }
      .funnel-header .form-field { min-width: 0; width: 100%; }
    }
    .form-button {
      background: linear-gradient(120deg, var(--accent), var(--accent-2));
      border: none; border-radius: 999px;
      padding: 10px 28px; min-width: 170px;
      font-size: 0.9rem; cursor: pointer;
      color: #f8fafc; font-weight: 600; letter-spacing: 0.2px;
      white-space: nowrap;
    }
    .form-button.secondary {
      background: transparent;
      border: 1px solid var(--border, #cbd5e1);
      color: var(--muted, #64748b);
      min-width: auto;
    }
    .date-warning {
      margin-top: 6px; padding: 6px 10px; background: #fef3c7; border: 1px solid #fcd34d;
      border-radius: 6px; font-size: 12px; color: #92400e; display: none;
    }

    /* Performance Overview */
    .perf-section-title {
      font-size: 13px; font-weight: 700; color: #0f172a;
      margin: 20px 0 10px; padding-bottom: 4px;
      border-bottom: 2px solid #e2e8f0;
    }
    .perf-section-title:first-child { margin-top: 0; }

    .perf-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 16px; margin-bottom: 16px;
    }
    @media (max-width: 1024px) { .perf-grid { grid-template-columns: repeat(2, 1fr); } }
    @media (max-width: 600px) { .perf-grid { grid-template-columns: 1fr; } }
    .perf-card {
      background: #fff; border: 1px solid #e2e8f0; border-radius: 12px;
      padding: 14px 16px; text-align: left;
      display: flex; flex-direction: column; align-items: flex-start;
      position: relative; overflow: hidden;
      box-shadow: 0 14px 34px rgba(0,0,0,0.08);
      transition: transform 0.15s ease, border-color 0.15s ease, box-shadow 0.15s ease;
    }
    .perf-card:hover {
      transform: translateY(-1px);
      box-shadow: 0 18px 42px rgba(0,0,0,0.12);
    }
    .perf-card .card-label {
      font-size: 0.75rem; font-weight: 600; text-transform: uppercase;
      letter-spacing: 0.05em; color: #64748b;
      line-height: 1.2; margin-bottom: 8px;
      max-width: 100%;
    }
    .perf-card .card-value {
      font-size: 1.8rem; font-weight: 700; color: #0f172a; line-height: 1.1;
      margin-bottom: 4px;
    }
    .perf-card .card-sub {
      font-size: 0.85rem; color: #94a3b8; font-weight: 600;
      white-space: nowrap; text-overflow: ellipsis; max-width: 100%;
      overflow: hidden;
    }
    .perf-card.highlight {
      background: linear-gradient(135deg, rgba(37,99,235,0.10) 0%, rgba(37,99,235,0.03) 55%, transparent 100%), #fff;
      border-color: rgba(37,99,235,0.45);
    }
    .perf-card.highlight::before {
      content: ""; position: absolute; left: 0; top: 0; bottom: 0; width: 4px;
      background: linear-gradient(180deg, rgba(37,99,235,0.9), rgba(37,99,235,0.15));
    }
    .perf-card.highlight .card-value { color: #2563eb; }
    .perf-card.success {
      background: linear-gradient(135deg, rgba(22,163,74,0.10) 0%, rgba(22,163,74,0.03) 55%, transparent 100%), #fff;
      border-color: rgba(22,163,74,0.45);
    }
    .perf-card.success::before {
      content: ""; position: absolute; left: 0; top: 0; bottom: 0; width: 4px;
      background: linear-gradient(180deg, rgba(22,163,74,0.9), rgba(22,163,74,0.15));
    }
    .perf-card.success .card-value { color: #16a34a; }

    /* Merchant detail popover (floats out of success card) */
    .perf-card.success { overflow: visible; }
    .card-merchant-detail {
      display: none; position: absolute; left: 0; top: 100%; margin-top: 6px;
      width: max(100%, 260px); z-index: 50;
      background: #fff; border: 1px solid #e2e8f0; border-radius: 10px;
      padding: 10px 12px; font-size: 0.8rem; color: #334155;
      line-height: 1.6; box-shadow: 0 16px 40px rgba(0,0,0,0.12);
    }
    .card-merchant-detail.open { display: block; }
    .card-merchant-detail .merchant-pop-title {
      font-size: 0.7rem; font-weight: 700; text-transform: uppercase;
      letter-spacing: 0.05em; color: #64748b; margin-bottom: 6px;
    }
    .card-merchant-row {
      display: flex; justify-content: space-between; gap: 8px;
      padding: 3px 6px; border-radius: 4px;
    }
    .card-merchant-row:nth-child(even) {
      background: rgba(0,0,0,0.03);
    }
    .card-merchant-count {
      white-space: nowrap; font-variant-numeric: tabular-nums; font-weight: 600;
    }

    /* Metrics color key */
    .metrics-key {
      display: flex; align-items: center; gap: 14px; flex-wrap: wrap;
      padding: 8px 14px; margin-bottom: 12px;
      background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px;
      font-size: 11px; color: #64748b;
    }
    .key-label { font-weight: 600; color: #334155; margin-right: 2px; }
    .key-item { display: flex; align-items: center; gap: 5px; }
    .key-swatch {
      width: 12px; height: 12px; border-radius: 3px; flex-shrink: 0;
    }
    .key-swatch.ga { background: #ede9fe; border: 1px solid #c4b5fd; }
    .key-swatch.cs { background: #fef3c7; border: 1px solid #fcd34d; }
    .key-swatch.stats { background: #e0f2f1; border: 1px solid rgba(74,158,186,0.45); }
    .key-swatch.highlight { background: #dbeafe; border: 1px solid #93c5fd; }
    .key-swatch.success { background: #dcfce7; border: 1px solid #86efac; }

    /* GA toggle styling */
    .key-toggle {
      cursor: pointer;
      background: #f5f3ff; border: 1px solid #c4b5fd; border-radius: 5px;
      padding: 2px 8px 2px 4px; margin: -2px 0;
      transition: opacity 0.15s;
    }
    .key-toggle:hover { border-color: #7c3aed; }
    .key-toggle input[type="checkbox"] {
      width: 13px; height: 13px; margin: 0; cursor: pointer;
      accent-color: #7c3aed;
    }
    .hide-ga .key-toggle {
      background: #f8fafc; border-color: #cbd5e1; opacity: 0.6;
    }
    .hide-ga .key-toggle:hover { opacity: 1; }

    /* When GA is hidden — cards, table columns, row label */
    .hide-ga .ga-card,
    .hide-ga .ga-col,
    .hide-ga .grid-row-label.ga-row-label { display: none !important; }
    .hide-ga .key-swatch.ga { opacity: 0.3; }
    .hide-ga .ga-toggle-hint { display: inline; }

    /* Grid row labels (section dividers within the card grid) */
    .grid-row-label {
      grid-column: 1 / -1;
      font-size: 11px; font-weight: 700; text-transform: uppercase;
      letter-spacing: 0.05em; color: #475569;
      padding: 6px 0 2px; margin-top: 4px;
      border-bottom: 1px solid #e2e8f0;
    }
    .grid-row-label .muted {
      font-weight: 400; text-transform: none; letter-spacing: 0;
      color: #94a3b8; font-size: 10px;
    }

    /* GA-sourced cards (purple accent) */
    .perf-card.ga-card {
      background: linear-gradient(135deg, rgba(124,58,237,0.10) 0%, rgba(124,58,237,0.03) 55%, transparent 100%), #fff;
      border-color: rgba(124,58,237,0.40);
    }
    .perf-card.ga-card::before {
      content: ""; position: absolute; left: 0; top: 0; bottom: 0; width: 4px;
      background: linear-gradient(180deg, rgba(124,58,237,0.85), rgba(124,58,237,0.15));
    }
    .perf-card.ga-card .card-label { color: #5b21b6; }

    /* Session clickstream cards (amber accent) */
    .perf-card.cs-card {
      background: linear-gradient(135deg, rgba(217,119,6,0.10) 0%, rgba(217,119,6,0.03) 55%, transparent 100%), #fff;
      border-color: rgba(217,119,6,0.40);
    }
    .perf-card.cs-card::before {
      content: ""; position: absolute; left: 0; top: 0; bottom: 0; width: 4px;
      background: linear-gradient(180deg, rgba(217,119,6,0.85), rgba(217,119,6,0.15));
    }
    .perf-card.cs-card .card-label { color: #92400e; }
    .perf-card.cs-card.stats-card {
      background: linear-gradient(135deg, rgba(217,119,6,0.10) 0%, rgba(217,119,6,0.03) 55%, transparent 100%), #fff;
      border-color: rgba(217,119,6,0.40);
    }
    .perf-card.cs-card.stats-card::before {
      background: linear-gradient(180deg, rgba(217,119,6,0.85), rgba(217,119,6,0.15));
    }
    .perf-card.cs-card.stats-card .card-label { color: #92400e; }
    .perf-card.cs-card.stats-card { overflow: visible; }

    /* Stats chips card (Merchants Per Session) */
    .perf-card.stats-card {
      background: linear-gradient(135deg, rgba(74,158,186,0.12) 0%, rgba(74,158,186,0.04) 55%, transparent 100%), #fff;
      border-color: rgba(74,158,186,0.45);
    }
    .perf-card.stats-card::before {
      content: ""; position: absolute; left: 0; top: 0; bottom: 0; width: 4px;
      background: linear-gradient(180deg, rgba(74,158,186,0.9), rgba(74,158,186,0.15));
    }
    .perf-card.stats-card .card-label { color: #2a7f9a; }
    .stats-chips {
      display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-top: 6px;
      width: 100%;
    }
    .stats-chip {
      display: inline-flex; align-items: center; justify-content: space-between;
      gap: 8px;
      background: #fff; border: 1px solid #e2e8f0; border-radius: 10px;
      padding: 6px 10px; font-size: 0.85em; color: #64748b;
    }
    .stats-chip b { opacity: 0.8; font-size: 0.85em; letter-spacing: 0.03em; }
    .stats-chip .chip-val { font-weight: 700; color: #0f172a; font-variant-numeric: tabular-nums; }
    /* Stats card bottom row (AVG chip + distribution toggle) */
    .perf-card.stats-card { overflow: visible; position: relative; z-index: 1; }
    .perf-card.stats-card:has(.stats-dist-panel.open) { z-index: 70; }
    .stats-bottom-row {
      display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px;
      width: 100%; margin-top: 8px; align-items: center;
      position: relative;
    }
    .stats-bottom-row .stats-dist-toggle { grid-column: 2 / 4; }
    .stats-dist-toggle {
      font: inherit; padding: 5px 10px; border-radius: 10px;
      border: 1px solid #e2e8f0; background: #fff; color: #0f172a;
      font-weight: 600; font-size: 0.78rem; cursor: pointer;
      display: inline-flex; align-items: center; gap: 4px;
      transition: border-color 0.15s;
    }
    .stats-dist-toggle:hover { border-color: #4a9eba; }
    .stats-dist-toggle[aria-expanded="true"] { border-color: #4a9eba; }
    /* Distribution popover — anchored to .stats-bottom-row */
    .stats-dist-panel {
      display: none; position: absolute; right: 0; top: 100%; margin-top: 10px;
      width: min(360px, calc(100vw - 40px)); z-index: 60;
      background: #fff; border: 1px solid #e2e8f0; border-radius: 12px;
      box-shadow: 0 16px 40px rgba(0,0,0,0.12);
      max-height: 40vh; overflow: visible;
    }
    .stats-dist-panel > table,
    .stats-dist-panel > div {
      max-height: calc(40vh - 20px); overflow: auto;
    }
    .stats-dist-panel::before {
      content: ""; position: absolute; top: -7px; right: 28px;
      width: 12px; height: 12px; background: #fff;
      border-left: 1px solid #e2e8f0; border-top: 1px solid #e2e8f0;
      transform: rotate(45deg); z-index: 1;
    }
    .stats-dist-panel.open { display: block; }
    .stats-dist-table { width: 100%; border-collapse: collapse; }
    .stats-dist-table th, .stats-dist-table td {
      padding: 8px 12px; border-bottom: 1px solid #f1f5f9; text-align: left;
      font-size: 0.82rem;
    }
    .stats-dist-table th { font-weight: 700; color: #64748b; font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.04em; }
    .stats-dist-table td:last-child { text-align: right; font-variant-numeric: tabular-nums; font-weight: 600; }
    .stats-dist-empty { padding: 12px; font-size: 0.82rem; color: #94a3b8; }

    /* Highlights table */
    .highlights-table {
      width: 100%; border-collapse: collapse; font-size: 12px; margin-bottom: 8px;
    }
    .highlights-table th {
      text-align: left; padding: 6px 8px; font-size: 10px; font-weight: 700;
      text-transform: uppercase; letter-spacing: 0.03em; color: #475569;
      background: #f1f5f9; border-bottom: 2px solid #e2e8f0;
    }
    .highlights-table td {
      padding: 6px 8px; border-bottom: 1px solid #e2e8f0;
    }
    .highlights-table .num { text-align: center; font-variant-numeric: tabular-nums; }
    .highlights-table .hl-label { font-weight: 600; }
    .highlights-table .nowrap { white-space: nowrap; }
    .highlights-table tbody tr:nth-child(even) { background: #f8fafc; }
    .muted { color: #94a3b8; font-size: 11px; }

    /* Partner summary */
    .partner-summary { margin-top: 16px; }
    .partner-summary table {
      width: 100%; border-collapse: collapse; font-size: 12px;
    }
    .partner-summary th {
      text-align: left; padding: 6px 8px; font-size: 10px; font-weight: 700;
      text-transform: uppercase; letter-spacing: 0.03em; color: #475569;
      background: #f1f5f9; border-bottom: 2px solid #e2e8f0;
    }
    .partner-summary td { padding: 6px 8px; border-bottom: 1px solid #e2e8f0; }
    .partner-summary .num { text-align: right; font-variant-numeric: tabular-nums; }
    .partner-summary .total-row td { border-top: 2px solid #cbd5e1; font-weight: 700; background: #f1f5f9; }

    /* Totals bar */
    .totals-bar {
      font-size: 12px; color: #475569; margin-bottom: 12px; line-height: 1.5;
    }

    /* Per-FI tables */
    .group-block { margin-bottom: 16px; }
    .group-header {
      font-size: 13px; font-weight: 700; color: #0f172a;
      padding: 6px 0; border-bottom: 2px solid #e2e8f0;
      margin-bottom: 4px;
    }
    .table-scroll { overflow-x: auto; }
    .fi-table {
      width: 100%; border-collapse: collapse; font-size: 12px;
      white-space: nowrap;
    }
    .fi-table th {
      text-align: center; padding: 5px 8px; font-size: 10px; font-weight: 700;
      text-transform: uppercase; letter-spacing: 0.03em; color: #475569;
      background: #f1f5f9; border-bottom: 2px solid #e2e8f0;
      cursor: pointer; user-select: none;
    }
    .fi-table th:hover { color: #0f172a; }
    .fi-table td { padding: 5px 8px; border-bottom: 1px solid #f1f5f9; text-align: center; }
    .fi-table tbody tr:hover { background: #f8fafc; }
    .fi-table .num { text-align: center; font-variant-numeric: tabular-nums; }
    .fi-table .totals-row td {
      border-top: 2px solid #cbd5e1; font-weight: 700; background: #f8fafc;
    }
    .fi-table .muted { color: #94a3b8; font-size: 10px; }
    .fi-table .reach-good { color: #16a34a; font-weight: 600; }
    .fi-table .reach-low { color: #d97706; }
    .fi-table th:first-child, .fi-table td:first-child { text-align: left; }

    /* Tab bar (single-FI time breakdowns) */
    .tab-bar {
      display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 12px;
    }
    .tab-button {
      background: transparent; border: 1px solid var(--border, #e2e8f0);
      color: var(--muted, #64748b); border-radius: 999px;
      padding: 6px 14px; font-size: 0.78rem; text-transform: uppercase;
      letter-spacing: 0.08em; cursor: pointer;
      transition: background 0.15s ease, color 0.15s ease;
    }
    .tab-button:hover { color: var(--text, #0f172a); }
    .tab-button.active {
      background: var(--panel, #f8fafc); color: var(--text, #0f172a);
      border-color: var(--accent, #2563eb);
    }
    .tab-panel { display: none; margin-top: 8px; }
    .tab-panel.active { display: block; }
    .tab-panel h3 {
      margin: 0 0 6px; font-size: 0.9rem; color: var(--muted, #64748b);
      letter-spacing: 0.08em; text-transform: uppercase;
    }

    /* Date window label */
    .date-window { font-weight: 400; color: #64748b; font-size: 12px; }

    /* Loading */
    .loading-banner {
      display: none; align-items: center; gap: 10px; padding: 12px 16px;
      background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px;
      margin-bottom: 12px;
    }
    .spinner {
      width: 18px; height: 18px; border: 2px solid #cbd5e1;
      border-top-color: #2563eb; border-radius: 50%;
      animation: spin 0.6s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    .loading-text { font-size: 13px; color: #64748b; }
  </style>
</head>
<body>
  <div id="sis-header"></div>
  <div class="sis-content">
  <main class="sis-main">
    <section class="sis-panel">
      <div id="pageLoader" class="loading-banner">
        <div class="spinner" aria-hidden="true"></div>
        <div class="loading-text">Loading data…</div>
      </div>
      <div id="filter-bar"></div>
      <div class="funnel-header">
        <div class="form-grid form-grid--dates">
          <div class="form-field">
            <label for="datePreset">Range preset</label>
            <select id="datePreset" class="form-select">
              <option value="last7" selected>Last 7 days</option>
              <option value="last14">Last 14 days</option>
              <option value="last30">Last 30 days</option>
              <option value="last60">Last 60 days</option>
              <option value="last90">Last 90 days</option>
              <option value="ytd">Year to date</option>
              <option value="">Custom</option>
            </select>
          </div>
          <div class="form-field">
            <label for="startDate">Start date</label>
            <input id="startDate" type="date" class="form-input" />
          </div>
          <div class="form-field">
            <label for="endDate">End date</label>
            <input id="endDate" type="date" class="form-input" />
          </div>
          <div class="form-field form-field-actions">
            <label>Actions</label>
            <div class="form-actions">
              <button id="applyBtn" class="form-button">Apply filters</button>
              <button id="exportCsvBtn" class="form-button secondary">Export CSV</button>
              <button id="exportPdfBtn" class="form-button secondary">Export PDF</button>
              <button id="shareLinkBtn" class="form-button secondary" type="button" title="Copy shareable link to clipboard" style="display:none;">Share</button>
            </div>
          </div>
        </div>
        <div id="dateWarning" class="date-warning" aria-live="polite"></div>
      </div>

      <!-- Performance Overview -->
      <div id="perfOverview" style="display:none;">
        <div class="perf-section-title">Performance Overview <span class="muted date-window" id="dateWindowLabel"></span></div>
        <div id="totalsBar" class="totals-bar" style="display:none;"></div>
        <!-- Color key -->
        <div class="metrics-key">
          <span class="key-label">Data source:</span>
          <label class="key-item key-toggle" id="gaToggleLabel">
            <input type="checkbox" id="gaToggle" checked>
            <span class="key-swatch ga"></span> Google Analytics
          </label>
          <span class="key-item"><span class="key-swatch cs"></span> Session Clickstream</span>
          <span class="key-item"><span class="key-swatch stats"></span> Session Stats</span>
          <span class="key-item"><span class="key-swatch highlight"></span> Success Metrics</span>
          <span class="key-item"><span class="key-swatch success"></span> Outcomes</span>
        </div>

        <div class="perf-grid" id="metricsGrid">
          <!-- Row 1: Headlines -->
          <div class="perf-card ga-card" id="cardGaSelect">
            <div class="card-label">CardUpdatr Launches</div>
            <div class="card-value" id="valGaSelect">-</div>
            <div class="card-sub" id="subGaSelect"></div>
          </div>
          <div class="perf-card" id="cardSessions">
            <div class="card-label">Total Sessions</div>
            <div class="card-value" id="valSessions">-</div>
            <div class="card-sub" id="subSessions"></div>
          </div>
          <div class="perf-card highlight" id="cardSuccessRate">
            <div class="card-label">Success Rate</div>
            <div class="card-value" id="valSuccessRate">-</div>
            <div class="card-sub" id="subSuccessRate">Sessions w/ success ÷ Total sessions</div>
          </div>
          <div class="perf-card success" id="cardSuccessful" style="cursor:pointer;" title="Click to see merchant breakdown">
            <div class="card-label">Successful Placements</div>
            <div class="card-value" id="valSuccessful">-</div>
            <div class="card-sub" id="subSuccessful"></div>
            <div class="card-merchant-detail" id="merchantDetail"></div>
          </div>

          <!-- Row 2: Funnel stages — GA paired with Clickstream -->
          <div class="grid-row-label">Funnel Stages <span class="muted">— GA traffic vs session clickstream at each step</span></div>
          <div class="perf-card ga-card" id="cardGaUser">
            <div class="card-label">User Data Page Views</div>
            <div class="card-value" id="valGaUser">-</div>
            <div class="card-sub" id="subGaUser"></div>
          </div>
          <div class="perf-card cs-card" id="cardCsSelect">
            <div class="card-label">Select Merchants (Sessions)</div>
            <div class="card-value" id="valCsSelect">-</div>
            <div class="card-sub" id="subCsSelect"></div>
          </div>
          <div class="perf-card ga-card" id="cardGaCred">
            <div class="card-label">Credential Entry Views</div>
            <div class="card-value" id="valGaCred">-</div>
            <div class="card-sub" id="subGaCred"></div>
          </div>
          <div class="perf-card cs-card" id="cardCsUser">
            <div class="card-label">User Data (Sessions)</div>
            <div class="card-value" id="valCsUser">-</div>
            <div class="card-sub" id="subCsUser"></div>
          </div>

          <!-- Row 3: Conversion & Outcomes -->
          <div class="grid-row-label">Conversion & Outcomes</div>
          <div class="perf-card cs-card" id="cardCsCred">
            <div class="card-label">Credential Entry (Sessions)</div>
            <div class="card-value" id="valCsCred">-</div>
            <div class="card-sub" id="subCsCred"></div>
          </div>
          <div class="perf-card" id="cardLaunchCredPct">
            <div class="card-label">Sel → Credential %</div>
            <div class="card-value" id="valLaunchCredPct">-</div>
            <div class="card-sub" id="subLaunchCredPct"></div>
          </div>
          <div class="perf-card highlight" id="cardSuccessSessions">
            <div class="card-label">Sessions w/ Successful Placements</div>
            <div class="card-value" id="valSuccessSessions">-</div>
            <div class="card-sub" id="subSuccessSessions"></div>
          </div>
          <div class="perf-card" id="cardAvgSuccessPerSession">
            <div class="card-label">Avg Successful Cards Per Session</div>
            <div class="card-value" id="valAvgSuccessPerSession">-</div>
            <div class="card-sub" id="subAvgSuccessPerSession"></div>
          </div>

          <!-- Row 4: Session Depth Analysis -->
          <div class="grid-row-label">Session Depth Analysis</div>
          <div class="perf-card stats-card" id="cardMerchantsPerSession" title="How many merchants cardholders attempt per session (sessions with at least one attempt)">
            <div class="card-label">Merchants Per Session</div>
            <div class="stats-chips" id="merchantStatsChips">
              <span class="stats-chip"><b>MEDIAN</b> <span class="chip-val" id="chipMedian">—</span></span>
              <span class="stats-chip"><b>MODE</b> <span class="chip-val" id="chipMode">—</span></span>
              <span class="stats-chip"><b>P75</b> <span class="chip-val" id="chipP75">—</span></span>
            </div>
            <div class="stats-bottom-row">
              <span class="stats-chip"><b>AVG</b> <span class="chip-val" id="chipAvg">—</span></span>
              <button class="stats-dist-toggle" id="toggleDistribution" type="button" aria-expanded="false">Show distribution &#9662;</button>
              <div class="stats-dist-panel" id="distributionPanel">
                <table class="stats-dist-table">
                  <thead><tr><th>Merchants per session</th><th>Sessions</th></tr></thead>
                  <tbody id="distributionBody"></tbody>
                </table>
                <div class="stats-dist-empty" id="distributionEmpty" hidden>No distribution data available.</div>
              </div>
            </div>
            <div class="card-sub" id="subMerchantsPerSession"></div>
          </div>
          <div class="perf-card cs-card stats-card" id="cardCsSelectDist" title="Select Merchant page views per session">
            <div class="card-label">Select Merchant Views / Session</div>
            <div class="stats-chips" id="csSelectStatsChips">
              <span class="stats-chip"><b>MEDIAN</b> <span class="chip-val" id="csSelectChipMedian">—</span></span>
              <span class="stats-chip"><b>MODE</b> <span class="chip-val" id="csSelectChipMode">—</span></span>
              <span class="stats-chip"><b>P75</b> <span class="chip-val" id="csSelectChipP75">—</span></span>
            </div>
            <div class="stats-bottom-row">
              <span class="stats-chip"><b>AVG</b> <span class="chip-val" id="csSelectChipAvg">—</span></span>
              <button class="stats-dist-toggle" id="csSelectToggleDist" type="button" aria-expanded="false">Show distribution &#9662;</button>
              <div class="stats-dist-panel" id="csSelectDistPanel">
                <table class="stats-dist-table">
                  <thead><tr><th>Views per session</th><th>Sessions</th></tr></thead>
                  <tbody id="csSelectDistBody"></tbody>
                </table>
                <div class="stats-dist-empty" id="csSelectDistEmpty" hidden>No data available.</div>
              </div>
            </div>
            <div class="card-sub" id="csSelectDistSub"></div>
          </div>
          <div class="perf-card cs-card stats-card" id="cardCsUserDist" title="User Data page views per session">
            <div class="card-label">User Data Views / Session</div>
            <div class="stats-chips" id="csUserStatsChips">
              <span class="stats-chip"><b>MEDIAN</b> <span class="chip-val" id="csUserChipMedian">—</span></span>
              <span class="stats-chip"><b>MODE</b> <span class="chip-val" id="csUserChipMode">—</span></span>
              <span class="stats-chip"><b>P75</b> <span class="chip-val" id="csUserChipP75">—</span></span>
            </div>
            <div class="stats-bottom-row">
              <span class="stats-chip"><b>AVG</b> <span class="chip-val" id="csUserChipAvg">—</span></span>
              <button class="stats-dist-toggle" id="csUserToggleDist" type="button" aria-expanded="false">Show distribution &#9662;</button>
              <div class="stats-dist-panel" id="csUserDistPanel">
                <table class="stats-dist-table">
                  <thead><tr><th>Views per session</th><th>Sessions</th></tr></thead>
                  <tbody id="csUserDistBody"></tbody>
                </table>
                <div class="stats-dist-empty" id="csUserDistEmpty" hidden>No data available.</div>
              </div>
            </div>
            <div class="card-sub" id="csUserDistSub"></div>
          </div>
          <div class="perf-card cs-card stats-card" id="cardCsCredDist" title="Credential Entry page views per session">
            <div class="card-label">Credential Entry Views / Session</div>
            <div class="stats-chips" id="csCredStatsChips">
              <span class="stats-chip"><b>MEDIAN</b> <span class="chip-val" id="csCredChipMedian">—</span></span>
              <span class="stats-chip"><b>MODE</b> <span class="chip-val" id="csCredChipMode">—</span></span>
              <span class="stats-chip"><b>P75</b> <span class="chip-val" id="csCredChipP75">—</span></span>
            </div>
            <div class="stats-bottom-row">
              <span class="stats-chip"><b>AVG</b> <span class="chip-val" id="csCredChipAvg">—</span></span>
              <button class="stats-dist-toggle" id="csCredToggleDist" type="button" aria-expanded="false">Show distribution &#9662;</button>
              <div class="stats-dist-panel" id="csCredDistPanel">
                <table class="stats-dist-table">
                  <thead><tr><th>Views per session</th><th>Sessions</th></tr></thead>
                  <tbody id="csCredDistBody"></tbody>
                </table>
                <div class="stats-dist-empty" id="csCredDistEmpty" hidden>No data available.</div>
              </div>
            </div>
            <div class="card-sub" id="csCredDistSub"></div>
          </div>
        </div>
      </div>

      <!-- Highlights -->
      <div id="highlightsSection" style="display:none;">
        <div class="perf-section-title">Performance Highlights <span class="muted">(Best 7-Day Windows)</span></div>
        <div id="bestWindows"></div>
      </div>

      <!-- Per-FI Conversion Tables -->
      <div id="fiTablesSection" style="display:none;">
        <div class="perf-section-title">FI Performance Detail</div>

        <div class="group-block" data-group="SSO" style="display:none;">
          <div class="group-header">SSO</div>
          <div class="table-scroll">
          <table class="fi-table" id="table-SSO">
          <thead><tr>
            <th data-sort="fi">Financial Institution</th>
            <th data-sort="instances">Instance</th>
            <th data-sort="integration">Integration</th>
            <th data-sort="ga_select" class="num ga-col">Launches</th>
            <th data-sort="cs_select" class="num">Sess @Select</th>
            <th data-sort="ga_cred" class="num ga-col">Credential Views</th>
            <th data-sort="reach" class="num">Monthly Reach %</th>
            <th data-sort="sel_cred_pct" class="num">Sel→Cred %</th>
            <th data-sort="sel_success_pct" class="num">Sel→Succ %</th>
            <th data-sort="sessions" class="num">Sessions</th>
            <th data-sort="sess_with_success" class="num">Successful Sessions</th>
            <th data-sort="sess_success_pct" class="num">Session Success %</th>
            <th data-sort="placements" class="num">Placements</th>
          </tr></thead>
          <tbody></tbody>
          </table>
          </div>
        </div>

        <div class="group-block" data-group="NON-SSO" style="display:none;">
          <div class="group-header">NON-SSO</div>
          <div class="table-scroll">
          <table class="fi-table" id="table-NON-SSO">
          <thead><tr>
            <th data-sort="fi">Financial Institution</th>
            <th data-sort="instances">Instance</th>
            <th data-sort="integration">Integration</th>
            <th data-sort="ga_select" class="num ga-col">Launches</th>
            <th data-sort="cs_select" class="num">Sess @Select</th>
            <th data-sort="ga_user" class="num ga-col">User Data Views</th>
            <th data-sort="ga_cred" class="num ga-col">Credential Views</th>
            <th data-sort="reach" class="num">Monthly Reach %</th>
            <th data-sort="sel_user_pct" class="num">Sel→User %</th>
            <th data-sort="sel_cred_pct" class="num">Sel→Cred %</th>
            <th data-sort="sel_success_pct" class="num">Sel→Succ %</th>
            <th data-sort="sessions" class="num">Sessions</th>
            <th data-sort="sess_with_success" class="num">Successful Sessions</th>
            <th data-sort="sess_success_pct" class="num">Session Success %</th>
            <th data-sort="placements" class="num">Placements</th>
          </tr></thead>
          <tbody></tbody>
          </table>
          </div>
        </div>

        <div class="group-block" data-group="CardSavr" style="display:none;">
          <div class="group-header">CardSavr</div>
          <div class="table-scroll">
          <table class="fi-table" id="table-CardSavr">
          <thead><tr>
            <th data-sort="fi">Financial Institution</th>
            <th data-sort="instances">Instance</th>
            <th data-sort="integration">Integration</th>
            <th data-sort="ga_select" class="num ga-col">Launches</th>
            <th data-sort="cs_select" class="num">Sess @Select</th>
            <th data-sort="ga_user" class="num ga-col">User Data Views</th>
            <th data-sort="ga_cred" class="num ga-col">Credential Views</th>
            <th data-sort="reach" class="num">Monthly Reach %</th>
            <th data-sort="sel_user_pct" class="num">Sel→User %</th>
            <th data-sort="sel_cred_pct" class="num">Sel→Cred %</th>
            <th data-sort="sel_success_pct" class="num">Sel→Succ %</th>
            <th data-sort="sessions" class="num">Sessions</th>
            <th data-sort="sess_with_success" class="num">Successful Sessions</th>
            <th data-sort="sess_success_pct" class="num">Session Success %</th>
            <th data-sort="placements" class="num">Placements</th>
          </tr></thead>
          <tbody></tbody>
          </table>
          </div>
        </div>

        <div class="group-block" data-group="UNKNOWN" style="display:none;">
          <div class="group-header">Other</div>
          <div class="table-scroll">
          <table class="fi-table" id="table-UNKNOWN">
          <thead><tr>
            <th data-sort="fi">Financial Institution</th>
            <th data-sort="instances">Instance</th>
            <th data-sort="integration">Integration</th>
            <th data-sort="ga_select" class="num ga-col">Launches</th>
            <th data-sort="cs_select" class="num">Sess @Select</th>
            <th data-sort="ga_user" class="num ga-col">User Data Views</th>
            <th data-sort="ga_cred" class="num ga-col">Credential Views</th>
            <th data-sort="reach" class="num">Monthly Reach %</th>
            <th data-sort="sel_user_pct" class="num">Sel→User %</th>
            <th data-sort="sel_cred_pct" class="num">Sel→Cred %</th>
            <th data-sort="sel_success_pct" class="num">Sel→Succ %</th>
            <th data-sort="sessions" class="num">Sessions</th>
            <th data-sort="sess_with_success" class="num">Successful Sessions</th>
            <th data-sort="sess_success_pct" class="num">Session Success %</th>
            <th data-sort="placements" class="num">Placements</th>
          </tr></thead>
          <tbody></tbody>
          </table>
          </div>
        </div>
      </div>

      <!-- Single-FI Time Breakdowns -->
      <div id="singleFiView" style="display:none;"></div>

      <!-- Partner Integration Mix -->
      <div id="partnerSummary" class="partner-summary" style="display:none;"></div>

    </section>
  </main>
  </div>

  <script>
    // ─── DOM references ───
    const startDateInput = document.getElementById("startDate");
    const endDateInput = document.getElementById("endDate");
    const dateWarningEl = document.getElementById("dateWarning");
    const applyBtn = document.getElementById("applyBtn");
    const exportCsvBtn = document.getElementById("exportCsvBtn");
    const loaderEl = document.getElementById("pageLoader");
    const loaderTextEl = loaderEl?.querySelector(".loading-text");
    const bestWindowsDiv = document.getElementById("bestWindows");
    const partnerSummaryBox = document.getElementById("partnerSummary");
    const dateWindowLabel = document.getElementById("dateWindowLabel");
    const perfOverview = document.getElementById("perfOverview");
    const highlightsSection = document.getElementById("highlightsSection");
    const totalsBar = document.getElementById("totalsBar");

    // ─── Constants ───
    const FI_ALL_VALUE = "__all__";
    const PARTNER_ALL_VALUE = "__all_partners__";
    const INSTANCE_ALL_VALUE = "__all_instances__";
    const MIN_SELECTS = 10;

    // ─── State ───
    let registryMap = {};
    let dailyFiles = [];
    let dailyData = {};
    let lastAggregated = null;
    let lastRenderContext = null;
    let lastFilterSnapshot = null;
    let latestVisibleRows = [];
    let latestSingleFiBreakdowns = null;
    let lastActiveTab = null;
    let latestHighlights = [];
    let latestPartnerSummary = null;
    let latestDailyDate = null;
    let earliestDailyDate = null;

    // ─── Helpers ───
    const nextFrame = () => new Promise((resolve) => requestAnimationFrame(resolve));
    const dayMs = 86400000;

    const isoLocalFromDate = (d) => {
      const copy = new Date(d.getTime());
      copy.setHours(0, 0, 0, 0);
      const tzOffset = copy.getTimezoneOffset() * 60000;
      return new Date(copy.getTime() - tzOffset).toISOString().slice(0, 10);
    };
    const isoLocalToday = () => isoLocalFromDate(new Date());
    const isoLocalDaysAgo = (n) => {
      const d = new Date();
      d.setDate(d.getDate() - n);
      return isoLocalFromDate(d);
    };
    const isoLocalYesterday = () => isoLocalDaysAgo(1);
    const defaultEndDateStr = isoLocalYesterday();
    const defaultStartDateStr = isoLocalDaysAgo(6);

    const getLatestUsableDateIso = () => isoLocalYesterday();
    const getMaxSelectableDateIso = () => isoLocalToday();

    function getReferenceDate() {
      return new Date(`${getLatestUsableDateIso()}T00:00:00Z`);
    }

    function enforceEndDateBounds() {
      try {
        const baseIso = getMaxSelectableDateIso();
        if (endDateInput && endDateInput.value && endDateInput.value > baseIso) {
          endDateInput.value = baseIso;
        }
        if (startDateInput && endDateInput && startDateInput.value && endDateInput.value && startDateInput.value > endDateInput.value) {
          startDateInput.value = endDateInput.value;
        }
      } catch (err) {}
    }

    function renderDateWarning() {
      if (!dateWarningEl) return;
      try {
        if (!latestDailyDate) { dateWarningEl.style.display = "none"; dateWarningEl.textContent = ""; return; }
        const chosenEnd = endDateInput?.value;
        if (!chosenEnd || chosenEnd <= latestDailyDate) { dateWarningEl.style.display = "none"; dateWarningEl.textContent = ""; return; }
        dateWarningEl.innerHTML = `Note: data is available through ${latestDailyDate}. You selected ${chosenEnd}.`;
        dateWarningEl.style.display = "block";
      } catch (err) {}
    }

    function applyPresetRange(value) {
      const ref = getReferenceDate();
      const iso = (d) => d.toISOString().slice(0, 10);
      const daysAgo = (n) => iso(new Date(ref.getTime() - n * dayMs));
      const startOfYear = `${ref.getUTCFullYear()}-01-01`;
      let start = daysAgo(6);
      let end = iso(ref);
      switch (value) {
        case "last7": start = daysAgo(6); break;
        case "last14": start = daysAgo(13); break;
        case "last30": start = daysAgo(29); break;
        case "last60": start = daysAgo(59); break;
        case "last90": start = daysAgo(89); break;
        case "ytd": start = startOfYear; break;
        default: start = daysAgo(6);
      }
      startDateInput.value = start;
      endDateInput.value = end;
      renderDateWarning();
    }

    function applyDefaultDateRange(force = false) {
      if (force || !startDateInput.value || !endDateInput.value) {
        applyPresetRange("last7");
        const preset = document.getElementById("datePreset");
        if (preset) preset.value = "last7";
      }
    }

    function ensureDateDefaults() {
      if (!startDateInput.value) startDateInput.value = defaultStartDateStr;
      if (!endDateInput.value) endDateInput.value = defaultEndDateStr;
      enforceEndDateBounds();
    }

    const normalizeFiKey = (value) => value ? value.toString().trim().toLowerCase() : "";
    const normalizeInstanceKey = (value) => {
      if (!value) return "unknown";
      const str = value.toString().trim().toLowerCase();
      const normalized = str.replace(/[^a-z0-9]/g, "");
      return normalized || "unknown";
    };
    const makeFiInstanceKey = (fi, instance) => `${normalizeFiKey(fi)}__${normalizeInstanceKey(instance)}`;
    const parseFiInstanceKey = (key = "") => {
      if (!key.includes("__")) return { fi: key, instance: "unknown" };
      const [fi, instance] = key.split("__");
      return { fi, instance: instance || "unknown" };
    };

    const normalizeIntegrationKey = (val) => {
      const upper = (val || "").toString().trim().toUpperCase();
      if (upper === "NON-SSO" || upper === "NON_SSO" || upper === "NONSSO") return "NON-SSO";
      if (upper === "SSO") return "SSO";
      return upper;
    };

    function normalizeIntegrationLabel(value) {
      if (!value) return "NON-SSO";
      const raw = value.toString().trim().toUpperCase().replace(/[_\s-]+/g, "-");
      if (raw === "SSO") return "SSO";
      if (raw === "CARDSAVR" || raw === "CARD-SAVR" || raw === "CARDSAVER") return "CardSavr";
      if (raw === "TEST") return "TEST";
      if (raw === "UNKNOWN") return "UNKNOWN";
      return "NON-SSO";
    }

    function formatPartnerLabel(value) {
      if (!value) return "Unknown";
      return value.toString();
    }

    function parseDateUtc(dateStr) { return new Date(`${dateStr}T00:00:00Z`); }
    function formatDateUtc(dateObj) { return dateObj.toISOString().slice(0, 10); }
    function addDaysUtc(dateObj, days) {
      const d = new Date(dateObj);
      d.setUTCDate(d.getUTCDate() + days);
      return d;
    }

    function dayCountInclusive(start, end) {
      if (!start || !end) return null;
      const diff = Math.floor((parseDateUtc(end) - parseDateUtc(start)) / dayMs);
      return diff >= 0 ? diff + 1 : null;
    }

    function inRange(date, start, end) {
      if (!date) return false;
      if (start && date < start) return false;
      if (end && date > end) return false;
      return true;
    }

    function dayBefore(dateStr) {
      const d = new Date(dateStr + "T00:00:00Z");
      d.setUTCDate(d.getUTCDate() - 1);
      return d.toISOString().slice(0, 10);
    }

    const INSTANCE_DISPLAY_OVERRIDES = new Map([["digital-onboarding", "digitalonboarding"]]);
    function formatInstanceDisplay(value) {
      if (!value) return "unknown";
      const base = value.toString().trim().toLowerCase().replace(/[\s_]+/g, "-");
      const display = base || "unknown";
      return INSTANCE_DISPLAY_OVERRIDES.get(display) || display;
    }

    function getBillablePlacementCount(placements) {
      if (!placements || typeof placements !== "object") return 0;
      if (typeof placements.successful_placements === "number") return placements.successful_placements;
      if (placements.by_termination && typeof placements.by_termination.BILLABLE === "number") return placements.by_termination.BILLABLE;
      if (typeof placements.total_placements === "number") return placements.total_placements;
      if (typeof placements.total === "number") return placements.total;
      return 0;
    }

    // ─── Registry lookups ───
    const registryInfoMap = new Map();
    const registryCardholderMap = new Map();

    function buildRegistryLookupKey(fiName, instanceValue) {
      return makeFiInstanceKey(normalizeFiKey(fiName), normalizeInstanceKey(instanceValue));
    }

    function updateRegistryLookups(registryData = {}) {
      registryInfoMap.clear();
      registryCardholderMap.clear();
      Object.values(registryData || {}).forEach((entry) => {
        if (!entry || typeof entry !== "object") return;
        const fiKey = normalizeFiKey(entry.fi_lookup_key || entry.fi_name);
        const instanceValue = entry.instance || null;
        const comboKey = buildRegistryLookupKey(fiKey, instanceValue);
        if (comboKey && !registryInfoMap.has(comboKey)) registryInfoMap.set(comboKey, entry);
        if (fiKey && !registryInfoMap.has(fiKey)) registryInfoMap.set(fiKey, entry);
        const total = Number(entry.cardholder_total);
        if (!Number.isFinite(total) || total <= 0) return;
        const info = { total, as_of: entry.cardholder_as_of || null, source: entry.cardholder_source || null };
        if (comboKey && !registryCardholderMap.has(comboKey)) registryCardholderMap.set(comboKey, info);
        if (fiKey && !registryCardholderMap.has(fiKey)) registryCardholderMap.set(fiKey, info);
      });
    }

    function getRegistryEntry(fiName, instanceValue) {
      const fiKey = normalizeFiKey(fiName);
      const comboKey = buildRegistryLookupKey(fiName, instanceValue);
      return registryInfoMap.get(comboKey) || registryInfoMap.get(fiKey) || null;
    }

    function getRegistryCardholderInfo(fiName, instanceValue) {
      const fiKey = normalizeFiKey(fiName);
      const comboKey = buildRegistryLookupKey(fiName, instanceValue);
      return registryCardholderMap.get(comboKey) || registryCardholderMap.get(fiKey) || null;
    }

    // ─── Data loading ───
    async function fetchJson(url) {
      const res = await fetch(url);
      if (!res.ok) throw new Error(`${url} → ${res.status}`);
      return res.json();
    }

    function deriveIntegration(meta) {
      const raw = (meta?.integration_type || "").toString().toLowerCase();
      const instances = (meta?.instances || []).map((inst) => (inst || "").toString().toLowerCase());
      const hasOnDot = instances.some((inst) => inst.includes("ondot"));
      if (hasOnDot || raw === "cardsavr") return "CardSavr";
      if (raw === "sso") return "SSO";
      return "NON-SSO";
    }

    function extractInstances(meta) {
      if (!meta || typeof meta !== "object") return [];
      const list = Array.isArray(meta.instances) ? meta.instances.slice() : [];
      if (meta.instance) list.push(meta.instance);
      return Array.from(new Set(list.filter(Boolean).map((inst) => inst.toString()))).sort((a, b) => a.localeCompare(b));
    }

    async function fetchRegistry() {
      const data = await fetchJson("/fi-registry");
      const map = {};
      const precedence = { CardSavr: 3, SSO: 2, "NON-SSO": 1 };
      const mergeEntry = (key, payload) => {
        if (!key) return;
        if (!map[key]) { map[key] = { ...payload }; return; }
        const existing = map[key];
        const incomingPriority = precedence[payload.integration || "NON-SSO"] || 0;
        const existingPriority = precedence[existing.integration || "NON-SSO"] || 0;
        if (incomingPriority > existingPriority) existing.integration = payload.integration;
        const mergedInstances = new Set(existing.instances || []);
        (payload.instances || []).forEach((inst) => mergedInstances.add(inst));
        existing.instances = Array.from(mergedInstances).sort((a, b) => a.localeCompare(b));
        if (!existing.instance && payload.instance) existing.instance = payload.instance;
        if (!existing.fi_lookup_key && payload.fi_lookup_key) existing.fi_lookup_key = payload.fi_lookup_key;
        if (!existing.fi_name && payload.fi_name) existing.fi_name = payload.fi_name;
        if (!existing.partner && payload.partner) existing.partner = payload.partner;
        const incomingCardholders = Number(payload.cardholder_total);
        if (Number.isFinite(incomingCardholders) && incomingCardholders > 0 && (!Number.isFinite(Number(existing.cardholder_total)) || Number(existing.cardholder_total) <= 0)) {
          existing.cardholder_total = payload.cardholder_total;
        }
        if (!existing.cardholder_source && payload.cardholder_source) existing.cardholder_source = payload.cardholder_source;
        if (!existing.cardholder_as_of && payload.cardholder_as_of) existing.cardholder_as_of = payload.cardholder_as_of;
      };
      const assignMeta = (metaLike = {}) => {
        const fiKey = normalizeFiKey(metaLike.fi_lookup_key || metaLike.fi_name || metaLike.fi || "");
        if (!fiKey) return;
        const integration = deriveIntegration(metaLike);
        const instances = extractInstances(metaLike);
        const basePayload = {
          integration, instances, fi_lookup_key: fiKey,
          fi_name: metaLike.fi_name || metaLike.fi || metaLike.fi_lookup_key || "",
          partner: metaLike.partner || null,
          cardholder_total: metaLike.cardholder_total !== undefined ? metaLike.cardholder_total : null,
          cardholder_as_of: metaLike.cardholder_as_of || null,
          cardholder_source: metaLike.cardholder_source || null,
          traffic_first_seen_sso: metaLike.traffic_first_seen_sso || null,
        };
        mergeEntry(fiKey, { ...basePayload });
        if (instances.length) {
          instances.forEach((instance) => {
            const normInstance = normalizeInstanceKey(instance);
            const comboKey = makeFiInstanceKey(fiKey, normInstance);
            mergeEntry(comboKey, { ...basePayload, instances: [instance], instance });
          });
        } else {
          const comboKey = makeFiInstanceKey(fiKey, "unknown");
          mergeEntry(comboKey, { ...basePayload, instances: ["unknown"], instance: "unknown" });
        }
      };
      if (Array.isArray(data)) {
        data.forEach((row) => assignMeta(row || {}));
      } else if (data && typeof data === "object") {
        for (const [fiName, meta] of Object.entries(data)) {
          assignMeta({ fi_name: fiName, ...(meta || {}) });
        }
      }
      return map;
    }

    async function fetchDailyList() {
      const payload = await fetch("/list-daily", { cache: 'no-store' }).then(r => r.json());
      return payload.files || [];
    }

    async function fetchDaily(date) {
      if (window.DataCache) {
        const cached = await window.DataCache.getAsync(`daily_${date}`);
        if (cached) return cached;
      }
      const payload = await fetchJson(`/daily?date=${date}`);
      const result = payload?.error ? null : payload;
      if (result && window.DataCache) await window.DataCache.set(`daily_${date}`, result);
      return result;
    }

    async function fetchDailyRange(startDate, endDate) {
      if (!startDate || !endDate) return null;
      try {
        const payload = await fetchJson(`/daily-range?start=${startDate}&end=${endDate}`);
        if (!payload || payload.error) return null;
        return payload.entries || null;
      } catch (err) { return null; }
    }

    function getCardholderMap() { return {}; }

    // ─── Aggregation ───
    function getFiInstanceEntriesForDay(day) {
      if (day?.fi_instances && Object.keys(day.fi_instances).length) {
        return Object.entries(day.fi_instances).map(([key, row]) => {
          const parsed = parseFiInstanceKey(key);
          const instanceDisplay = formatInstanceDisplay(row.instance || parsed.instance);
          const comboKey = key || makeFiInstanceKey(row.fi_lookup_key || parsed.fi, instanceDisplay);
          return { key: comboKey, fi: row.fi_lookup_key || parsed.fi, instance: instanceDisplay, row };
        });
      }
      if (!day?.fi) return [];
      return Object.entries(day.fi).map(([fiName, row]) => {
        const instances = Array.isArray(row.ga_instances) && row.ga_instances.length ? row.ga_instances : ["unknown"];
        const instanceDisplay = formatInstanceDisplay(instances[0]);
        const comboKey = makeFiInstanceKey(fiName, instanceDisplay);
        return { key: comboKey, fi: fiName, instance: instanceDisplay, row };
      });
    }

    function aggregateData(startDate, endDate, cardholderMap) {
      const perFi = {};
      const dates = Object.keys(dailyData).sort();
      for (const date of dates) {
        if (!inRange(date, startDate, endDate)) continue;
        const day = dailyData[date];
        if (!day?.fi) continue;
        const entries = getFiInstanceEntriesForDay(day);
        for (const entry of entries) {
          const fiName = entry.fi || "unknown_fi";
          const instanceName = entry.instance || "unknown";
          const fiNorm = normalizeFiKey(fiName);
          const comboKey = entry.key || makeFiInstanceKey(fiNorm, instanceName);
          const registryEntry = getRegistryEntry(fiName, instanceName);
          const row = entry.row || {};
          const rowIsTest = Boolean(row.is_test);
          const baseIntegration = normalizeIntegrationLabel(registryEntry?.integration || registryEntry?.integration_type);
          const integration = rowIsTest ? "TEST" : baseIntegration;
          const partnerLabel = formatPartnerLabel(registryEntry?.partner);
          const agg = perFi[comboKey] || {
            key: comboKey, fi: fiName, instance: instanceName, integration_type: integration,
            partner: partnerLabel, ga_select: 0, ga_user: 0, ga_cred: 0,
            cs_select: 0, cs_user: 0, cs_cred: 0,
            sessions: 0, sess_with_jobs: 0, sess_with_success: 0,
            total_jobs: 0, successful_jobs: 0, placements: 0,
            instances: [instanceName], is_test: rowIsTest,
            cardholders: null, cardholder_source: null, cardholder_as_of: null,
          };
          agg.integration_type = integration;
          agg.is_test = agg.is_test || rowIsTest;
          const existingInstanceKey = normalizeInstanceKey(agg.instance);
          const incomingInstanceKey = normalizeInstanceKey(instanceName);
          if (agg.instance === "unknown" || (existingInstanceKey === incomingInstanceKey && agg.instance.indexOf("-") === -1 && instanceName.indexOf("-") !== -1)) {
            agg.instance = instanceName;
          }
          if (!agg.instances.some((v) => normalizeInstanceKey(v) === incomingInstanceKey)) {
            agg.instances.push(instanceName);
          }
          if (row.ga) {
            agg.ga_select += row.ga.select_merchants || 0;
            agg.ga_user += row.ga.user_data_collection || 0;
            agg.ga_cred += row.ga.credential_entry || 0;
          }
          if (row.sessions) {
            agg.sessions += row.sessions.total || 0;
            agg.sess_with_jobs += row.sessions.with_jobs || 0;
            agg.sess_with_success += row.sessions.with_success || 0;
            agg.total_jobs += row.sessions.total_jobs || 0;
            agg.successful_jobs += row.sessions.successful_jobs || 0;
            agg.cs_select += row.sessions.cs_select_sessions || 0;
            agg.cs_user += row.sessions.cs_user_sessions || 0;
            agg.cs_cred += row.sessions.cs_cred_sessions || 0;
          }
          if (row.placements) agg.placements += getBillablePlacementCount(row.placements);
          if (rowIsTest) agg.is_test = true;
          const cardholders = cardholderMap[fiNorm];
          if (typeof cardholders === "number" && cardholders > 0) {
            agg.cardholders = cardholders; agg.cardholder_source = "manual"; agg.cardholder_as_of = null;
          } else {
            const registryInfo = getRegistryCardholderInfo(fiName, instanceName);
            if (registryInfo?.total) {
              agg.cardholders = registryInfo.total; agg.cardholder_source = registryInfo.source || null; agg.cardholder_as_of = registryInfo.as_of || null;
            }
          }
          if (!agg.partner || agg.partner === "Unknown") agg.partner = partnerLabel;
          perFi[comboKey] = agg;
        }
      }
      for (const agg of Object.values(perFi)) {
        const registryInfo = getRegistryEntry(agg.fi, agg.instance);
        const derivedIntegration = registryInfo?.integration || registryInfo?.integration_type || agg.integration_type;
        const instanceKey = normalizeInstanceKey(agg.instance);
        let normalized = agg.is_test ? "TEST" : normalizeIntegrationLabel(derivedIntegration);
        if (instanceKey === "ondot" && normalized !== "TEST") normalized = "CardSavr";
        agg.integration_type = normalized;
      }
      return perFi;
    }

    // ─── Filtering ───
    function getVisibleRows(perFi) {
      const shared = window.__FILTER_STATE;
      // Customer page: never include test data
      const includeTests = false;
      const fiTouched = shared && shared.__fiTouched;
      if (shared && shared.page === "funnel-customer") {
        const sharedFiSet = shared.fis ? new Set(Array.from(shared.fis).map((fi) => normalizeFiKey(fi))) : new Set();
        const partnerSet = shared.partnerSetNormalized instanceof Set ? shared.partnerSetNormalized : null;
        const integrationSet = shared.integrationSetNormalized instanceof Set ? shared.integrationSetNormalized : null;
        const partnerSetActive = Boolean(shared.__partnerSetTouched);
        const integrationSetActive = Boolean(shared.__integrationSetTouched);
        const instanceSet = shared.instanceSetNormalized instanceof Set ? shared.instanceSetNormalized : null;
        const instanceSetActive = Boolean(shared.__instanceSetTouched);
        return Object.values(perFi).filter((row) => {
          if (!includeTests && row.is_test) return false;
          if (fiTouched && sharedFiSet.size === 0) return false;
          if (partnerSetActive && (!partnerSet || partnerSet.size === 0)) return false;
          if (integrationSetActive && (!integrationSet || integrationSet.size === 0)) return false;
          if (partnerSetActive && partnerSet && partnerSet.size) {
            const rowPartner = row.partner || "Unknown";
            if (!partnerSet.has(rowPartner)) return false;
          }
          if (integrationSetActive && integrationSet && integrationSet.size) {
            const rowIntegration = normalizeIntegrationKey(row.integration_type || "");
            const allowed = new Set(Array.from(integrationSet).map((v) => normalizeIntegrationKey(v)));
            if (!allowed.has(rowIntegration)) return false;
          }
          if (instanceSetActive) {
            if (!instanceSet || instanceSet.size === 0) return false;
            const rowInstanceKey = normalizeInstanceKey(row.instance);
            if (!instanceSet.has(rowInstanceKey)) return false;
          }
          if (sharedFiSet.size) {
            const fiKey = normalizeFiKey(row.fi);
            if (!sharedFiSet.has(fiKey)) return false;
          }
          return true;
        });
      }
      // Fallback: enforce user scope
      let allowedInstances = null;
      let allowedPartners = null;
      try {
        const user = window.sisAuth?.getUser?.();
        if (user && user.access_level === "limited") {
          if (Array.isArray(user.instance_keys) && user.instance_keys.length > 0) {
            allowedInstances = new Set(user.instance_keys.map(k => (k || "").toString().trim().toLowerCase()));
          }
          if (Array.isArray(user.partner_keys) && user.partner_keys.length > 0) {
            allowedPartners = new Set(user.partner_keys.map(k => (k || "").toString().trim().toLowerCase()));
          }
        }
      } catch (e) {}
      return Object.values(perFi).filter((row) => {
        if (!includeTests && row.is_test) return false;
        if (allowedInstances) {
          const rowInstance = (row.instance || "").toString().trim().toLowerCase();
          if (!allowedInstances.has(rowInstance)) return false;
        }
        if (allowedPartners) {
          const rowPartner = (row.partner || "").toString().trim().toLowerCase();
          if (!allowedPartners.has(rowPartner)) return false;
        }
        return true;
      });
    }

    function isSingleFiSelected() {
      const shared = window.__FILTER_STATE;
      if (shared && shared.page === "funnel-customer") {
        return shared.fis && shared.fis.size === 1;
      }
      return false;
    }

    // ─── Termination rules (needed for placement categorization) ───
    const TERMINATION_RULES = {
      BILLABLE: { label: "Successful", severity: "success" },
      SITE_INTERACTION_FAILURE: { label: "Automation / site failed", severity: "site-failure" },
      UNSUCCESSFUL: { label: "Ran but didn't complete", severity: "site-failure" },
      USER_DATA_FAILURE: { label: "Bad or missing user data", severity: "ux" },
      NEVER_STARTED: { label: "User didn't proceed", severity: "ux" },
      TIMEOUT_CREDENTIALS: { label: "User didn't finish login", severity: "ux" },
      TIMEOUT_TFA: { label: "User didn't finish MFA", severity: "ux" },
      ABANDONED_QUICKSTART: { label: "User bailed from QuickStart", severity: "ux" },
      CANCELED: { label: "User canceled", severity: "ux" },
      ACCOUNT_SETUP_INCOMPLETE: { label: "User didn't finish setup", severity: "ux" },
      TOO_MANY_LOGIN_FAILURES: { label: "User kept failing login", severity: "ux" },
      ACCOUNT_LOCKED: { label: "User account locked", severity: "ux" },
      PASSWORD_RESET_REQUIRED: { label: "Password reset needed", severity: "ux" },
      INVALID_CARD_DETAILS: { label: "Bad card info", severity: "ux" },
      UNKNOWN: { label: "Unknown", severity: "unknown" },
    };

    // ─── Metrics calculation (customer-facing: only positive metrics) ───
    function calculateMetrics(startDate, endDate, visibleRows) {
      const metrics = {
        totalGaSelect: 0, totalGaUser: 0, totalGaCred: 0,
        totalCsSelect: 0, totalCsUser: 0, totalCsCred: 0,
        totalSessions: 0, sessionsWithJobs: 0, sessionsWithSuccessfulJobs: 0,
        totalJobs: 0, successful: 0, totalPlacements: 0,
      };
      for (const row of visibleRows) {
        metrics.totalGaSelect += row.ga_select || 0;
        metrics.totalGaUser += row.ga_user || 0;
        metrics.totalGaCred += row.ga_cred || 0;
        metrics.totalCsSelect += row.cs_select || 0;
        metrics.totalCsUser += row.cs_user || 0;
        metrics.totalCsCred += row.cs_cred || 0;
        metrics.totalSessions += row.sessions || 0;
        metrics.sessionsWithJobs += row.sess_with_jobs || 0;
        metrics.sessionsWithSuccessfulJobs += row.sess_with_success || 0;
        metrics.totalJobs += row.total_jobs || 0;
      }
      // Count placements from daily data (only successful)
      const dates = Object.keys(dailyData).sort();
      for (const date of dates) {
        if (!inRange(date, startDate, endDate)) continue;
        const day = dailyData[date];
        if (!day?.fi_instances) continue;
        for (const fiInstanceKey in day.fi_instances) {
          const fid = day.fi_instances[fiInstanceKey];
          if (!fid?.placements?.by_termination) continue;
          const fiName = fid.fi_lookup_key || fid.fi_name || "";
          const instanceName = fid.instance || "";
          const isVisible = visibleRows.some(row => {
            const rowFi = normalizeFiKey(row.fi || "");
            const dayFi = normalizeFiKey(fiName);
            if (rowFi !== dayFi) return false;
            const rowInstance = normalizeInstanceKey(row.instance);
            const dayInstance = normalizeInstanceKey(instanceName);
            if (rowInstance && rowInstance !== "any" && dayInstance !== rowInstance) return false;
            return true;
          });
          if (!isVisible) continue;
          for (const termType in fid.placements.by_termination) {
            const count = fid.placements.by_termination[termType];
            const rule = TERMINATION_RULES[termType] || TERMINATION_RULES.UNKNOWN;
            if (rule.severity === "success") metrics.successful += count;
            metrics.totalPlacements += count;
          }
        }
      }
      return metrics;
    }

    // ─── Best windows (highlights) ───
    function computeBestWindows(startDate, endDate, perFiLookup = {}, visibleRows = [], monthlyFactor = 1, options = {}) {
      const dates = Object.keys(dailyData).filter((d) => inRange(d, startDate, endDate)).sort();
      if (!dates.length) return [];
      const allowLowVolume = Boolean(options.allowLowVolume);
      const allowedSet = new Set(visibleRows.map((row) => row.key || makeFiInstanceKey(normalizeFiKey(row.fi), normalizeInstanceKey(row.instance))));
      const restrict = allowedSet.size > 0;
      const fiDaily = {};
      for (const date of dates) {
        const day = dailyData[date];
        if (!day?.fi) continue;
        const entries = getFiInstanceEntriesForDay(day);
        for (const entry of entries) {
          const fiDay = entry.row;
          const comboKey = entry.key || makeFiInstanceKey(entry.fi, entry.instance);
          const ga = fiDay.ga || {};
          if (!fiDaily[comboKey]) fiDaily[comboKey] = {};
          fiDaily[comboKey][date] = {
            select: ga.select_merchants || 0, user: ga.user_data_collection || 0,
            cred: ga.credential_entry || 0, cs_select: fiDay.sessions?.cs_select_sessions || 0,
            sessions: fiDay.sessions?.total || 0,
            sess_with_jobs: fiDay.sessions?.with_jobs || 0, sess_with_success: fiDay.sessions?.with_success || 0,
            placements: getBillablePlacementCount(fiDay.placements),
          };
        }
      }
      const perFiByKey = {};
      Object.entries(perFiLookup || {}).forEach(([key, data]) => {
        perFiByKey[key] = data;
        if (data && data.fi) {
          const combo = data.key || makeFiInstanceKey(data.fi, data.instance);
          if (!perFiByKey[combo]) perFiByKey[combo] = data;
        }
      });
      const windows = [
        { label: "Most CardUpdatr Launches", len: 7, minSelects: MIN_SELECTS, minSessions: 0,
          compare: (c, b) => { if (c.sel !== b.sel) return c.sel - b.sel; if (c.sessionSuccessRatio !== b.sessionSuccessRatio) return c.sessionSuccessRatio - b.sessionSuccessRatio; return c.sessions - b.sessions; } },
        { label: "Most CardUpdatr Launches with Successful Placements", len: 7, minSelects: 25, minSessions: 14,
          compare: (c, b) => { if (c.selSuccessRatio !== b.selSuccessRatio) return c.selSuccessRatio - b.selSuccessRatio; if (c.sel !== b.sel) return c.sel - b.sel; return c.sessions - b.sessions; } },
        { label: "Most Cardholders Starting Merchant Placements", len: 7, minSelects: MIN_SELECTS, minSessions: MIN_SELECTS,
          compare: (c, b) => { if (c.sessions !== b.sessions) return c.sessions - b.sessions; if (c.sessionSuccessRatio !== b.sessionSuccessRatio) return c.sessionSuccessRatio - b.sessionSuccessRatio; return c.sel - b.sel; } },
        { label: "Most Cardholders Successfully Placing a Card", len: 7, minSelects: MIN_SELECTS, minSessions: MIN_SELECTS,
          compare: (c, b) => { if (c.sess_with_success !== b.sess_with_success) return c.sess_with_success - b.sess_with_success; if (c.sessions !== b.sessions) return c.sessions - b.sessions; return c.sel - b.sel; } },
      ];
      const results = [];
      for (const config of windows) {
        const { label, len } = config;
        if (dates.length < len) { results.push({ label, empty: true }); continue; }
        const compareFn = config.compare;
        const minSelects = allowLowVolume ? 1 : config.minSelects || MIN_SELECTS;
        const minSessions = allowLowVolume ? 1 : config.minSessions || 0;
        let best = null;
        for (const [comboKey, dailyMap] of Object.entries(fiDaily)) {
          if (restrict && !allowedSet.has(comboKey)) continue;
          for (let idx = 0; idx <= dates.length - len; idx += 1) {
            let sel = 0, user = 0, cred = 0, csSelect = 0, sessions = 0, sessWithJobs = 0, sessWithSuccess = 0, placements = 0;
            for (let offset = 0; offset < len; offset += 1) {
              const stats = dailyMap[dates[idx + offset]];
              if (stats) {
                sel += stats.select || 0; user += stats.user || 0; cred += stats.cred || 0;
                csSelect += stats.cs_select || 0;
                sessions += stats.sessions || 0; sessWithJobs += stats.sess_with_jobs || 0;
                sessWithSuccess += stats.sess_with_success || 0; placements += stats.placements || 0;
              }
            }
            if (sel < minSelects || sessions < minSessions) continue;
            const sessionSuccessRatio = sessions ? sessWithSuccess / sessions : 0;
            const selSuccessRatio = csSelect ? sessWithSuccess / csSelect : 0;
            const candidate = {
              label, key: comboKey,
              fi: perFiByKey[comboKey]?.fi || comboKey,
              instance: perFiByKey[comboKey]?.instance || parseFiInstanceKey(comboKey).instance,
              start: dates[idx], end: dates[idx + len - 1],
              sel, user, cred, sessionSuccessRatio, selSuccessRatio,
              sessions, sess_with_jobs: sessWithJobs, sess_with_success: sessWithSuccess, placements,
            };
            if (!best || compareFn(candidate, best) > 0) best = candidate;
          }
        }
        if (best) {
          const aggRow = perFiByKey[best.key] || {};
          const registryInfo = getRegistryEntry(best.fi, best.instance);
          best.instances = (aggRow.instances || registryInfo?.instances || [best.instance]).join(", ");
          best.integration = normalizeIntegrationLabel(aggRow.integration_type || registryInfo?.integration || "UNKNOWN");
          best.partner = aggRow.partner || registryInfo?.partner || "";
          results.push(best);
        } else {
          results.push({ label, empty: true });
        }
      }
      return results;
    }

    // ─── Partner summary ───
    function buildPartnerSummaryData(rows = [], daySpan = 0, partnerValue = PARTNER_ALL_VALUE) {
      if (!rows || !rows.length || !partnerValue || partnerValue === PARTNER_ALL_VALUE) return null;
      const relevant = rows.filter((row) => (row.partner || "Unknown") === partnerValue);
      if (!relevant.length) return null;
      const makeBucket = () => ({ fiCount: 0, ga_select: 0, cs_select: 0, sessions: 0, sess_with_success: 0, placements: 0, cardholders: 0 });
      const buckets = { SSO: makeBucket(), "NON-SSO": makeBucket() };
      relevant.forEach((row) => {
        const key = row.integration_type === "SSO" ? "SSO" : row.integration_type === "NON-SSO" ? "NON-SSO" : null;
        if (!key) return;
        const bucket = buckets[key];
        bucket.ga_select += row.ga_select || 0;
        bucket.cs_select += row.cs_select || 0;
        bucket.sessions += row.sessions || 0;
        bucket.sess_with_success += row.sess_with_success || 0;
        bucket.placements += row.placements || 0;
        if (typeof row.cardholders === "number" && row.cardholders > 0) bucket.cardholders += row.cardholders;
        bucket.fiCount += 1;
      });
      const monthlyFactor = daySpan ? 30 / daySpan : 1;
      const totals = makeBucket();
      const bucketSummaries = Object.entries(buckets).map(([key, bucket]) => {
        bucket.selSuccessPct = bucket.cs_select > 0 && bucket.sess_with_success > 0 ? (bucket.sess_with_success / bucket.cs_select) * 100 : null;
        bucket.sessionSuccessPct = bucket.sessions > 0 && bucket.sess_with_success > 0 ? (bucket.sess_with_success / bucket.sessions) * 100 : null;
        totals.ga_select += bucket.ga_select; totals.cs_select += bucket.cs_select; totals.sessions += bucket.sessions;
        totals.sess_with_success += bucket.sess_with_success; totals.placements += bucket.placements;
        totals.cardholders += bucket.cardholders; totals.fiCount += bucket.fiCount;
        return { key, bucket };
      });
      const rowsOut = bucketSummaries.map(({ key, bucket }) => ({
        integration: key, fiCount: bucket.fiCount, ga_select: bucket.ga_select,
        selSuccessPct: bucket.selSuccessPct, sessions: bucket.sessions,
        sess_with_success: bucket.sess_with_success, sessionSuccessPct: bucket.sessionSuccessPct,
      }));
      totals.selSuccessPct = totals.cs_select > 0 && totals.sess_with_success > 0 ? (totals.sess_with_success / totals.cs_select) * 100 : null;
      totals.sessionSuccessPct = totals.sessions > 0 && totals.sess_with_success > 0 ? (totals.sess_with_success / totals.sessions) * 100 : null;
      return {
        partner: partnerValue, daySpan, rows: rowsOut,
        totals: { integration: "Total", fiCount: totals.fiCount, ga_select: totals.ga_select, selSuccessPct: totals.selSuccessPct, sessions: totals.sessions, sess_with_success: totals.sess_with_success, sessionSuccessPct: totals.sessionSuccessPct },
        instanceCount: relevant.length,
      };
    }

    // ─── Loading UI ───
    let loaderTimer = null;
    let loaderStartedAt = 0;
    const MIN_LOADER_MS = 350;
    const setLoaderMessage = (msg) => { if (loaderTextEl && msg) loaderTextEl.textContent = msg; };
    function startLoading(message = "Loading data…") {
      if (!loaderEl) return;
      if (loaderTimer) { clearTimeout(loaderTimer); loaderTimer = null; }
      loaderStartedAt = Date.now();
      loaderEl.style.display = "flex"; loaderEl.style.visibility = "visible"; loaderEl.style.opacity = "1";
      setLoaderMessage(message);
    }
    function stopLoading() {
      if (!loaderEl) return;
      const elapsed = Date.now() - loaderStartedAt;
      if (elapsed < MIN_LOADER_MS) { loaderTimer = setTimeout(stopLoading, MIN_LOADER_MS - elapsed); return; }
      loaderTimer = null;
      loaderEl.style.display = "none"; loaderEl.style.visibility = "hidden"; loaderEl.style.opacity = "0";
      if (loaderTextEl) loaderTextEl.textContent = "";
    }

    // ─── Rendering ───
    const fmt = (n) => typeof n === "number" && Number.isFinite(n) ? n.toLocaleString("en-US") : "0";
    const pct = (num, den) => den > 0 ? ((num / den) * 100).toFixed(1) + "%" : "—";

    function escapeHtml(text) {
      if (!text) return '';
      const div = document.createElement('div');
      div.textContent = text.toString();
      return div.innerHTML;
    }

    async function fetchPlacementDetails(type) {
      const shared = window.__FILTER_STATE || {};
      let fiParam = '__all__';
      if (shared.fis && shared.fis.size > 0) {
        fiParam = Array.from(shared.fis).join(',');
      }
      let partnerParam = '__all_partners__';
      if (shared.__partnerSetTouched && shared.partnerSet && shared.partnerSet.size > 0) {
        partnerParam = Array.from(shared.partnerSet).join(',');
      }
      let integrationParam = '(all)';
      if (shared.integrationSet && shared.integrationSet.size > 0) {
        const arr = Array.from(shared.integrationSet);
        if (arr.length === 1) integrationParam = arr[0];
      }
      let instanceParam = 'All';
      if (shared.instanceSet && shared.instanceSet.size > 0) {
        const arr = Array.from(shared.instanceSet);
        if (arr.length === 1) instanceParam = arr[0];
      }
      const params = new URLSearchParams({
        type,
        startDate: startDateInput?.value || defaultStartDateStr,
        endDate: endDateInput?.value || defaultEndDateStr,
        fi: fiParam,
        partner: partnerParam,
        integration: integrationParam,
        instance: instanceParam,
        includeTest: 'false',
        limit: '1000',
        showAll: 'true',
      });
      const token = window.sisAuth?.getToken?.() || localStorage.getItem("sis_session_token") || "";
      const response = await fetch(`/api/placement-details?${params}`, {
        headers: token ? { Authorization: "Bearer " + token } : {},
      });
      if (!response.ok) throw new Error(`HTTP ${response.status}`);
      return response.json();
    }

    let merchantPopoverReady = false;

    function renderMerchantBreakdown(successful) {
      const detailEl = document.getElementById("merchantDetail");
      if (!detailEl) return;
      detailEl.classList.remove("open");
      if (!successful || successful <= 0) { detailEl.innerHTML = ""; merchantPopoverReady = false; return; }
      merchantPopoverReady = false;
      fetchPlacementDetails("success").then(data => {
        if (!data?.results?.length) { detailEl.innerHTML = ""; merchantPopoverReady = false; return; }
        const topMerchants = data.results
          .sort((a, b) => (b.successCount || b.count || 0) - (a.successCount || a.count || 0))
          .slice(0, 10);
        detailEl.innerHTML = '<div class="merchant-pop-title">Top Merchants</div>' +
          topMerchants.map(m => {
            const count = m.successCount || m.count || 0;
            const mPct = successful > 0 ? ((count / successful) * 100).toFixed(1) : "0.0";
            return `<div class="card-merchant-row"><span>${escapeHtml(m.merchant)}</span><span class="card-merchant-count">${count.toLocaleString()} (${mPct}%)</span></div>`;
          }).join("");
        merchantPopoverReady = true;
      }).catch(() => { detailEl.innerHTML = ""; merchantPopoverReady = false; });
    }

    async function fetchJobsStats() {
      const shared = window.__FILTER_STATE || {};
      const token = window.sisAuth?.getToken?.() || localStorage.getItem("sis_session_token") || "";
      const body = {
        start: startDateInput?.value || defaultStartDateStr,
        end: endDateInput?.value || defaultEndDateStr,
        includeTests: false,
      };
      if (shared.fis && shared.fis.size > 0) body.fi = Array.from(shared.fis);
      if (shared.__partnerSetTouched && shared.partnerSet && shared.partnerSet.size > 0) body.partner = Array.from(shared.partnerSet).join(',');
      if (shared.integrationSet && shared.integrationSet.size > 0) {
        const arr = Array.from(shared.integrationSet);
        if (arr.length === 1) body.integration = arr[0];
      }
      if (shared.instanceSet && shared.instanceSet.size > 0) {
        const arr = Array.from(shared.instanceSet);
        if (arr.length === 1) body.instance = arr[0];
      }
      const resp = await fetch("/sessions/jobs-stats", {
        method: "POST",
        headers: { "Content-Type": "application/json", ...(token ? { Authorization: "Bearer " + token } : {}) },
        body: JSON.stringify(body),
      });
      if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
      return resp.json();
    }

    function renderJobsStatsCard(data) {
      const chipMedian = document.getElementById("chipMedian");
      const chipMode = document.getElementById("chipMode");
      const chipP75 = document.getElementById("chipP75");
      const chipAvg = document.getElementById("chipAvg");
      const subEl = document.getElementById("subMerchantsPerSession");
      const distBody = document.getElementById("distributionBody");
      const distEmpty = document.getElementById("distributionEmpty");
      const distPanel = document.getElementById("distributionPanel");
      // Close panel on new data
      if (distPanel) distPanel.classList.remove("open");
      const toggleBtn = document.getElementById("toggleDistribution");
      if (toggleBtn) toggleBtn.setAttribute("aria-expanded", "false");

      if (!data || !data.distribution || !data.distribution.length) {
        if (chipMedian) chipMedian.textContent = "—";
        if (chipMode) chipMode.textContent = "—";
        if (chipP75) chipP75.textContent = "—";
        if (chipAvg) chipAvg.textContent = "—";
        if (subEl) subEl.textContent = "";
        if (distBody) distBody.innerHTML = "";
        if (distEmpty) distEmpty.hidden = false;
        return;
      }
      // Rebuild sorted array from distribution for quantile calculations
      const sorted = [];
      let totalJobs = 0;
      for (const row of data.distribution) {
        for (let i = 0; i < row.sessions; i++) sorted.push(row.jobsPerSession);
        totalJobs += row.jobsPerSession * row.sessions;
      }
      const n = sorted.length;
      if (n === 0) {
        if (chipMedian) chipMedian.textContent = "—";
        if (chipMode) chipMode.textContent = "—";
        if (chipP75) chipP75.textContent = "—";
        if (chipAvg) chipAvg.textContent = "—";
        if (subEl) subEl.textContent = "";
        if (distBody) distBody.innerHTML = "";
        if (distEmpty) distEmpty.hidden = false;
        return;
      }
      // Quantile helper
      function q(p) {
        const idx = (n - 1) * p;
        const lo = Math.floor(idx), hi = Math.ceil(idx);
        if (hi === lo) return sorted[lo];
        return sorted[lo] + (sorted[hi] - sorted[lo]) * (idx - lo);
      }
      const median = q(0.5);
      const p75 = q(0.75);
      const avg = totalJobs / n;
      // Mode = job count with most sessions
      let mode = null, maxSess = 0;
      for (const row of data.distribution) {
        if (row.sessions > maxSess) { maxSess = row.sessions; mode = row.jobsPerSession; }
      }
      if (chipMedian) chipMedian.textContent = String(Math.round(median));
      if (chipMode) chipMode.textContent = mode !== null ? String(mode) : "—";
      if (chipP75) chipP75.textContent = p75 % 1 === 0 ? String(p75) : p75.toFixed(2);
      if (chipAvg) chipAvg.textContent = avg % 1 === 0 ? String(avg) : avg.toFixed(2);
      if (subEl) subEl.textContent = `${n.toLocaleString()} sessions with attempts`;

      // Populate distribution table
      if (distBody) {
        distBody.innerHTML = data.distribution
          .sort((a, b) => a.jobsPerSession - b.jobsPerSession)
          .map(r => {
            const jobs = r.jobsPerSession;
            const label = jobs + " merchant" + (jobs === 1 ? "" : "s");
            return `<tr><td>${label}</td><td>${r.sessions.toLocaleString()}</td></tr>`;
          }).join("");
      }
      if (distEmpty) distEmpty.hidden = data.distribution.length > 0;
    }

    async function fetchPageviewStats() {
      const shared = window.__FILTER_STATE || {};
      const token = window.sisAuth?.getToken?.() || localStorage.getItem("sis_session_token") || "";
      const body = {
        start: startDateInput?.value || defaultStartDateStr,
        end: endDateInput?.value || defaultEndDateStr,
        includeTests: false,
      };
      if (shared.fis && shared.fis.size > 0) body.fi = Array.from(shared.fis);
      if (shared.__partnerSetTouched && shared.partnerSet && shared.partnerSet.size > 0) body.partner = Array.from(shared.partnerSet).join(',');
      if (shared.integrationSet && shared.integrationSet.size > 0) {
        const arr = Array.from(shared.integrationSet);
        if (arr.length === 1) body.integration = arr[0];
      }
      if (shared.instanceSet && shared.instanceSet.size > 0) {
        const arr = Array.from(shared.instanceSet);
        if (arr.length === 1) body.instance = arr[0];
      }
      const resp = await fetch("/sessions/pageview-stats", {
        method: "POST",
        headers: { "Content-Type": "application/json", ...(token ? { Authorization: "Bearer " + token } : {}) },
        body: JSON.stringify(body),
      });
      if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
      return resp.json();
    }

    function renderPageviewStatsCards(data) {
      renderOnePageviewDist("csSelect", data?.selectMerchants, "view");
      renderOnePageviewDist("csUser", data?.userData, "view");
      renderOnePageviewDist("csCred", data?.credentialEntry, "view");
    }

    function renderOnePageviewDist(prefix, distData, unitLabel) {
      const chipMedian = document.getElementById(`${prefix}ChipMedian`);
      const chipMode = document.getElementById(`${prefix}ChipMode`);
      const chipP75 = document.getElementById(`${prefix}ChipP75`);
      const chipAvg = document.getElementById(`${prefix}ChipAvg`);
      const subEl = document.getElementById(`${prefix}DistSub`);
      const distBody = document.getElementById(`${prefix}DistBody`);
      const distEmpty = document.getElementById(`${prefix}DistEmpty`);
      const distPanel = document.getElementById(`${prefix}DistPanel`);
      if (distPanel) distPanel.classList.remove("open");
      const toggleBtn = document.getElementById(`${prefix}ToggleDist`);
      if (toggleBtn) toggleBtn.setAttribute("aria-expanded", "false");

      if (!distData || !distData.distribution || !distData.distribution.length) {
        if (chipMedian) chipMedian.textContent = "—";
        if (chipMode) chipMode.textContent = "—";
        if (chipP75) chipP75.textContent = "—";
        if (chipAvg) chipAvg.textContent = "—";
        if (subEl) subEl.textContent = "";
        if (distBody) distBody.innerHTML = "";
        if (distEmpty) distEmpty.hidden = false;
        return;
      }
      const sorted = [];
      let totalViews = 0;
      for (const row of distData.distribution) {
        for (let i = 0; i < row.sessions; i++) sorted.push(row.viewsPerSession);
        totalViews += row.viewsPerSession * row.sessions;
      }
      const n = sorted.length;
      if (n === 0) {
        if (chipMedian) chipMedian.textContent = "—";
        if (chipMode) chipMode.textContent = "—";
        if (chipP75) chipP75.textContent = "—";
        if (chipAvg) chipAvg.textContent = "—";
        if (subEl) subEl.textContent = "";
        if (distBody) distBody.innerHTML = "";
        if (distEmpty) distEmpty.hidden = false;
        return;
      }
      function q(p) {
        const idx = (n - 1) * p;
        const lo = Math.floor(idx), hi = Math.ceil(idx);
        if (hi === lo) return sorted[lo];
        return sorted[lo] + (sorted[hi] - sorted[lo]) * (idx - lo);
      }
      const median = q(0.5);
      const p75 = q(0.75);
      const avg = totalViews / n;
      let mode = null, maxSess = 0;
      for (const row of distData.distribution) {
        if (row.sessions > maxSess) { maxSess = row.sessions; mode = row.viewsPerSession; }
      }
      if (chipMedian) chipMedian.textContent = String(Math.round(median));
      if (chipMode) chipMode.textContent = mode !== null ? String(mode) : "—";
      if (chipP75) chipP75.textContent = p75 % 1 === 0 ? String(p75) : p75.toFixed(2);
      if (chipAvg) chipAvg.textContent = avg % 1 === 0 ? String(avg) : avg.toFixed(2);
      if (subEl) subEl.textContent = `${n.toLocaleString()} sessions`;

      if (distBody) {
        distBody.innerHTML = distData.distribution
          .sort((a, b) => a.viewsPerSession - b.viewsPerSession)
          .map(r => {
            const v = r.viewsPerSession;
            const label = v + " " + unitLabel + (v === 1 ? "" : "s");
            return `<tr><td>${label}</td><td>${r.sessions.toLocaleString()}</td></tr>`;
          }).join("");
      }
      if (distEmpty) distEmpty.hidden = distData.distribution.length > 0;
    }

    function renderMetrics(metrics, startDate, endDate, daySpan, fiCount, visibleRows) {
      perfOverview.style.display = "";
      dateWindowLabel.textContent = `Date window: ${startDate} → ${endDate} (${fiCount} FIs)`;

      // Detect all-SSO: auto-hide GA data when all visible FIs are SSO
      const allSso = visibleRows && visibleRows.length > 0 &&
        visibleRows.every(r => normalizeIntegrationLabel(r.integration_type || "") === "SSO");
      const gaToggle = document.getElementById("gaToggle");
      if (gaToggle) {
        gaToggle.checked = !allSso;
        document.body.classList.toggle("hide-ga", allSso);
      }

      document.getElementById("valGaSelect").textContent = fmt(metrics.totalGaSelect);
      document.getElementById("subGaSelect").textContent = "Google Analytics tracked";
      document.getElementById("valGaUser").textContent = fmt(metrics.totalGaUser);
      document.getElementById("subGaUser").textContent = pct(metrics.totalGaUser, metrics.totalGaSelect) + " of launches";
      document.getElementById("valGaCred").textContent = fmt(metrics.totalGaCred);
      document.getElementById("subGaCred").textContent = pct(metrics.totalGaCred, metrics.totalGaSelect) + " of launches";
      document.getElementById("valSessions").textContent = fmt(metrics.totalSessions);
      document.getElementById("subSessions").textContent = allSso ? "CardUpdatr loads via SSO" : pct(metrics.totalSessions, metrics.totalGaSelect) + " of launches";

      const launchCredPct = metrics.totalCsSelect > 0 ? ((metrics.totalCsCred / metrics.totalCsSelect) * 100).toFixed(1) + "%" : "—";
      document.getElementById("valLaunchCredPct").textContent = launchCredPct;
      document.getElementById("subLaunchCredPct").textContent = fmt(metrics.totalCsCred) + " of " + fmt(metrics.totalCsSelect) + " sessions @select";

      document.getElementById("valSuccessSessions").textContent = fmt(metrics.sessionsWithSuccessfulJobs);
      document.getElementById("subSuccessSessions").textContent = pct(metrics.sessionsWithSuccessfulJobs, metrics.totalSessions) + " of sessions";

      const successRate = metrics.totalSessions > 0 ? ((metrics.sessionsWithSuccessfulJobs / metrics.totalSessions) * 100).toFixed(1) + "%" : "—";
      document.getElementById("valSuccessRate").textContent = successRate;

      document.getElementById("valSuccessful").textContent = fmt(metrics.successful);
      document.getElementById("subSuccessful").textContent = "Cards updated at merchants";

      // Merchant breakdown on Successful Placements card
      renderMerchantBreakdown(metrics.successful);

      // Avg Successful Cards Per Session
      const avgSucc = metrics.sessionsWithSuccessfulJobs > 0
        ? (metrics.successful / metrics.sessionsWithSuccessfulJobs).toFixed(2)
        : "—";
      document.getElementById("valAvgSuccessPerSession").textContent = avgSucc;
      document.getElementById("subAvgSuccessPerSession").textContent =
        metrics.sessionsWithSuccessfulJobs > 0
          ? fmt(metrics.successful) + " across " + fmt(metrics.sessionsWithSuccessfulJobs) + " sessions"
          : "";

      // Merchants Per Session (async — calls /sessions/jobs-stats)
      document.getElementById("chipMedian").textContent = "…";
      document.getElementById("chipMode").textContent = "…";
      document.getElementById("chipP75").textContent = "…";
      document.getElementById("chipAvg").textContent = "…";
      document.getElementById("subMerchantsPerSession").textContent = "Loading…";
      fetchJobsStats().then(renderJobsStatsCard).catch(() => renderJobsStatsCard(null));

      // Session clickstream metrics
      document.getElementById("valCsSelect").textContent = fmt(metrics.totalCsSelect);
      document.getElementById("subCsSelect").textContent = fmt(metrics.totalCsSelect) + " of " + fmt(metrics.totalSessions) + " sessions";
      document.getElementById("valCsUser").textContent = fmt(metrics.totalCsUser);
      document.getElementById("subCsUser").textContent = pct(metrics.totalCsUser, metrics.totalCsSelect) + " of sessions @select";
      document.getElementById("valCsCred").textContent = fmt(metrics.totalCsCred);
      document.getElementById("subCsCred").textContent = pct(metrics.totalCsCred, metrics.totalCsSelect) + " of sessions @select";

      // Hide User Data cards when all-SSO (SSO skips user data collection step)
      const cardCsUser = document.getElementById("cardCsUser");
      if (cardCsUser) cardCsUser.style.display = allSso ? "none" : "";
      const cardCsUserDist = document.getElementById("cardCsUserDist");
      if (cardCsUserDist) cardCsUserDist.style.display = allSso ? "none" : "";

      // Clickstream page-view distributions (async)
      ["csSelect", "csUser", "csCred"].forEach(prefix => {
        const el = document.getElementById(`${prefix}ChipMedian`);
        if (el) el.textContent = "…";
        const el2 = document.getElementById(`${prefix}ChipMode`);
        if (el2) el2.textContent = "…";
        const el3 = document.getElementById(`${prefix}ChipP75`);
        if (el3) el3.textContent = "…";
        const el4 = document.getElementById(`${prefix}ChipAvg`);
        if (el4) el4.textContent = "…";
        const sub = document.getElementById(`${prefix}DistSub`);
        if (sub) sub.textContent = "Loading…";
      });
      fetchPageviewStats().then(renderPageviewStatsCards).catch(() => renderPageviewStatsCards(null));

      // Totals bar
      const parts = [];
      parts.push(`sel ${fmt(metrics.totalGaSelect)}`);
      parts.push(`user ${fmt(metrics.totalGaUser)}`);
      parts.push(`cred ${fmt(metrics.totalGaCred)}`);
      parts.push(`sessions ${fmt(metrics.totalSessions)}`);
      parts.push(`sess w/ success ${fmt(metrics.sessionsWithSuccessfulJobs)}`);
      totalsBar.innerHTML = `Totals (${fiCount} FIs): ${parts.join(" | ")}`;
      totalsBar.style.display = "";
    }

    // ─── Per-FI table rendering ───
    const fiTablesSection = document.getElementById("fiTablesSection");
    const singleFiView = document.getElementById("singleFiView");
    const fiTableBodies = {};
    const fiGroupBlocks = {};
    const fiGroupHeaders = {};
    ["SSO", "NON-SSO", "CardSavr", "UNKNOWN"].forEach(key => {
      const block = fiTablesSection?.querySelector(`[data-group="${key}"]`);
      if (block) {
        fiGroupBlocks[key] = block;
        fiGroupHeaders[key] = block.querySelector(".group-header");
        fiTableBodies[key] = block.querySelector("tbody");
      }
    });

    const tableSortState = {};

    function getMonthlyReachValue(row) {
      const cardholders = row?.cardholders;
      if (!cardholders || cardholders <= 0) return 0;
      const dayCount = row.dayCount || dayCountInclusive(row.periodStart || row.start, row.periodEnd || row.end) || lastRenderContext?.daySpan || 1;
      const reachBase = row.ga_select > 0 ? row.ga_select : row.sessions;
      if (!reachBase || dayCount <= 0) return 0;
      const reachMonthly = reachBase * (30 / dayCount);
      return reachMonthly > 0 ? reachMonthly / cardholders : 0;
    }

    function formatMonthlyReachPct(row) {
      const value = getMonthlyReachValue(row);
      return value > 0 ? (value * 100).toFixed(1) + "%" : "";
    }

    function formatSessSuccessPct(row) {
      if (!row.sessions) return "";
      return (((row.sess_with_success || 0) / row.sessions) * 100).toFixed(1) + "%";
    }

    function formatSelSuccessPct(row) {
      const sel = row.cs_select || 0;
      if (!sel || !row.sess_with_success) return "";
      return ((row.sess_with_success / sel) * 100).toFixed(1) + "%";
    }

    function getSortValue(row, key) {
      switch (key) {
        case "fi": return (row.fi || "").toLowerCase();
        case "instances": return (row.instance || "").toLowerCase();
        case "integration": return (row.integration_type || "").toLowerCase();
        case "ga_select": return row.ga_select || 0;
        case "cs_select": return row.cs_select || 0;
        case "ga_user": return row.ga_user || 0;
        case "ga_cred": return row.ga_cred || 0;
        case "reach": return getMonthlyReachValue(row);
        case "sel_user_pct": return row.cs_select ? (row.cs_user || 0) / row.cs_select : 0;
        case "sel_cred_pct": return row.cs_select ? (row.cs_cred || 0) / row.cs_select : 0;
        case "sel_success_pct": return row.cs_select && row.sess_with_success ? row.sess_with_success / row.cs_select : 0;
        case "sessions": return row.sessions || 0;
        case "sess_with_success": return row.sess_with_success || 0;
        case "sess_success_pct": return row.sessions ? (row.sess_with_success || 0) / row.sessions : 0;
        case "placements": return row.placements || 0;
        default: return 0;
      }
    }

    function renderFiRow(row, integration) {
      const isSso = integration === "SSO";
      const instancesText = row.instance || (Array.isArray(row.instances) ? row.instances.join(", ") : "");
      const selUserPct = row.cs_select ? ((row.cs_user / row.cs_select) * 100).toFixed(1) + "%" : "";
      const selCredPct = row.cs_select ? ((row.cs_cred / row.cs_select) * 100).toFixed(1) + "%" : "";
      const selSuccPct = formatSelSuccessPct(row);
      const reachPct = formatMonthlyReachPct(row);
      const reachVal = getMonthlyReachValue(row);
      const reachCls = reachVal >= 0.025 ? " reach-good" : reachVal > 0 ? " reach-low" : "";
      const sessSuccPct = formatSessSuccessPct(row);

      const tr = document.createElement("tr");
      let cells = `
        <td>${row.fi}</td>
        <td>${instancesText}</td>
        <td>${integration}</td>
        <td class="num ga-col">${row.ga_select || 0}</td>
        <td class="num">${row.cs_select || 0}</td>`;
      if (!isSso) cells += `<td class="num ga-col">${row.ga_user || 0}</td>`;
      cells += `
        <td class="num ga-col">${row.ga_cred || 0}</td>
        <td class="num${reachCls}">${reachPct}</td>`;
      if (!isSso) cells += `<td class="num">${selUserPct}</td>`;
      cells += `
        <td class="num">${selCredPct}</td>
        <td class="num">${selSuccPct}</td>
        <td class="num">${row.sessions || 0}</td>
        <td class="num">${row.sess_with_success || 0}</td>
        <td class="num">${sessSuccPct}</td>
        <td class="num">${row.placements || 0}</td>`;
      tr.innerHTML = cells;
      return tr;
    }

    function buildFiTotalsRow(rows, integration) {
      if (!rows.length) return null;
      const isSso = integration === "SSO";
      const t = rows.reduce((acc, r) => {
        acc.ga_select += r.ga_select || 0;
        acc.cs_select += r.cs_select || 0;
        acc.ga_user += r.ga_user || 0;
        acc.ga_cred += r.ga_cred || 0;
        acc.cs_user += r.cs_user || 0;
        acc.cs_cred += r.cs_cred || 0;
        acc.sessions += r.sessions || 0;
        acc.sess_with_success += r.sess_with_success || 0;
        acc.placements += r.placements || 0;
        return acc;
      }, { ga_select: 0, cs_select: 0, ga_user: 0, ga_cred: 0, cs_user: 0, cs_cred: 0, sessions: 0, sess_with_success: 0, placements: 0 });

      const selUserPct = t.cs_select ? ((t.cs_user / t.cs_select) * 100).toFixed(1) + "%" : "";
      const selCredPct = t.cs_select ? ((t.cs_cred / t.cs_select) * 100).toFixed(1) + "%" : "";
      const selSuccPct = t.cs_select && t.sess_with_success ? ((t.sess_with_success / t.cs_select) * 100).toFixed(1) + "%" : "";
      const sessSuccPct = t.sessions ? ((t.sess_with_success / t.sessions) * 100).toFixed(1) + "%" : "";

      const tr = document.createElement("tr");
      tr.className = "totals-row";
      let cells = `
        <td>Total</td>
        <td>\u2014</td>
        <td>${integration}</td>
        <td class="num ga-col">${t.ga_select}</td>
        <td class="num">${t.cs_select}</td>`;
      if (!isSso) cells += `<td class="num ga-col">${t.ga_user}</td>`;
      cells += `
        <td class="num ga-col">${t.ga_cred}</td>
        <td class="num"></td>`;
      if (!isSso) cells += `<td class="num">${selUserPct}</td>`;
      cells += `
        <td class="num">${selCredPct}</td>
        <td class="num">${selSuccPct}</td>
        <td class="num">${t.sessions}</td>
        <td class="num">${t.sess_with_success}</td>
        <td class="num">${sessSuccPct}</td>
        <td class="num">${t.placements}</td>`;
      tr.innerHTML = cells;
      return tr;
    }

    function renderTables(visibleRows, startDate, endDate, daySpan) {
      if (!fiTablesSection) return;

      // Single-FI mode: show time breakdowns instead of integration-bucketed tables
      if (isSingleFiSelected()) {
        fiTablesSection.style.display = "none";
        if (singleFiView) {
          singleFiView.style.display = "";
          renderSingleFiSections(visibleRows, startDate, endDate, daySpan);
        }
        return;
      }

      // Multi-FI mode: hide single-FI view, show integration-bucketed tables
      if (singleFiView) singleFiView.style.display = "none";
      if (!visibleRows.length) { fiTablesSection.style.display = "none"; return; }
      fiTablesSection.style.display = "";

      // Bucket by integration type (no TEST bucket on customer page)
      const bucketed = { SSO: [], "NON-SSO": [], CardSavr: [], UNKNOWN: [] };
      visibleRows.forEach(row => {
        const integration = normalizeIntegrationLabel(row.integration_type || "UNKNOWN");
        row.integration_type = integration;
        // Skip test rows entirely
        if (integration === "TEST") return;
        const key = bucketed[integration] ? integration : "UNKNOWN";
        bucketed[key].push(row);
      });

      Object.entries(bucketed).forEach(([integration, rows]) => {
        const tbody = fiTableBodies[integration];
        if (!tbody) return;
        tbody.innerHTML = "";

        // Sort
        const state = tableSortState[integration];
        let sorted = rows;
        if (state && state.key) {
          const dir = state.dir === "desc" ? -1 : 1;
          sorted = [...rows].sort((a, b) => {
            const va = getSortValue(a, state.key);
            const vb = getSortValue(b, state.key);
            if (typeof va === "string") return dir * va.localeCompare(vb);
            return dir * (va - vb);
          });
        } else {
          sorted = [...rows].sort((a, b) => (b.ga_select || 0) - (a.ga_select || 0));
        }

        sorted.forEach(row => tbody.appendChild(renderFiRow(row, integration)));
        const totalsRow = buildFiTotalsRow(rows, integration);
        if (totalsRow) tbody.appendChild(totalsRow);

        const block = fiGroupBlocks[integration];
        if (block) block.style.display = rows.length ? "" : "none";
        const header = fiGroupHeaders[integration];
        if (header) header.textContent = rows.length ? `${integration} (${rows.length})` : integration;
      });

      // Attach sort handlers
      fiTablesSection.querySelectorAll("th[data-sort]").forEach(th => {
        if (th.__sortBound) return;
        th.__sortBound = true;
        th.addEventListener("click", () => {
          const key = th.getAttribute("data-sort");
          const table = th.closest("table");
          const group = table?.closest("[data-group]")?.getAttribute("data-group");
          if (!group) return;
          const prev = tableSortState[group];
          if (prev && prev.key === key) {
            tableSortState[group] = { key, dir: prev.dir === "asc" ? "desc" : "asc" };
          } else {
            tableSortState[group] = { key, dir: key === "fi" || key === "instances" ? "asc" : "desc" };
          }
          if (latestVisibleRows && lastRenderContext) {
            renderTables(latestVisibleRows, lastRenderContext.startDate, lastRenderContext.endDate, lastRenderContext.daySpan);
          }
        });
      });
    }

    function renderHighlights(highlights) {
      const valid = (highlights || []).filter(h => h && !h.empty);
      if (!valid.length) { highlightsSection.style.display = "none"; return; }
      highlightsSection.style.display = "";
      const rows = valid.map(h => {
        const dateRange = h.start === h.end ? h.start : `${h.start} → ${h.end}`;
        const selSuccessPct = typeof h.selSuccessRatio === "number" ? (h.selSuccessRatio * 100).toFixed(1) + "%" : "—";
        const sessSuccessPct = typeof h.sessionSuccessRatio === "number" ? (h.sessionSuccessRatio * 100).toFixed(1) + "%" : "—";
        return `<tr>
          <td class="hl-label">${h.label || ""}</td>
          <td>${h.fi || ""}${h.instance ? ' <span class="muted">(' + h.instance + ')</span>' : ""}</td>
          <td>${h.integration || ""}</td>
          <td class="nowrap">${dateRange}</td>
          <td class="num">${fmt(h.sel)}</td>
          <td class="num">${fmt(h.sessions)}</td>
          <td class="num">${fmt(h.sess_with_success)}</td>
          <td class="num">${selSuccessPct}</td>
          <td class="num">${sessSuccessPct}</td>
          <td class="num">${fmt(h.placements)}</td>
        </tr>`;
      }).join("");
      bestWindowsDiv.innerHTML = `<table class="highlights-table">
        <thead><tr>
          <th>Highlight</th><th>FI</th><th>Integration</th><th>Window</th>
          <th class="num">Launches</th><th class="num">Sessions</th><th class="num">Successful Sessions</th>
          <th class="num">Sel→Succ %</th><th class="num">Session Success %</th><th class="num">Placements</th>
        </tr></thead>
        <tbody>${rows}</tbody>
      </table>`;
    }

    // ─── Single-FI Time Breakdown Functions ───

    function buildDailyRowsForFi(fiName, startDate, endDate, meta) {
      const norm = normalizeFiKey(fiName);
      const rows = [];
      const dates = Object.keys(dailyData).sort();
      for (const date of dates) {
        if (!inRange(date, startDate, endDate)) continue;
        const day = dailyData[date];
        if (!day?.fi) continue;
        let fiEntry = null;
        for (const [name, data] of Object.entries(day.fi)) {
          if (normalizeFiKey(name) === norm) { fiEntry = data; break; }
        }
        if (!fiEntry) continue;
        const ga = fiEntry.ga || {};
        const sessions = fiEntry.sessions || {};
        const placements = fiEntry.placements || {};
        let rowIntegration = meta.integration;
        if (meta.ssoDate && meta.integration === "SSO" && date < meta.ssoDate) {
          rowIntegration = "NON-SSO";
        }
        rows.push({
          periodLabel: date, start: date, end: date,
          ga_select: ga.select_merchants || 0, ga_user: ga.user_data_collection || 0,
          ga_cred: ga.credential_entry || 0, cs_select: sessions.cs_select_sessions || 0,
          cs_user: sessions.cs_user_sessions || 0, cs_cred: sessions.cs_cred_sessions || 0,
          sessions: sessions.total || 0,
          sess_with_success: sessions.with_success || 0,
          placements: getBillablePlacementCount(placements),
          fi: meta.fi, instance: meta.instance, instances: meta.instances,
          integration_type: rowIntegration, partner: meta.partner || "",
          cardholders: meta.cardholders, cardholder_source: meta.cardholder_source || null,
          cardholder_as_of: meta.cardholder_as_of || null, dayCount: 1,
        });
      }
      return rows;
    }

    function aggregateRowsForPeriod(rows, label, start, end, meta) {
      if (!rows.length) return null;
      const integrationTypes = new Set(rows.map(r => r.integration_type || meta.integration));
      let periodIntegration;
      if (integrationTypes.size === 1) {
        periodIntegration = integrationTypes.values().next().value;
      } else if (integrationTypes.has("SSO") && integrationTypes.has("NON-SSO")) {
        periodIntegration = "NON-SSO \u2192 SSO";
      } else {
        periodIntegration = meta.integration;
      }
      const agg = {
        periodLabel: label, start, end,
        ga_select: 0, ga_user: 0, ga_cred: 0, cs_select: 0, cs_user: 0, cs_cred: 0, sessions: 0,
        sess_with_success: 0, placements: 0,
        fi: meta.fi, instance: meta.instance, instances: meta.instances,
        integration_type: periodIntegration, partner: meta.partner || "",
        cardholders: meta.cardholders, cardholder_source: meta.cardholder_source || null,
        cardholder_as_of: meta.cardholder_as_of || null,
        dayCount: dayCountInclusive(start, end) || rows.length || 1,
      };
      for (const row of rows) {
        agg.ga_select += row.ga_select || 0;
        agg.ga_user += row.ga_user || 0;
        agg.ga_cred += row.ga_cred || 0;
        agg.cs_select += row.cs_select || 0;
        agg.cs_user += row.cs_user || 0;
        agg.cs_cred += row.cs_cred || 0;
        agg.sessions += row.sessions || 0;
        agg.sess_with_success += row.sess_with_success || 0;
        agg.placements += row.placements || 0;
      }
      return agg;
    }

    function buildWeeklyRowsForFi(dailyRows, startDate, endDate, meta) {
      const buckets = new Map();
      for (const row of dailyRows) {
        const date = parseDateUtc(row.start);
        const weekStartDate = addDaysUtc(date, -date.getUTCDay());
        const weekEndDate = addDaysUtc(weekStartDate, 6);
        const weekStart = formatDateUtc(weekStartDate);
        const weekEnd = formatDateUtc(weekEndDate);
        if (weekStart < startDate || weekEnd > endDate) continue;
        const key = weekStart;
        if (!buckets.has(key)) buckets.set(key, { start: weekStart, end: weekEnd, rows: [] });
        buckets.get(key).rows.push(row);
      }
      return Array.from(buckets.values())
        .sort((a, b) => a.start.localeCompare(b.start))
        .map(b => aggregateRowsForPeriod(b.rows, `${b.start} \u2192 ${b.end}`, b.start, b.end, meta))
        .filter(Boolean);
    }

    function buildMonthlyRowsForFi(dailyRows, startDate, endDate, meta) {
      const buckets = new Map();
      for (const row of dailyRows) {
        const monthKey = row.start.slice(0, 7);
        const [yearStr, monthStr] = monthKey.split("-");
        const year = Number(yearStr);
        const monthIndex = Number(monthStr) - 1;
        const monthStart = formatDateUtc(new Date(Date.UTC(year, monthIndex, 1)));
        const monthEnd = formatDateUtc(new Date(Date.UTC(year, monthIndex + 1, 0)));
        if (monthStart < startDate || monthEnd > endDate) continue;
        if (!buckets.has(monthKey)) buckets.set(monthKey, { start: monthStart, end: monthEnd, rows: [] });
        buckets.get(monthKey).rows.push(row);
      }
      return Array.from(buckets.values())
        .sort((a, b) => a.start.localeCompare(b.start))
        .map(b => aggregateRowsForPeriod(b.rows, `${b.start} \u2192 ${b.end}`, b.start, b.end, meta))
        .filter(Boolean);
    }

    function buildQuarterlyRowsForFi(dailyRows, startDate, endDate, meta) {
      const buckets = new Map();
      for (const row of dailyRows) {
        const date = parseDateUtc(row.start);
        const q = Math.floor(date.getUTCMonth() / 3) + 1;
        const year = date.getUTCFullYear();
        const key = `${year}-Q${q}`;
        const quarterStart = formatDateUtc(new Date(Date.UTC(year, (q - 1) * 3, 1)));
        const quarterEnd = formatDateUtc(new Date(Date.UTC(year, q * 3, 0)));
        if (quarterStart < startDate || quarterEnd > endDate) continue;
        if (!buckets.has(key)) buckets.set(key, { start: quarterStart, end: quarterEnd, label: `Q${q} ${year}`, rows: [] });
        buckets.get(key).rows.push(row);
      }
      return Array.from(buckets.values())
        .sort((a, b) => a.start.localeCompare(b.start))
        .map(b => aggregateRowsForPeriod(b.rows, b.label, b.start, b.end, meta))
        .filter(Boolean);
    }

    // ─── Single-FI Rendering ───

    function renderSingleFiSections(visibleRows, startDate, endDate, daySpan) {
      singleFiView.innerHTML = "";
      if (!visibleRows || !visibleRows.length) {
        const div = document.createElement("div");
        div.className = "muted";
        div.textContent = "No data available for this FI.";
        singleFiView.appendChild(div);
        latestSingleFiBreakdowns = null;
        return;
      }

      const shared = window.__FILTER_STATE;
      const sharedFi = shared && shared.page === "funnel-customer" && shared.fis && shared.fis.size === 1
        ? Array.from(shared.fis)[0] : null;
      const fiName = sharedFi || (visibleRows[0]?.fi || "Unknown FI");
      const perFiRow = visibleRows[0] || {};
      const instanceDisplay = perFiRow.instance || (perFiRow.instances?.[0]) || "unknown";
      const registryInfo = getRegistryEntry(fiName, instanceDisplay);
      const meta = {
        fi: fiName, instance: instanceDisplay, instances: [instanceDisplay],
        integration: normalizeIntegrationLabel(
          perFiRow.integration_type || registryInfo?.integration || registryInfo?.integration_type || "UNKNOWN"
        ),
        partner: perFiRow.partner || registryInfo?.partner || "Unknown",
        cardholders: perFiRow.cardholders,
        cardholder_source: perFiRow.cardholder_source || null,
        cardholder_as_of: perFiRow.cardholder_as_of || null,
        ssoDate: registryInfo?.traffic_first_seen_sso || null,
      };

      const dailyRows = buildDailyRowsForFi(fiName, startDate, endDate, meta);
      const weeklyRows = buildWeeklyRowsForFi(dailyRows, startDate, endDate, meta);
      const monthlyRows = buildMonthlyRowsForFi(dailyRows, startDate, endDate, meta);
      const quarterlyRows = buildQuarterlyRowsForFi(dailyRows, startDate, endDate, meta);
      latestSingleFiBreakdowns = { summary: visibleRows, daily: dailyRows, weekly: weeklyRows, monthly: monthlyRows, quarterly: quarterlyRows };

      const sections = [];
      sections.push({ key: "summary", title: `Summary (${startDate} \u2192 ${endDate})`, rows: visibleRows });
      if (quarterlyRows.length) sections.push({ key: "quarterly", title: "Quarterly", rows: quarterlyRows });
      if (monthlyRows.length) sections.push({ key: "monthly", title: "Monthly (Full Calendar Months)", rows: monthlyRows });
      if (weeklyRows.length) sections.push({ key: "weekly", title: "Weekly (Sunday \u2192 Saturday)", rows: weeklyRows });
      if (dailyRows.length) sections.push({ key: "daily", title: "Daily", rows: dailyRows });

      const availableSections = sections.filter(s => s.rows && s.rows.length);
      if (!availableSections.length) {
        const div = document.createElement("div");
        div.className = "muted";
        div.textContent = "No full periods available for this FI within the selected dates.";
        singleFiView.appendChild(div);
        return;
      }

      const tabBar = document.createElement("div");
      tabBar.className = "tab-bar";
      const panelsWrap = document.createElement("div");

      availableSections.forEach((section, idx) => {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = `tab-button ${idx === 0 ? "active" : ""}`;
        btn.dataset.tab = section.key;
        btn.textContent = section.title;
        tabBar.appendChild(btn);

        const panel = document.createElement("div");
        panel.className = `tab-panel ${idx === 0 ? "active" : ""}`;
        panel.dataset.tab = section.key;
        const heading = document.createElement("h3");
        heading.textContent = section.title;
        panel.appendChild(heading);
        panel.appendChild(createSingleFiTable(section.rows, section.key, meta.integration === "SSO"));
        panelsWrap.appendChild(panel);
      });

      const activateTab = (key) => {
        lastActiveTab = key;
        tabBar.querySelectorAll(".tab-button").forEach(btn => {
          btn.classList.toggle("active", btn.dataset.tab === key);
        });
        panelsWrap.querySelectorAll(".tab-panel").forEach(panel => {
          panel.classList.toggle("active", panel.dataset.tab === key);
        });
      };

      tabBar.addEventListener("click", (ev) => {
        const btn = ev.target.closest(".tab-button");
        if (!btn) return;
        activateTab(btn.dataset.tab);
      });

      singleFiView.appendChild(tabBar);
      singleFiView.appendChild(panelsWrap);

      const tabToActivate = (lastActiveTab && availableSections.some(s => s.key === lastActiveTab))
        ? lastActiveTab : availableSections[0].key;
      activateTab(tabToActivate);
    }

    function createSingleFiTable(rows, key, isSso) {
      const table = document.createElement("table");
      table.className = "fi-table";
      let headerHtml = `<thead><tr>
          <th data-sort="period">Period</th>
          <th data-sort="fi">Financial Institution</th>
          <th data-sort="instances">Instance</th>
          <th data-sort="integration">Integration</th>
          <th data-sort="ga_select" class="num">Launches</th>
          <th data-sort="cs_select" class="num">Sess @Select</th>`;
      if (!isSso) headerHtml += `<th data-sort="ga_user" class="num">User Data Views</th>`;
      headerHtml += `
          <th data-sort="ga_cred" class="num">Credential Views</th>
          <th data-sort="reach" class="num">Monthly Reach %</th>`;
      if (!isSso) headerHtml += `<th data-sort="sel_user_pct" class="num">Sel\u2192User %</th>`;
      headerHtml += `
          <th data-sort="sel_cred_pct" class="num">Sel\u2192Cred %</th>
          <th data-sort="sel_success_pct" class="num">Sel\u2192Succ %</th>
          <th data-sort="sessions" class="num">Sessions</th>
          <th data-sort="sess_with_success" class="num">Successful Sessions</th>
          <th data-sort="sess_success_pct" class="num">Session Success %</th>
          <th data-sort="placements" class="num">Placements</th>
        </tr></thead>`;
      table.innerHTML = headerHtml;

      const tbody = document.createElement("tbody");
      const tableId = `single-${key.replace(/[^a-zA-Z0-9]/g, "_")}`;

      // Sort
      const state = tableSortState[tableId];
      let sorted = [...rows];
      if (state && state.key) {
        const dir = state.dir === "desc" ? -1 : 1;
        sorted.sort((a, b) => {
          const va = getSingleSortValue(a, state.key);
          const vb = getSingleSortValue(b, state.key);
          if (typeof va === "string") return dir * va.localeCompare(vb);
          return dir * (va - vb);
        });
      }

      sorted.forEach(row => tbody.appendChild(renderSingleFiRow(row, isSso)));
      table.appendChild(tbody);
      table.id = tableId;

      // Attach sort handlers
      table.querySelectorAll("th[data-sort]").forEach(th => {
        th.style.cursor = "pointer";
        th.addEventListener("click", () => {
          const sortKey = th.getAttribute("data-sort");
          const prev = tableSortState[tableId];
          if (prev && prev.key === sortKey) {
            tableSortState[tableId] = { key: sortKey, dir: prev.dir === "asc" ? "desc" : "asc" };
          } else {
            tableSortState[tableId] = { key: sortKey, dir: sortKey === "fi" || sortKey === "instances" || sortKey === "period" ? "asc" : "desc" };
          }
          // Re-render this table in place
          const newTbody = document.createElement("tbody");
          const reSorted = [...rows];
          const st = tableSortState[tableId];
          const d = st.dir === "desc" ? -1 : 1;
          reSorted.sort((a, b) => {
            const va = getSingleSortValue(a, st.key);
            const vb = getSingleSortValue(b, st.key);
            if (typeof va === "string") return d * va.localeCompare(vb);
            return d * (va - vb);
          });
          reSorted.forEach(r => newTbody.appendChild(renderSingleFiRow(r, isSso)));
          const oldTbody = table.querySelector("tbody");
          if (oldTbody) table.replaceChild(newTbody, oldTbody);
        });
      });

      const wrapper = document.createElement("div");
      wrapper.className = "table-scroll";
      wrapper.appendChild(table);
      return wrapper;
    }

    function getSingleSortValue(row, key) {
      switch (key) {
        case "period": return row.periodLabel || row.start || "";
        case "fi": return (row.fi || "").toLowerCase();
        case "instances": return (row.instance || "").toLowerCase();
        case "integration": return (row.integration_type || "").toLowerCase();
        case "ga_select": return row.ga_select || 0;
        case "cs_select": return row.cs_select || 0;
        case "ga_user": return row.ga_user || 0;
        case "ga_cred": return row.ga_cred || 0;
        case "reach": return getMonthlyReachValue(row);
        case "sel_user_pct": return row.cs_select ? (row.cs_user || 0) / row.cs_select : 0;
        case "sel_cred_pct": return row.cs_select ? (row.cs_cred || 0) / row.cs_select : 0;
        case "sel_success_pct": return row.cs_select && row.sess_with_success ? row.sess_with_success / row.cs_select : 0;
        case "sessions": return row.sessions || 0;
        case "sess_with_success": return row.sess_with_success || 0;
        case "sess_success_pct": return row.sessions ? (row.sess_with_success || 0) / row.sessions : 0;
        case "placements": return row.placements || 0;
        default: return 0;
      }
    }

    function renderSingleFiRow(row, isSso) {
      const tr = document.createElement("tr");
      const instancesText = row.instance || (Array.isArray(row.instances) ? row.instances.join(", ") : "");
      const selUserPct = row.cs_select ? ((row.cs_user / row.cs_select) * 100).toFixed(1) + "%" : "";
      const selCredPct = row.cs_select ? ((row.cs_cred / row.cs_select) * 100).toFixed(1) + "%" : "";
      const selSuccPct = formatSelSuccessPct(row);
      const reachPct = formatMonthlyReachPct(row);
      const reachVal = getMonthlyReachValue(row);
      const reachCls = reachVal >= 0.025 ? " reach-good" : reachVal > 0 ? " reach-low" : "";
      const sessSuccPct = formatSessSuccessPct(row);
      let cells = `
        <td>${row.periodLabel || ""}</td>
        <td>${row.fi || ""}</td>
        <td>${instancesText}</td>
        <td>${row.integration_type || ""}</td>
        <td class="num">${row.ga_select || 0}</td>
        <td class="num">${row.cs_select || 0}</td>`;
      if (!isSso) cells += `<td class="num">${row.ga_user || 0}</td>`;
      cells += `
        <td class="num">${row.ga_cred || 0}</td>
        <td class="num${reachCls}">${reachPct}</td>`;
      if (!isSso) cells += `<td class="num">${selUserPct}</td>`;
      cells += `
        <td class="num">${selCredPct}</td>
        <td class="num">${selSuccPct}</td>
        <td class="num">${row.sessions || 0}</td>
        <td class="num">${row.sess_with_success || 0}</td>
        <td class="num">${sessSuccPct}</td>
        <td class="num">${row.placements || 0}</td>`;
      tr.innerHTML = cells;
      return tr;
    }

    function renderPartnerSummary(summaryData) {
      if (!partnerSummaryBox) return;
      if (!summaryData) { partnerSummaryBox.style.display = "none"; partnerSummaryBox.innerHTML = ""; return; }
      const pctStr = (v) => typeof v === "number" && Number.isFinite(v) ? v.toFixed(1) + "%" : "—";
      const rows = summaryData.rows.map(r => `<tr>
        <td>${r.integration}</td><td class="num">${r.fiCount}</td><td class="num ga-col">${fmt(r.ga_select)}</td>
        <td class="num">${pctStr(r.selSuccessPct)}</td><td class="num">${fmt(r.sessions)}</td>
        <td class="num">${fmt(r.sess_with_success)}</td><td class="num">${pctStr(r.sessionSuccessPct)}</td>
      </tr>`).join("");
      const t = summaryData.totals || {};
      const totalRow = `<tr class="total-row">
        <td><strong>Total</strong></td><td class="num"><strong>${t.fiCount || ""}</strong></td>
        <td class="num ga-col"><strong>${fmt(t.ga_select)}</strong></td><td class="num"><strong>${pctStr(t.selSuccessPct)}</strong></td>
        <td class="num"><strong>${fmt(t.sessions)}</strong></td><td class="num"><strong>${fmt(t.sess_with_success)}</strong></td>
        <td class="num"><strong>${pctStr(t.sessionSuccessPct)}</strong></td>
      </tr>`;
      partnerSummaryBox.innerHTML = `
        <div class="perf-section-title">${summaryData.partner || "Partner"} Integration Mix <span class="muted">${summaryData.rows.length} integration types</span></div>
        <table><thead><tr>
          <th>Integration</th><th class="num">FIs</th><th class="num ga-col">GA Select</th>
          <th class="num">Sel→Succ %</th><th class="num">Sessions</th>
          <th class="num">Sess w/ Success</th><th class="num">Sess→Succ %</th>
        </tr></thead><tbody>${rows}${totalRow}</tbody></table>`;
      partnerSummaryBox.style.display = "";
    }

    // ─── CSV Export ───
    function csvEscape(value) {
      if (value === null || value === undefined) return "";
      const str = String(value);
      if (/[",\n]/.test(str)) return `"${str.replace(/"/g, '""')}"`;
      return str;
    }

    function buildCustomerCsv(visibleRows, highlights, partnerSummary, startDate, endDate) {
      const lines = [];
      const title = `Cardholder Engagement Report ${startDate || ""} → ${endDate || ""}`.trim();
      lines.push(`"${title}"`, "", "");

      // Highlights
      const validH = (highlights || []).filter(h => h && !h.empty);
      if (validH.length) {
        lines.push("Performance Highlights");
        lines.push(["Highlight","FI","Integration","Window Start","Window End","GA Select","Sessions","Sess w/ Success","Sel→Succ %","Sess→Succ %","Placements"].map(csvEscape).join(","));
        validH.forEach(h => {
          const selSuccPct = typeof h.selSuccessRatio === "number" ? (h.selSuccessRatio * 100).toFixed(1) + "%" : "";
          const sessSuccPct = typeof h.sessionSuccessRatio === "number" ? (h.sessionSuccessRatio * 100).toFixed(1) + "%" : "";
          lines.push([h.label, h.fi, h.integration, h.start, h.end, h.sel || 0, h.sessions || 0, h.sess_with_success || 0, selSuccPct, sessSuccPct, h.placements || 0].map(csvEscape).join(","));
        });
        lines.push("", "");
      }

      // Summary by FI
      if (visibleRows.length) {
        const header = ["FI","Partner","Integration","Instance","GA Select","Sess @Select","GA User","GA Cred","Monthly Reach %","Select→User %","Select→Cred %","Select→Succ %","Sessions","Sessions w/ Success","Session Success %","Placements"];
        lines.push("Summary by FI");
        lines.push(header.map(csvEscape).join(","));
        visibleRows.forEach(row => {
          const reachPct = formatMonthlyReachPct(row);
          const selUserPct = row.cs_select ? (((row.cs_user || 0) / row.cs_select) * 100).toFixed(1) + "%" : "";
          const selCredPct = row.cs_select ? (((row.cs_cred || 0) / row.cs_select) * 100).toFixed(1) + "%" : "";
          const selSuccPct = row.cs_select && row.sess_with_success ? ((row.sess_with_success / row.cs_select) * 100).toFixed(1) + "%" : "";
          const sessSuccPct = row.sessions && row.sess_with_success ? ((row.sess_with_success / row.sessions) * 100).toFixed(1) + "%" : "";
          lines.push([
            row.fi, row.partner, row.integration_type, row.instance,
            row.ga_select || 0, row.cs_select || 0, row.ga_user || 0, row.ga_cred || 0,
            reachPct, selUserPct, selCredPct, selSuccPct,
            row.sessions || 0, row.sess_with_success || 0, sessSuccPct,
            row.placements || 0,
          ].map(csvEscape).join(","));
        });
        lines.push("", "");
      }

      // Partner mix
      if (partnerSummary && partnerSummary.rows && partnerSummary.rows.length) {
        const pctStr = (v) => typeof v === "number" && Number.isFinite(v) ? v.toFixed(1) + "%" : "";
        lines.push(`${partnerSummary.partner} Integration Mix`);
        lines.push(["Integration","FIs","GA Select","Sel→Succ %","Sessions","Sessions w/ Success","Sess→Succ %"].map(csvEscape).join(","));
        partnerSummary.rows.forEach(r => {
          lines.push([r.integration, r.fiCount, r.ga_select, pctStr(r.selSuccessPct), r.sessions, r.sess_with_success, pctStr(r.sessionSuccessPct)].map(csvEscape).join(","));
        });
        const t = partnerSummary.totals || {};
        lines.push([t.integration || "Total", t.fiCount || 0, t.ga_select || 0, pctStr(t.selSuccessPct), t.sessions || 0, t.sess_with_success || 0, pctStr(t.sessionSuccessPct)].map(csvEscape).join(","));
      }

      return lines.join("\n");
    }

    function downloadCsv(filename, contents) {
      const blob = new Blob([contents], { type: "text/csv;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url; a.download = filename;
      document.body.appendChild(a); a.click(); a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 0);
    }

    // ─── Apply filters ───
    async function applyFilters() {
      await nextFrame();
      const startDate = startDateInput.value || defaultStartDateStr;
      const endDate = endDateInput.value || defaultEndDateStr;
      const startDt = new Date(`${startDate}T00:00:00Z`);
      const endDt = new Date(`${endDate}T00:00:00Z`);
      const daySpan = Math.max(1, Math.floor((endDt - startDt) / (1000 * 60 * 60 * 24)) + 1);
      const cardholderMap = getCardholderMap();
      const perFi = aggregateData(startDate, endDate, cardholderMap);
      lastAggregated = perFi;
      const visibleRows = getVisibleRows(perFi);
      latestVisibleRows = visibleRows;
      const singleFiMode = isSingleFiSelected();
      const best = computeBestWindows(startDate, endDate, perFi, visibleRows, 30 / daySpan, { allowLowVolume: singleFiMode });
      latestHighlights = best;

      // Metrics
      const metrics = calculateMetrics(startDate, endDate, visibleRows);
      renderMetrics(metrics, startDate, endDate, daySpan, visibleRows.length, visibleRows);

      // Stamp rows with date context for Monthly Reach % calculation
      visibleRows.forEach(row => {
        row.periodStart = startDate;
        row.periodEnd = endDate;
        row.dayCount = row.dayCount || daySpan;
      });

      // Per-FI tables
      renderTables(visibleRows, startDate, endDate, daySpan);

      // Highlights
      renderHighlights(best);

      // Partner summary
      const shared = window.__FILTER_STATE;
      let partnerValue = PARTNER_ALL_VALUE;
      if (shared && shared.page === "funnel-customer" && shared.__partnerSetTouched && shared.partnerSet && shared.partnerSet.size === 1) {
        partnerValue = Array.from(shared.partnerSet)[0];
      }
      const partnerSummary = buildPartnerSummaryData(visibleRows, daySpan, partnerValue);
      latestPartnerSummary = partnerSummary;
      renderPartnerSummary(partnerSummary);

      lastRenderContext = { perFi, startDate, endDate, daySpan, best, metrics };
      const snapshot = shared && shared.page === "funnel-customer";
      lastFilterSnapshot = {
        fis: snapshot && shared.fis ? Array.from(shared.fis).sort().join(',') : '',
        partner: snapshot ? (shared.partner || '') : '',
      };
    }

    async function safeApplyFilters() {
      ensureDateDefaults();
      enforceEndDateBounds();
      renderDateWarning();
      await applyFilters();
    }

    function rerenderFromCache() {
      if (!lastRenderContext) return;
      const shared = window.__FILTER_STATE;
      const snapshot = shared && shared.page === "funnel-customer";
      const current = {
        fis: snapshot && shared.fis ? Array.from(shared.fis).sort().join(',') : '',
        partner: snapshot ? (shared.partner || '') : '',
      };
      const changed = !lastFilterSnapshot || lastFilterSnapshot.fis !== current.fis || lastFilterSnapshot.partner !== current.partner;
      if (changed) {
        startLoading("Loading data…");
        applyFilters().finally(() => stopLoading());
        return;
      }
    }

    // ─── View mode ───
    const __viewParams = new URLSearchParams(window.location.search);
    const __isViewMode = __viewParams.get("view") === "1";

    if (__isViewMode) {
      window.__sisViewMode = true;
      const __viewSid = __viewParams.get("sid");
      if (__viewSid) {
        try { fetch("/api/share-log/view?sid=" + encodeURIComponent(__viewSid)).catch(function() {}); } catch (e) {}
      }
      const vpFrom = __viewParams.get("from");
      const vpTo = __viewParams.get("to");
      if (startDateInput) startDateInput.value = vpFrom || defaultStartDateStr;
      if (endDateInput) endDateInput.value = vpTo || defaultEndDateStr;
      const presetEl = document.getElementById("datePreset");
      if (presetEl) { presetEl.value = ""; presetEl.disabled = true; }
      if (startDateInput) startDateInput.disabled = true;
      if (endDateInput) endDateInput.disabled = true;
      if (applyBtn) applyBtn.style.display = "none";
      if (exportCsvBtn) exportCsvBtn.style.display = "none";
      const exportPdfBtnView = document.getElementById("exportPdfBtn");
      if (exportPdfBtnView) exportPdfBtnView.style.display = "none";
      const presetParent = document.getElementById("datePreset");
      if (presetParent) presetParent.parentElement.style.display = "none";
    } else {
      // Check for date params from redirect
      const urlFrom = __viewParams.get("from");
      const urlTo = __viewParams.get("to");
      if (urlFrom && urlTo) {
        if (startDateInput) startDateInput.value = urlFrom;
        if (endDateInput) endDateInput.value = urlTo;
        const presetEl = document.getElementById("datePreset");
        if (presetEl) presetEl.value = "";
      } else {
        if (startDateInput && !startDateInput.value) startDateInput.value = defaultStartDateStr;
        if (endDateInput && !endDateInput.value) endDateInput.value = defaultEndDateStr;
        const presetEl = document.getElementById("datePreset");
        if (presetEl) presetEl.value = "last7";
      }
      // Share button
      const shareLinkBtn = document.getElementById("shareLinkBtn");
      if (shareLinkBtn) {
        shareLinkBtn.style.display = "";
        shareLinkBtn.addEventListener("click", function() {
          const fs = window.__FILTER_STATE || {};
          const params = new URLSearchParams();
          params.set("view", "1");
          const sidBytes = new Uint8Array(4);
          crypto.getRandomValues(sidBytes);
          const sid = Array.from(sidBytes).map(b => b.toString(16).padStart(2, "0")).join("");
          params.set("sid", sid);
          if (startDateInput && startDateInput.value) params.set("from", startDateInput.value);
          if (endDateInput && endDateInput.value) params.set("to", endDateInput.value);
          if (fs.fis && fs.fis.size > 0) {
            const fiArr = Array.from(fs.fis);
            if (fiArr.length === 1) params.set("fi", fiArr[0]);
          }
          if (fs.__partnerSetTouched && fs.partnerSet && fs.partnerSet.size > 0) {
            const arr = Array.from(fs.partnerSet);
            if (arr.length === 1) params.set("partner", arr[0]);
          }
          const shareUrl = window.location.origin + window.location.pathname + "?" + params.toString();
          navigator.clipboard.writeText(shareUrl).then(function() {
            shareLinkBtn.textContent = "Copied!";
            setTimeout(function() { shareLinkBtn.textContent = "Share"; }, 2000);
          }).catch(function() { prompt("Copy this link:", shareUrl); });
          try { fetch("/api/share-log", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ sid, url: shareUrl }) }).catch(function() {}); } catch (e) {}
        });
      }
    }

    // Toggle merchant detail on card click
    document.getElementById("cardSuccessful")?.addEventListener("click", (e) => {
      const detailEl = document.getElementById("merchantDetail");
      if (!detailEl || !merchantPopoverReady) return;
      e.stopPropagation();
      detailEl.classList.toggle("open");
    });
    // Close merchant popover when clicking outside
    document.addEventListener("click", (e) => {
      const detailEl = document.getElementById("merchantDetail");
      const card = document.getElementById("cardSuccessful");
      if (detailEl?.classList.contains("open") && card && !card.contains(e.target) && !detailEl.contains(e.target)) {
        detailEl.classList.remove("open");
      }
    });

    // ── GA data toggle ──
    const gaToggle = document.getElementById("gaToggle");
    if (gaToggle) {
      gaToggle.addEventListener("change", () => {
        document.body.classList.toggle("hide-ga", !gaToggle.checked);
      });
    }

    // ── Distribution panel toggles (close others when one opens) ──
    const distPanels = [
      { btnId: "toggleDistribution", panelId: "distributionPanel", cardId: "cardMerchantsPerSession" },
      { btnId: "csSelectToggleDist", panelId: "csSelectDistPanel", cardId: "cardCsSelectDist" },
      { btnId: "csUserToggleDist", panelId: "csUserDistPanel", cardId: "cardCsUserDist" },
      { btnId: "csCredToggleDist", panelId: "csCredDistPanel", cardId: "cardCsCredDist" },
    ];
    function closeAllDistPanels(exceptPanelId) {
      for (const d of distPanels) {
        if (d.panelId === exceptPanelId) continue;
        const p = document.getElementById(d.panelId);
        const b = document.getElementById(d.btnId);
        if (p) p.classList.remove("open");
        if (b) b.setAttribute("aria-expanded", "false");
      }
    }
    for (const d of distPanels) {
      const btn = document.getElementById(d.btnId);
      const panel = document.getElementById(d.panelId);
      if (btn && panel) {
        btn.addEventListener("click", (e) => {
          e.stopPropagation();
          const isOpen = panel.classList.toggle("open");
          btn.setAttribute("aria-expanded", String(isOpen));
          if (isOpen) closeAllDistPanels(d.panelId);
        });
      }
    }
    // Close any open distribution panel when clicking outside
    document.addEventListener("click", (e) => {
      for (const d of distPanels) {
        const panel = document.getElementById(d.panelId);
        const card = document.getElementById(d.cardId);
        if (panel?.classList.contains("open") && card && !card.contains(e.target)) {
          panel.classList.remove("open");
          const btn = document.getElementById(d.btnId);
          if (btn) btn.setAttribute("aria-expanded", "false");
        }
      }
    });

    // ─── Event listeners ───
    applyBtn.addEventListener("click", () => {
      lastRenderContext = null;
      lastFilterSnapshot = null;
      startLoading("Loading data…");
      safeApplyFilters().catch(err => console.error("apply failed", err)).finally(() => stopLoading());
    });

    endDateInput?.addEventListener("change", () => {
      const presetEl = document.getElementById("datePreset");
      if (presetEl) presetEl.value = "";
      renderDateWarning();
    });
    startDateInput?.addEventListener("change", () => {
      const presetEl = document.getElementById("datePreset");
      if (presetEl) presetEl.value = "";
      renderDateWarning();
    });

    exportCsvBtn.addEventListener("click", () => {
      const csv = buildCustomerCsv(
        latestVisibleRows, latestHighlights, latestPartnerSummary,
        lastRenderContext?.startDate || startDateInput.value,
        lastRenderContext?.endDate || endDateInput.value,
      );
      const start = (startDateInput.value || "start").replace(/[^0-9-]/g, "");
      const end = (endDateInput.value || "end").replace(/[^0-9-]/g, "");
      downloadCsv(`cardholder-engagement-${start}-to-${end}.csv`, csv);
    });

    document.getElementById("exportPdfBtn")?.addEventListener("click", async () => {
      const btn = document.getElementById("exportPdfBtn");
      const origText = btn.textContent;
      btn.textContent = "Generating…"; btn.disabled = true;
      try {
        const startDate = startDateInput.value || defaultStartDateStr;
        const endDate = endDateInput.value || defaultEndDateStr;
        const visibleRows = latestVisibleRows || [];
        const metrics = calculateMetrics(startDate, endDate, visibleRows);
        const parts = [];
        const fs = window.__FILTER_STATE || {};
        if (fs.__partnerSetTouched && fs.partnerSet && fs.partnerSet.size > 0) parts.push("Partner: " + Array.from(fs.partnerSet).join(", "));
        if (fs.__fiTouched && fs.fis && fs.fis.size > 0 && fs.fis.size <= 3) parts.push("FI: " + Array.from(fs.fis).join(", "));
        const filterContext = parts.length ? parts.join(" | ") : `All data (${visibleRows.length} FIs)`;

        // Generate share URL for the PDF link — include all active filters
        const shareParams = new URLSearchParams();
        shareParams.set("view", "1");
        const sidBytes = new Uint8Array(4);
        crypto.getRandomValues(sidBytes);
        const pdfSid = Array.from(sidBytes).map(b => b.toString(16).padStart(2, "0")).join("");
        shareParams.set("sid", pdfSid);
        if (startDate) shareParams.set("from", startDate);
        if (endDate) shareParams.set("to", endDate);
        if (fs.fis && fs.fis.size > 0) {
          shareParams.set("fi", Array.from(fs.fis).join(","));
        }
        if (fs.partnerSet && fs.partnerSet.size > 0) {
          shareParams.set("partner", Array.from(fs.partnerSet).join(","));
        }
        if (fs.instanceSet && fs.instanceSet.size > 0) {
          shareParams.set("instance", Array.from(fs.instanceSet).join(","));
        }
        if (fs.integrationSet && fs.integrationSet.size > 0) {
          shareParams.set("integration", Array.from(fs.integrationSet).join(","));
        }
        const shareUrl = window.location.origin + window.location.pathname + "?" + shareParams.toString();
        try { fetch("/api/share-log", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ sid: pdfSid, url: shareUrl }) }).catch(() => {}); } catch (e) {}

        const payload = {
          startDate, endDate, filterContext, shareUrl,
          metrics: {
            totalGaSelect: metrics.totalGaSelect, totalGaUser: metrics.totalGaUser, totalGaCred: metrics.totalGaCred,
            totalCsSelect: metrics.totalCsSelect, totalCsUser: metrics.totalCsUser, totalCsCred: metrics.totalCsCred,
            totalSessions: metrics.totalSessions, sessionsWithSuccessfulJobs: metrics.sessionsWithSuccessfulJobs,
            successful: metrics.successful,
          },
          highlights: (latestHighlights || []).map(h => ({
            label: h.label, fi: h.fi, instance: h.instance, integration: h.integration,
            start: h.start, end: h.end, sel: h.sel, sessions: h.sessions,
            sess_with_success: h.sess_with_success, placements: h.placements,
            selSuccessRatio: h.selSuccessRatio, sessionSuccessRatio: h.sessionSuccessRatio, empty: h.empty,
          })),
          partnerSummary: latestPartnerSummary || null,
        };
        const token = window.sisAuth?.getToken?.() || localStorage.getItem("sis_session_token") || "";
        const resp = await fetch("/api/export-pdf-customer", {
          method: "POST",
          headers: { "Content-Type": "application/json", ...(token ? { Authorization: "Bearer " + token } : {}) },
          body: JSON.stringify(payload),
        });
        if (!resp.ok) {
          const err = await resp.json().catch(() => ({ error: "Unknown error" }));
          throw new Error(err.error || `HTTP ${resp.status}`);
        }
        const blob = await resp.blob();
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url; a.download = `cardholder-engagement-${startDate}-to-${endDate}.pdf`;
        document.body.appendChild(a); a.click(); a.remove();
        setTimeout(() => URL.revokeObjectURL(url), 0);
      } catch (err) {
        console.error("[pdf] Export failed:", err);
        alert("PDF export failed: " + err.message);
      } finally {
        btn.textContent = origText; btn.disabled = false;
      }
    });

    // ─── Init ───
    async function init() {
      try {
        startLoading("Loading engagement data…");
        try {
          registryMap = await fetchRegistry();
          updateRegistryLookups(registryMap);
        } catch (err) { console.error("Failed to load registry:", err); registryMap = {}; }

        try {
          const fetched = await fetchDailyList();
          dailyFiles = Array.isArray(fetched) ? fetched : [];
          if (dailyFiles.length) {
            const sortedDates = dailyFiles.map(f => f.replace(".json", "")).filter(d => /^\d{4}-\d{2}-\d{2}$/.test(d)).sort();
            earliestDailyDate = sortedDates[0] || null;
            latestDailyDate = sortedDates[sortedDates.length - 1] || null;
            const baseIso = getMaxSelectableDateIso();
            if (endDateInput && (!endDateInput.value || endDateInput.value > baseIso)) endDateInput.value = baseIso;
            if (startDateInput && startDateInput.value > (endDateInput?.value || baseIso)) startDateInput.value = endDateInput.value || baseIso;
            renderDateWarning();
          }
          // Bulk cache
          const dataVersion = window.DataCache?.currentVersion || 'unknown';
          const bulkCacheKey = `funnel_all_daily_data_v${dataVersion}`;
          if (window.DataCache) {
            const cachedBulk = await window.DataCache.getAsync(bulkCacheKey);
            if (cachedBulk && typeof cachedBulk === 'object' && Object.keys(cachedBulk).length > 0) {
              setLoaderMessage('Loading from cache…');
              dailyData = cachedBulk;
            } else {
              const totalDays = dailyFiles.length;
              let loadedDays = 0;
              if (earliestDailyDate && latestDailyDate) {
                setLoaderMessage(`Loading daily data… ${loadedDays}/${totalDays}`);
                const rangeEntries = await fetchDailyRange(earliestDailyDate, latestDailyDate);
                if (rangeEntries && typeof rangeEntries === "object") { dailyData = rangeEntries; loadedDays = Object.keys(dailyData).length; }
              }
              if (loadedDays === 0) {
                for (const file of dailyFiles) {
                  const date = file.replace(".json", "");
                  setLoaderMessage(`Loading daily data… ${loadedDays}/${totalDays}`);
                  const data = await fetchDaily(date);
                  if (data) dailyData[date] = data;
                  loadedDays += 1;
                }
              }
              if (Object.keys(dailyData).length > 0) {
                window.DataCache.set(bulkCacheKey, dailyData).catch(() => {});
              }
            }
          } else {
            const totalDays = dailyFiles.length;
            let loadedDays = 0;
            for (const file of dailyFiles) {
              const date = file.replace(".json", "");
              setLoaderMessage(`Loading daily data… ${loadedDays}/${totalDays}`);
              const data = await fetchDaily(date);
              if (data) dailyData[date] = data;
              loadedDays += 1;
            }
          }
        } catch (err) { console.error("Failed to load daily data:", err); }

        await safeApplyFilters();
      } catch (err) {
        console.error("Init failed", err);
        stopLoading();
      } finally {
        stopLoading();
      }
    }

    init().catch(err => { console.error("Init failed", err); stopLoading(); });

    const presetSelect = document.getElementById("datePreset");
    if (presetSelect) {
      presetSelect.addEventListener("change", () => {
        const val = presetSelect.value;
        if (val) { applyPresetRange(val); safeApplyFilters(); }
      });
    }

    applyDefaultDateRange(false);

    // Initialize filters
    (function ensureFilters(pageId){
      const run = () => { if (window.initFilters) window.initFilters(pageId); };
      if (window.initFilters) return run();
      const candidates = ["./assets/js/filters.js?v=shared-fallback", "/assets/js/filters.js?v=shared-fallback"];
      const loadNext = (idx) => {
        if (idx >= candidates.length) return;
        const s = document.createElement("script");
        s.src = candidates[idx] + "&ts=" + Date.now();
        s.onload = () => run();
        s.onerror = () => loadNext(idx + 1);
        document.head.appendChild(s);
      };
      loadNext(0);
    })("funnel-customer");
  </script>
</body>
</html>
