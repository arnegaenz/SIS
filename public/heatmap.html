<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Strivve â€¢ Merchant Reach &amp; Reliability</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="./sis-shared.css?v=navfix" />
  <link rel="stylesheet" href="./assets/css/sis.css">
  <script defer src="./assets/js/sis.js"></script>
  <script defer src="./assets/js/filters.js?v=shared"></script>
  <link rel="stylesheet" href="./assets/css/filters.css">
  <style>
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      padding: 0;
      min-height: 100vh;
      font-family: "Inter", "Segoe UI", ui-sans-serif, system-ui, -apple-system, Roboto, "Helvetica Neue", Arial;
      font-size: 16px;
      background: var(--bg);
      color: var(--ink);
      --sis-panel-bg: var(--panel);
    }
    .filter-row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: flex-end;
    }
    /* Scope toolbar filters so the shared filter bar keeps its own styles */
    .toolbar .filter-field {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 170px;
      min-height: 0;
    }
    .toolbar .filter-field label {
      display: block;
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 0;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      padding-left: 2px;
    }
    .toolbar .filter-field select {
      background: var(--input-bg);
      border: 1px solid var(--input-border);
      color: var(--ink);
      padding: 10px 12px;
      border-radius: 10px;
      font-size: 14px;
      height: 42px;
      line-height: 22px;
      box-sizing: border-box;
    }
    .toolbar .filter-field select:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(37,99,235,0.2);
    }
    .toolbar .filter-field input[type="date"] {
      background: var(--input-bg);
      border: 1px solid var(--input-border);
      color: var(--ink);
      padding: 10px 12px;
      border-radius: 10px;
      font-size: 14px;
      height: 42px;
      line-height: 22px;
      box-sizing: border-box;
    }
    .toolbar .filter-field input[type="date"]:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(37,99,235,0.2);
    }
    .filter-actions {
      display: flex;
      gap: 6px;
      align-items: center;
      flex-wrap: wrap;
      margin-top: 2px;
    }
    .mode-row {
      margin-top: 10px;
    }
    .filter-btn {
      background: linear-gradient(120deg, var(--accent), var(--accent-2));
      border: none;
      border-radius: 999px;
      color: #f8fafc;
      padding: 10px 28px;
      min-width: 170px;
      font-weight: 600;
      letter-spacing: 0.2px;
      cursor: pointer;
      font-size: 0.9rem;
      text-transform: none;
    }
    .filter-btn:hover { transform: translateY(-1px); filter: brightness(1.05); }
    .filter-toggle label.toggle {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      color: var(--ink);
      text-transform: none;
    }
    .filter-toggle input[type="checkbox"] {
      width: 16px;
      height: 16px;
      accent-color: var(--accent);
    }
    .row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    label { font-size: 13px; color: var(--muted); }
    input[type="date"] {
      background: var(--input-bg);
      border: 1px solid var(--grid-border);
      color: var(--ink);
      padding: 8px 10px;
      border-radius: 8px;
      font-size: 13px;
    }
    .toolbar button.filter-btn, .chip {
      appearance: none;
      border: 1px solid var(--grid-border);
      background: var(--chip);
      color: var(--ink);
      padding: 8px 12px;
      border-radius: 999px;
      font-weight: 600;
      font-size: 12px;
      cursor: pointer;
    }
    .toolbar button.filter-btn:hover, .chip:hover { filter: brightness(1.05); }
    .chip.on {
      background: var(--chip-on);
      outline: 2px solid var(--chip-ring);
    }

    .legend { display: flex; align-items: center; gap: 8px; font-size: 12px; color: var(--muted); }
    .swatch { width: 14px; height: 14px; border-radius: 3px; border: 1px solid var(--grid-border); }
    .heatmap-tiles {
      display: flex;
      flex-direction: column;
      gap: 16px;
      margin-top: 12px;
    }
    .heatmap-tile {
      background: var(--panel);
      border: 1px solid var(--grid-border);
      border-radius: 14px;
      padding: 14px;
      box-shadow: 0 16px 40px rgba(15, 23, 42, 0.06);
    }
    .loading-banner {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      border: 1px solid #f59e0b;
      border-radius: 12px;
      background: rgba(245, 158, 11, 0.12);
      box-shadow: 0 10px 24px rgba(15, 23, 42, 0.08);
      color: #92400e;
      font-size: 13px;
      margin-bottom: 10px;
    }
    .loading-banner .spinner {
      width: 16px;
      height: 16px;
      border: 2px solid var(--grid-border);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
      flex-shrink: 0;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    .heatmap-tile h3 {
      margin: 0 0 8px 0;
      font-size: 16px;
      letter-spacing: 0.2px;
    }
    .heatmap-tile .tile-subtext {
      margin: 0 0 10px 0;
      color: var(--muted);
      font-size: 12px;
      line-height: 1.5;
    }
    .status-pill {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 1px 5px;
      border-radius: 8px;
      font-weight: 700;
      font-size: 9px;
      letter-spacing: 0.2px;
      border: 1px solid transparent;
      min-width: 22px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
      cursor: default;
    }
    .status-pill.up {
      color: #0f5132;
      border-color: rgba(34, 197, 94, 0.35);
      background: linear-gradient(135deg, rgba(16, 185, 129, 0.16), rgba(16, 185, 129, 0.04));
    }
    .status-pill.down {
      color: #7f1d1d;
      border-color: rgba(220, 38, 38, 0.35);
      background: linear-gradient(135deg, rgba(248, 113, 113, 0.2), rgba(248, 113, 113, 0.06));
    }
    .status-pill.limited {
      color: #854d0e;
      border-color: rgba(234, 179, 8, 0.35);
      background: linear-gradient(135deg, rgba(234, 179, 8, 0.2), rgba(234, 179, 8, 0.06));
    }
    .status-pill.unknown {
      color: #334155;
      border-color: rgba(100, 116, 139, 0.35);
      background: linear-gradient(135deg, rgba(148, 163, 184, 0.2), rgba(148, 163, 184, 0.06));
    }
    @media (max-width: 1100px) {
      .heatmap-tiles {
        grid-template-columns: 1fr;
      }
    }

    .grid {
      display: grid;
      grid-template-columns: 260px 1fr;
      margin-top: 14px;
      min-height: 300px;
      max-height: 70vh;
      overflow: auto;
    }
    .grid-head {
      display: grid;
      grid-auto-flow: column;
      grid-auto-columns: 10px; /* day width */
      border-bottom: 1px solid var(--grid-border);
      position: sticky;
      top: 0;
      background: var(--panel);
      z-index: 1;
    }
    .grid-head .tick {
      width: 10px;
      height: 16px;
      border-right: 1px solid var(--grid-divider);
    }
    .grid-left {
      border-right: 1px solid var(--grid-border);
      padding-top: 16px; /* align with header height */
      background: var(--panel);
      position: sticky;
      left: 0;
      z-index: 2;
    }
    .site-row {
      display: flex;
      align-items: center;
      height: 12px; /* matches square size */
      padding: 0 10px;
      gap: 8px;
      border-bottom: 1px solid var(--grid-divider);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      font-size: 12px;
      line-height: 12px;
      color: var(--muted);
    }
    .status-dot {
      width: 10px;
      height: 10px;
      border-radius: 999px;
      border: 1px solid var(--grid-border);
      flex-shrink: 0;
      display: inline-block;
    }
    .status-dot.up { background: var(--good); }
    .status-dot.limited { background: var(--warn); }
    .status-dot.down { background: var(--bad); }
    .status-dot.unknown { background: var(--chip); }
    .grid-right { position: relative; }
    .day-row {
      display: grid;
      grid-auto-flow: column;
      grid-auto-columns: 12px; /* square size */
    }
    .px0 { padding-left: 0; padding-right: 0; }
    .square {
      width: 12px;
      height: 12px;
      border-right: 1px solid var(--grid-divider);
      border-bottom: 1px solid var(--grid-divider);
    }
    .square:hover { outline: 1px solid rgba(37,99,235,0.35); outline-offset: -1px; }

    .toolbar { display: flex; align-items: flex-end; gap: 6px; justify-content: space-between; flex-wrap: wrap; }
    .right { display: flex; gap: 6px; align-items: center; flex-wrap: wrap; }

    .tip {
      position: fixed;
      pointer-events: none;
      z-index: 20;
      background: var(--tooltip-bg);
      color: var(--ink);
      border: 1px solid var(--grid-border);
      border-radius: 8px;
      font-size: 12px;
      padding: 10px 12px;
      box-shadow: 0 6px 24px rgba(0,0,0,0.18);
      display: block;
      max-width: 320px;
      line-height: 1.25;
    }
    .tip[hidden] { display: none; }
    .heatmap-tooltip .tt-title {
      font-weight: 600;
      margin-bottom: 4px;
    }
    .heatmap-tooltip .tt-mode {
      font-size: 12px;
      margin-bottom: 2px;
    }
    .heatmap-tooltip .tt-anomaly {
      font-size: 12px;
      opacity: 0.8;
    }
    .muted { color: var(--muted); }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    .tiny { font-size: 11px; }
    /* Tighten container padding so it matches other pages */
    .heatmap-page .sis-content {
      padding: 4px 16px 0;
    }
    .heatmap-page .sis-main {
      padding: 0 16px;
      margin: 16px 0 64px;
    }
  </style>
</head>
<body class="heatmap-page">
  <header class="sis-header">
    <div class="sis-topbar">
      <div class="sis-title">Strivve Insights Service</div>

            <nav class="sis-nav">
        <a href="index.html">Overview</a>
        <a href="funnel.html">FI Funnel</a>
        <a href="sources.html">Sources</a>
        <a href="heatmap.html">Merchant Heatmap</a>
        <a href="watchlist.html">Alerts</a>
        <a href="troubleshoot.html">Troubleshooting</a>
        <a href="maintenance.html">Maintenance</a>
        <a href="fi-api.html">FI API Data</a>
        <a href="logs.html">Server Logs</a>
      </nav>
    </div>

    <h1 class="sis-page-name">Merchant Reach &amp; Reliability</h1>
    <p class="sis-page-desc">Track where cardholders succeed and struggle: traffic, health, and anomalies across your merchant footprint.</p>
  </header>
  <div class="sis-content">
  <main class="sis-main">
    <section class="sis-panel heatmap-panel">

    <div class="muted" style="font-size:13px; margin:0 0 10px 2px;">
      Filters and date range apply to both tiles (heatmap + health snapshot). Traffic source toggles include/exclude production and test merchant traffic.
    </div>
      <div id="pageLoader" class="loading-banner" hidden>
        <div class="spinner" aria-hidden="true"></div>
        <div class="loading-text">Loading merchant dataâ€¦</div>
      </div>
      <div id="filter-bar" style="margin-bottom: 8px;"></div>

    <div class="toolbar">
      <div class="filter-row">
        <div class="filter-field">
          <label for="datePreset">Range preset</label>
          <select id="datePreset">
            <option value="last7">Last 7 days</option>
            <option value="last14">Last 14 days</option>
            <option value="last30">Last 30 days</option>
            <option value="last60">Last 60 days</option>
            <option value="last90" selected>Last 90 days</option>
            <option value="ytd">Year to date</option>
            <option value="">Custom</option>
          </select>
        </div>
        <div class="filter-field">
          <label for="start">Start date</label>
          <input id="start" type="date">
        </div>
        <div class="filter-field">
          <label for="end">End date</label>
          <input id="end" type="date">
        </div>
        <div class="filter-field">
          <label for="apply">Actions</label>
          <div class="filter-actions">
            <button id="apply" class="filter-btn" type="button">Apply filters</button>
            <span class="muted tiny mono" id="count"></span>
          </div>
        </div>
        <div class="filter-field filter-toggle">
          <label>Traffic sources</label>
          <label class="toggle">
            <input type="checkbox" id="includeProdMerchants" checked />
            Include production traffic
          </label>
          <label class="toggle">
            <input type="checkbox" id="includeTestMerchants" />
            Include traffic from test (customer-dev) FIs
          </label>
        </div>
      </div>
      <div class="right mode-row">
        <span class="muted tiny">Mode:</span>
        <button class="chip on" data-mode="traffic" id="m-traffic">Traffic</button>
        <button class="chip" data-mode="health" id="m-health">Health</button>
        <button class="chip" data-mode="conversion" id="m-conv">Conversion</button>
        <button class="chip" data-mode="anomaly" id="m-anom">Anomaly</button>
        <button class="chip" data-mode="availability" id="m-availability">Availability</button>
      </div>
    </div>
      <div style="height:6px"></div>
      <div class="muted tiny" style="margin:4px 0 6px 2px;">Filters and date range apply to both tiles.</div>

      <div class="heatmap-tiles">
        <div class="heatmap-tile">
          <h3>Daily Merchant Footprint</h3>
          <p class="tile-subtext">Day-by-day view of traffic, health, conversion, anomalies, or availability across your merchant listâ€”filtered to your issuers and date window.</p>
          <div class="row" style="margin-bottom:8px;">
            <div class="legend" id="legend"></div>
          </div>
          <div class="grid" id="grid" aria-busy="true">
            <div class="grid-left" id="leftCol"></div>
            <div class="grid-right">
              <div class="grid-head" id="headTicks"></div>
              <div id="rows"></div>
            </div>
          </div>
        </div>

        <div class="heatmap-tile" id="healthSummaryPanel">
          <h3>Merchant Health Snapshot</h3>
          <p class="tile-subtext">Summarized merchant health over the same windowâ€”quickly see strong performers, watchlist candidates, and trends before cardholders feel pain.</p>
          <div id="healthSummary" class="muted tiny">Loadingâ€¦</div>
          <div class="muted tiny" style="margin-top:8px; line-height:1.4;">
            Legend: ðŸŸ¢ health â‰¥80%, ðŸŸ  50â€“79%, ðŸ”´ <50%; UX ðŸŸ¢ <25%, ðŸŸ¡ 25â€“49%, ðŸ”´ â‰¥50%.
            Arrows: â†‘/â†“ latest day â‰¥10pp vs prior 6-day avg; â†—/â†˜ between 2â€“10pp; â†’ within Â±2pp.
          </div>
        </div>
      </div>
    </section>
  </main>
  </div>

  <div class="tip heatmap-tooltip" id="tip" hidden></div>

  <script>
    // ===== Utilities =====
    const $ = (sel) => document.querySelector(sel);
    const fmtPct = (num) => (Number.isFinite(num) ? (num * 100).toFixed(1) + "%" : "â€”");
    const formatPercentValue = (value) => {
      if (!Number.isFinite(value)) return null;
      const str = value.toFixed(1).replace(/\.0$/, "");
      return `${str}%`;
    };
    function escapeHtml(value) {
      return (value ?? "")
        .toString()
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }

    const urlParams = new URLSearchParams(location.search);
    const dayMs = 86400000;
    const pageLoader = $("#pageLoader");
    function isoLocalFromDate(d) {
      const copy = new Date(d.getTime());
      copy.setHours(0, 0, 0, 0);
      const tzOffset = copy.getTimezoneOffset() * 60000;
      return new Date(copy.getTime() - tzOffset).toISOString().slice(0, 10);
    }
    function isoYesterday() {
      const d = new Date();
      d.setDate(d.getDate() - 1);
      return isoLocalFromDate(d);
    }
    function isoDaysAgo(n, refIso) {
      if (refIso) {
        const [y, m, dd] = refIso.split("-").map((v) => parseInt(v, 10));
        const base = new Date(Date.UTC(y, (m || 1) - 1, dd || 1));
        base.setUTCDate(base.getUTCDate() - n);
        return isoLocalFromDate(base);
      }
      const d = new Date();
      d.setDate(d.getDate() - n);
      return isoLocalFromDate(d);
    }
    function enumerate(start, end) {
      const out = [];
      let c = new Date(start + "T00:00:00Z").getTime();
      const e = new Date(end + "T00:00:00Z").getTime();
      const day = 86400000;
      while (c <= e) { out.push(new Date(c).toISOString().slice(0,10)); c += day; }
      return out;
    }

    // Color scales
    function lerp(a,b,t){ return a + (b-a)*t; }
    function clamp01(x){ return Math.max(0, Math.min(1, x)); }
    // Green scale for positive intensity (traffic/conversion)
    function greenScale(t){
      t = clamp01(t);
      const r = Math.round(lerp(18, 59, t));
      const g = Math.round(lerp(65, 214, t));
      const b = Math.round(lerp(40, 113, t));
      return `rgb(${r},${g},${b})`;
    }
    // Red scale for failure rate (health)
    function redScale(t){
      t = clamp01(t);
      const r = Math.round(lerp(60, 255, t));
      const g = Math.round(lerp(30, 107, t));
      const b = Math.round(lerp(30, 107, t));
      return `rgb(${r},${g},${b})`;
    }
    // Purple scale for anomaly intensity
    function purpleScale(t){
      t = clamp01(t);
      const r = Math.round(lerp(60, 180, t));
      const g = Math.round(lerp(50, 110, t));
      const b = Math.round(lerp(90, 255, t));
      return `rgb(${r},${g},${b})`;
    }
    const veryLight = "rgba(255,255,255,0.04)";

    function normalizeMerchantStats(stats, daysOrder) {
      const safe = stats && typeof stats === "object" ? stats : {};
      const total = Number(safe.total || 0);
      const billable = Number(safe.billable || 0);
      const siteFailures = Number(
        safe.siteFailures ?? safe.siteFail ?? 0
      );
      const userFlowIssues = Number(safe.userFlowIssues || 0);
      const overall =
        typeof safe.overallHealthPct === "number"
          ? safe.overallHealthPct
          : null;
      const baseDays = Array.isArray(safe.days)
        ? safe.days
        : (daysOrder || []).map((day) => ({ day }));
      const days = baseDays.map((cell) => {
        const day = cell.day;
        const bill = Number(cell.billable || 0);
        const sf = Number((cell.siteFail ?? cell.siteFailures) || 0);
        const ux = Number(cell.userFlowIssues || 0);
        const tot = Number(cell.total || 0);
        const denom = bill + sf;
        const pct =
          denom > 0 ? Number(((bill / denom) * 100).toFixed(1)) : null;
        return {
          day,
          billable: bill,
          siteFail: sf,
          siteFailures: sf,
          userFlowIssues: ux,
          total: tot,
          pct,
        };
      });
      return {
        total,
        billable,
        siteFailures,
        userFlowIssues,
        overallHealthPct: overall,
        days,
      };
    }

    function mergeDayStats(daysOrder, primaryDays, secondaryDays) {
      const map = new Map();
      const add = (cell) => {
        if (!cell || !cell.day) return;
        const key = cell.day;
        if (!map.has(key)) {
          map.set(key, {
            day: key,
            billable: 0,
            siteFail: 0,
            siteFailures: 0,
            userFlowIssues: 0,
            total: 0,
          });
        }
        const bucket = map.get(key);
        bucket.billable += Number(cell.billable || 0);
        const sf = Number((cell.siteFail ?? cell.siteFailures) || 0);
        bucket.siteFail += sf;
        bucket.siteFailures = bucket.siteFail;
        bucket.userFlowIssues += Number(cell.userFlowIssues || 0);
        bucket.total += Number(cell.total || 0);
      };
      (primaryDays || []).forEach(add);
      (secondaryDays || []).forEach(add);
      return (daysOrder || []).map((day) => {
        const base =
          map.get(day) || {
            day,
            billable: 0,
            siteFail: 0,
            siteFailures: 0,
            userFlowIssues: 0,
            total: 0,
          };
        const denom = base.billable + base.siteFail;
        const pct =
          denom > 0 ? Number(((base.billable / denom) * 100).toFixed(1)) : null;
        return { ...base, siteFailures: base.siteFail, pct };
      });
    }

    function mergeMerchantStats(prodStats, testStats, daysOrder) {
      const billable = prodStats.billable + testStats.billable;
      const siteFailures = prodStats.siteFailures + testStats.siteFailures;
      const total = prodStats.total + testStats.total;
      const userFlowIssues =
        prodStats.userFlowIssues + testStats.userFlowIssues;
      const denom = billable + siteFailures;
      const overall =
        denom > 0 ? Number(((billable / denom) * 100).toFixed(1)) : null;
      const days = mergeDayStats(daysOrder, prodStats.days, testStats.days);
      return {
        total,
        billable,
        siteFailures,
        userFlowIssues,
        overallHealthPct: overall,
        days,
      };
    }

    function transformMerchantRow(row, options, daysOrder) {
      const includeProd = options?.includeProd ?? true;
      const includeTests = options?.includeTest ?? false;
  const prodFallback = {
    total: row.prod_traffic ?? row.total ?? 0,
    billable: row.billable ?? 0,
        siteFailures: row.siteFailures ?? row.siteFail ?? 0,
        userFlowIssues: row.userFlowIssues ?? 0,
        days: row.days || [],
        overallHealthPct: row.overallHealthPct ?? null,
      };
      const prodStats = normalizeMerchantStats(
        row.prod_stats || prodFallback,
        daysOrder
      );
      const testStats = normalizeMerchantStats(
        row.test_stats || {
          total: row.test_traffic ?? 0,
          billable: 0,
          siteFailures: 0,
          userFlowIssues: 0,
          days: row.test_days || [],
        },
        daysOrder
      );
  let mergedStats;
  if (includeProd && includeTests) {
    mergedStats = mergeMerchantStats(prodStats, testStats, daysOrder);
  } else if (includeTests && !includeProd) {
    mergedStats = testStats;
  } else {
    mergedStats = prodStats;
  }
  return {
    ...row,
    total: mergedStats.total,
        billable: mergedStats.billable,
        siteFailures: mergedStats.siteFailures,
        userFlowIssues: mergedStats.userFlowIssues,
        overallHealthPct: mergedStats.overallHealthPct,
        days: mergedStats.days,
        prod_traffic: prodStats.total,
        test_traffic: testStats.total,
        has_test_fi:
          row.has_test_fi ?? testStats.total > 0,
        has_prod_fi: prodStats.total > 0,
        prod_stats: prodStats,
        test_stats: testStats,
      };
    }

    function normalizeIntegration(value) {
      if (!value) return "UNKNOWN";
      const upper = value.toString().trim().toUpperCase();
      if (upper === "SSO") return "SSO";
      if (upper === "NON-SSO" || upper === "NON_SSO" || upper === "NONSSO") return "NON-SSO";
      if (upper === "CARDSAVR" || upper === "CARD-SAVR") return "CARDSAVR";
      if (upper === "TEST") return "TEST";
      return upper || "UNKNOWN";
    }

    async function fetchRegistry() {
      try {
        const res = await fetch("/fi-registry");
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json();
        registryEntries = Object.entries(data || {}).map(([key, entry]) => {
          const inst = entry.instance || key.split("__")[1] || null;
          return {
            fi: entry.fi_name || key.split("__")[0] || key,
            integration: normalizeIntegration(entry.integration_type),
            partner: entry.partner || "Unknown",
            instance: inst,
          };
        });
        registryInstanceMap = new Map();
        registryEntries.forEach((entry) => {
          const fiKey = normalizeFi(entry.fi);
          if (!fiKey) return;
          const instNorm = normalizeInstance(entry.instance);
          if (!instNorm) return;
          if (!registryInstanceMap.has(fiKey)) registryInstanceMap.set(fiKey, new Set());
          registryInstanceMap.get(fiKey).add(instNorm);
        });
      } catch (err) {
        console.error("Failed to load fi_registry for filters", err);
        registryEntries = [];
        registryInstanceMap = new Map();
      }
    }

    function classifyStatus(tags = []) {
      const lower = tags.map((t) => t && t.toString().toLowerCase());
      if (lower.some((t) => t.includes("down") || t.includes("disabled"))) {
        return { label: "Down", css: "down" };
      }
      if (lower.some((t) => t.includes("limited") || t.includes("beta") || t.includes("degraded"))) {
        return { label: "Limited", css: "limited" };
      }
      if (lower.some((t) => t.includes("unrestricted") || t === "prod")) {
        return { label: "Up", css: "up" };
      }
      return { label: "Unknown", css: "unknown" };
    }

    async function loadMerchantStatuses() {
      try {
        const res = await fetch("/merchant-sites", { cache: "no-store" });
        if (!res.ok) return;
        const data = await res.json();
        const map = new Map();
        const sites = Array.isArray(data?.sites) ? data.sites : [];
        sites.forEach((s) => {
          const host = (s.host || s.hostname || "").toString().toLowerCase();
          if (!host) return;
          const tags = Array.isArray(s.tags) ? s.tags : [];
          const status = classifyStatus(tags);
          map.set(host, { ...status, tags });
        });
        merchantStatusMap = map;
      } catch (err) {
        console.warn("Failed to load merchant site statuses", err);
      }
    }

    function getMerchantStatusMeta(merchantName) {
      const host = (merchantName || "").toString().toLowerCase();
      return merchantStatusMap.get(host) || null;
    }

    // ===== State =====
    let MODE = "traffic"; // traffic | health | conversion | anomaly | availability
    const startEl = $("#start");
    const endEl = $("#end");
    const applyBtn = $("#apply");
    const datePreset = $("#datePreset");
    const instanceSelect = $("#instanceFilter");
    const integrationSelect = $("#integrationFilter");
    const partnerSelect = $("#partnerFilter");
    const headTicks = $("#headTicks");
    const leftCol = $("#leftCol");
    const rowsWrap = $("#rows");
    const legendEl = $("#legend");
    const tip = $("#tip");
    const countEl = $("#count");
    const healthSummaryEl = $("#healthSummary");
    let merchantStatusMap = new Map();
    const includeProdToggle = document.getElementById("includeProdMerchants");
    const includeTestToggle = document.getElementById("includeTestMerchants");
    const INSTANCE_ALL_VALUE = "__all_instances__";
    const FI_ALL_VALUE = "__all__";
    const PARTNER_ALL_VALUE = "__all_partners__";
    let latestMerchantPayload = null;
    let registryEntries = [];
    let registryInstanceMap = new Map();
    let latestRenderedData = null;

    const normalizeFi = (val) => (val || "").toString().trim().toLowerCase();
    const normalizeInstance = (val) =>
      (val || "").toString().trim().toLowerCase();
    function createEmptyStore() {
      return { total: 0, billable: 0, siteFailures: 0, userFlowIssues: 0, daily: new Map() };
    }
    function addStats(store, stats) {
      if (!stats) return;
      store.total += Number(stats.total || 0);
      store.billable += Number(stats.billable || 0);
      store.siteFailures += Number(stats.siteFailures || stats.siteFail || 0);
      store.userFlowIssues += Number(stats.userFlowIssues || 0);
      const daysArr = Array.isArray(stats.days) ? stats.days : [];
      daysArr.forEach((d) => {
        const dayKey = d.day || d.date;
        if (!dayKey) return;
        if (!store.daily.has(dayKey)) {
          store.daily.set(dayKey, { total: 0, billable: 0, siteFailures: 0, userFlowIssues: 0 });
        }
        const cur = store.daily.get(dayKey);
        cur.total += Number(d.total || 0);
        cur.billable += Number(d.billable || 0);
        cur.siteFailures += Number(d.siteFailures || d.siteFail || 0);
        cur.userFlowIssues += Number(d.userFlowIssues || 0);
      });
    }
    function finalizeStore(store, daysOrder) {
      const dayCells = (daysOrder || []).map((day) => {
        const cur = store.daily.get(day) || { total: 0, billable: 0, siteFailures: 0, userFlowIssues: 0 };
        const denom = cur.billable + cur.siteFailures;
        const pct = denom > 0 ? Number(((cur.billable / denom) * 100).toFixed(1)) : null;
        return { day, total: cur.total, billable: cur.billable, siteFailures: cur.siteFailures, userFlowIssues: cur.userFlowIssues, pct };
      });
      const overallDenom = store.billable + store.siteFailures;
      const overallHealthPct = overallDenom > 0 ? Number(((store.billable / overallDenom) * 100).toFixed(1)) : null;
      return {
        total: store.total,
        billable: store.billable,
        siteFailures: store.siteFailures,
        userFlowIssues: store.userFlowIssues,
        overallHealthPct,
        days: dayCells,
      };
    }
    function sliceMerchant(row, opts = {}, days) {
      const includeProd = opts.includeProd ?? (includeProdToggle?.checked !== false);
      const includeTests = opts.includeTests ?? (includeTestToggle?.checked ?? false);
      const integrationFilter = opts.integration ?? integrationSelect?.value ?? "(all)";
      const partnerFilter = opts.partner ?? partnerSelect?.value ?? PARTNER_ALL_VALUE;
    const fiFilter = opts.fi ?? FI_ALL_VALUE;
      const fiFilterSetRaw = opts.fiSet instanceof Set ? opts.fiSet : null;
      if (fiFilterSetRaw && fiFilterSetRaw.size === 0) return null; // explicit empty = show nothing
      const fiFilterSet =
        fiFilterSetRaw && fiFilterSetRaw.size
          ? new Set(Array.from(fiFilterSetRaw).map((fi) => normalizeFi(fi)))
          : null;
      const instanceFilter = opts.instance ?? instanceSelect?.value ?? INSTANCE_ALL_VALUE;
      const instanceFilterNormalized =
        instanceFilter && instanceFilter !== INSTANCE_ALL_VALUE ? normalizeInstance(instanceFilter) : null;
      const fiFilterNormalized =
        fiFilter && fiFilter !== FI_ALL_VALUE ? normalizeFi(fiFilter) : null;

      const prodStore = createEmptyStore();
      const testStore = createEmptyStore();
      const fiSet = new Set();
      const integrationSet = new Set();
      const partnerSet = new Set();
      const instanceSet = new Set();

      // If the merchant can be mapped to FI(s) directly from row data, use that to short-circuit when a FI filter is active.
      let rowFiSet = null;
      if (fiFilterSet) {
        const directList = Array.isArray(row.fi_list)
          ? row.fi_list
          : [];
        const mapped = directList.length ? directList : mapFiForMerchant(row);
        if (Array.isArray(mapped) && mapped.length) {
          rowFiSet = new Set(mapped.map((v) => normalizeFi(v)).filter(Boolean));
          const matchesRowFi = Array.from(rowFiSet).some((fi) => fiFilterSet.has(fi));
          if (!matchesRowFi) return null;
        }
      }

      const buckets = Array.isArray(row.buckets) ? row.buckets : [];
      const rowIntegrationSet = new Set(
        (row.integration_list || []).map((v) => normalizeIntegration(v))
      );
      const rowPartnerSet = new Set(
        (row.partner_list || []).map((v) => (v || "Unknown"))
      );
      buckets.forEach((b) => {
        const bucketIntegration = normalizeIntegration(b.integration);
        if (b.is_test && !includeTests) return;
        if (!b.is_test && !includeProd) return;
        const filterIntegrationNorm = normalizeIntegration(integrationFilter);
        const bucketPartner = b.partner || "Unknown";
        if (
          filterIntegrationNorm &&
          filterIntegrationNorm !== "(ALL)" &&
          bucketIntegration !== filterIntegrationNorm &&
          !rowIntegrationSet.has(filterIntegrationNorm)
        )
          return;
        if (
          partnerFilter &&
          partnerFilter !== PARTNER_ALL_VALUE &&
          bucketPartner !== partnerFilter &&
          !rowPartnerSet.has(partnerFilter)
        )
          return;
        if (fiFilterSet && fiFilterSet.size) {
          const normFi = normalizeFi(b.fi);
          if (normFi) {
            if (!fiFilterSet.has(normFi)) return;
          } else if (!rowFiSet || !Array.from(rowFiSet).some((fi) => fiFilterSet.has(fi))) {
            return;
          }
        } else if (fiFilterNormalized) {
          if (normalizeFi(b.fi) !== fiFilterNormalized) return;
        }
        if (instanceFilterNormalized) {
          const norm = normalizeInstance(b.instance);
          if (norm !== instanceFilterNormalized) return;
        }
        const store = b.is_test ? testStore : prodStore;
        addStats(store, b.stats);
        if (b.fi) fiSet.add(b.fi);
        if (bucketIntegration) integrationSet.add(bucketIntegration);
        partnerSet.add(b.partner || "Unknown");
        if (b.instance) instanceSet.add(b.instance);
      });

      // If nothing matched, skip merchant
      if (prodStore.total === 0 && testStore.total === 0) return null;

      return {
        merchant: row.merchant,
        prod_stats: finalizeStore(prodStore, days),
        test_stats: finalizeStore(testStore, days),
        prod_traffic: prodStore.total,
        test_traffic: testStore.total,
        has_prod_fi: prodStore.total > 0,
        has_test_fi: testStore.total > 0,
        instance_list: Array.from(instanceSet),
        fi_list: Array.from(fiSet),
        integration_list: Array.from(integrationSet),
        partner_list: Array.from(partnerSet),
      };
    }

    function currentFiSet() {
      const shared = window.__FILTER_STATE;
      const registry = window.__FILTER_REGISTRY || [];
      if (!shared || shared.page !== "heatmap" || !registry.length) return null;
      let eligible = registry.filter((entry) => {
        if (shared.partner !== "All" && entry.partner !== shared.partner) return false;
        if (shared.integration !== "All" && entry.integration !== shared.integration) return false;
        if (shared.instance !== "All" && entry.instance !== shared.instance) return false;
        return true;
      });
      if (shared.fis && shared.fis.size) {
        eligible = eligible.filter((e) => shared.fis.has(e.fi_lookup_key));
      }
      return new Set(eligible.map((e) => e.fi_lookup_key));
    }

    function mapFiForMerchant(row) {
      if (!row) return null;
      const registry = window.__FILTER_REGISTRY || [];
      const byName = new Map();
      const byKey = new Map();
      registry.forEach((entry) => {
        const nameKey = normalizeFi(entry.fi_name);
        const keyKey = normalizeFi(entry.fi_lookup_key);
        if (nameKey) byName.set(nameKey, entry.fi_lookup_key);
        if (keyKey) byKey.set(keyKey, entry.fi_lookup_key);
      });

      if (Array.isArray(row.fi_list) && row.fi_list.length) {
        return row.fi_list
          .map((val) => {
            const norm = normalizeFi(val);
            if (!norm) return null;
            if (byKey.has(norm)) return byKey.get(norm);
            if (byName.has(norm)) return byName.get(norm);
            return norm;
          })
          .filter(Boolean);
      }

      if (!registry.length) return [];
      const fiName = normalizeFi(row.fi || row.fi_name || row.name || "");
      const inst = normalizeInstance(row.instance || row.instance_name || "");
      if (!fiName) return [];
      const matches = registry.filter((entry) => {
        if (normalizeFi(entry.fi_lookup_key || entry.fi_name) !== fiName) return false;
        if (inst && entry.instance && normalizeInstance(entry.instance) !== inst) return false;
        return true;
      });
      return matches.map((m) => m.fi_lookup_key);
    }

    function aggregateSlicesToMerchants(slices = [], days = []) {
      const dayIndex = new Map(days.map((d, idx) => [d, idx]));
      const makeStore = () => ({
        total: 0,
        billable: 0,
        siteFailures: 0,
        userFlowIssues: 0,
        days: Array.from({ length: days.length }, (_, i) => ({
          day: days[i],
          total: 0,
          billable: 0,
          siteFailures: 0,
          userFlowIssues: 0,
        })),
      });
      const merchants = new Map();
      slices.forEach((s) => {
        if (!s || !s.merchant) return;
        if (!merchants.has(s.merchant)) {
          merchants.set(s.merchant, {
            prod: makeStore(),
            test: makeStore(),
            fiSet: new Set(),
            instanceSet: new Set(),
            integrationSet: new Set(),
            partnerSet: new Set(),
            testInstanceSet: new Set(),
          });
        }
        const m = merchants.get(s.merchant);
        const store = s.is_test ? m.test : m.prod;
        const idx = dayIndex.has(s.day) ? dayIndex.get(s.day) : -1;
        store.total += Number(s.total || 0);
        store.billable += Number(s.billable || 0);
        store.siteFailures += Number(s.siteFailures || 0);
        store.userFlowIssues += Number(s.userFlowIssues || 0);
        if (idx >= 0) {
          const entry = store.days[idx];
          entry.total += Number(s.total || 0);
          entry.billable += Number(s.billable || 0);
          entry.siteFailures += Number(s.siteFailures || 0);
          entry.userFlowIssues += Number(s.userFlowIssues || 0);
        }
        if (s.fi) m.fiSet.add(s.fi);
        if (s.instance) m.instanceSet.add(s.instance);
        if (s.integration) m.integrationSet.add(s.integration);
        if (s.partner) m.partnerSet.add(s.partner);
        if (s.is_test && s.instance) m.testInstanceSet.add(s.instance);
      });

      const summarizeStore = (store) => {
        const denom = store.billable + store.siteFailures;
        const overallHealthPct = denom > 0 ? Number(((store.billable / denom) * 100).toFixed(1)) : null;
        return { ...store, overallHealthPct };
      };

      const rows = Array.from(merchants.entries()).map(([merchant, stats]) => {
        const prodStats = summarizeStore(stats.prod);
        const testStats = summarizeStore(stats.test);
        const fiList = Array.from(stats.fiSet);
        const instanceList = Array.from(stats.instanceSet);
        const integrationList = Array.from(stats.integrationSet);
        const partnerList = Array.from(stats.partnerSet);
        return {
          merchant,
          total: prodStats.total + testStats.total,
          billable: prodStats.billable + testStats.billable,
          siteFailures: prodStats.siteFailures + testStats.siteFailures,
          userFlowIssues: prodStats.userFlowIssues + testStats.userFlowIssues,
          overallHealthPct: prodStats.overallHealthPct,
          days: prodStats.days, // prod days only for coloring; test shown via test_stats
          prod_stats: prodStats,
          test_stats: testStats,
          prod_traffic: prodStats.total,
          test_traffic: testStats.total,
          has_test_fi: testStats.total > 0,
          has_prod_fi: prodStats.total > 0,
          fi_list: fiList,
          instance_list: instanceList,
          integration_list: integrationList,
          partner_list: partnerList,
          test_instances: Array.from(stats.testInstanceSet),
        };
      });

      rows.sort((a, b) => (b.total || 0) - (a.total || 0));
      return rows;
    }
    function applyFilters() {
      if (!currentData) return;
      const shared = window.__FILTER_STATE;
      const useShared = shared && shared.page === "heatmap";
      const sharedFisSet = useShared && shared?.fis ? new Set(shared.fis) : null;
      const fiFilterSet =
        useShared && sharedFisSet
          ? new Set(Array.from(sharedFisSet).map((fi) => normalizeFi(fi)).filter(Boolean))
          : null;

      let slices = currentData?.slices || [];
      const days = currentData?.days || [];
      if ((!slices || !slices.length) && currentData?.merchants) {
        slices = slicesFromLegacy(currentData);
      }

      const includeProd = includeProdToggle?.checked !== false;
      const includeTests = includeTestToggle?.checked ?? false;

      const filteredSlices = slices.filter((s) => {
        if (fiFilterSet) {
          if (fiFilterSet.size === 0) return false; // explicit none selected
          if (!fiFilterSet.has(normalizeFi(s.fi))) return false;
        }
        if (!includeProd && !s.is_test) return false;
        if (!includeTests && s.is_test) return false;
        return true;
      });

      const merchants = aggregateSlicesToMerchants(filteredSlices, days);

      populateFilterOptionsFromSlices(slices);

      latestRenderedData = { days, merchants };
      render(latestRenderedData);
    }

    includeTestToggle?.addEventListener("change", () => applyFilters());
    instanceSelect?.addEventListener("change", () => applyFilters());
    includeProdToggle?.addEventListener("change", () => applyFilters());
    integrationSelect?.addEventListener("change", () => applyFilters());
    partnerSelect?.addEventListener("change", () => applyFilters());

    // initial dates: from query or default last 90 days
    const initEndParam = urlParams.get("end");
    const initEndRaw = initEndParam || isoYesterday();
    const clampToYesterday = (iso) => (iso > isoYesterday() ? isoYesterday() : iso);
    const partnerParam = urlParams.get("partner");
    const integrationParam = urlParams.get("integration");
    const instanceParam = urlParams.get("instance");
    const fiParam = urlParams.get("fi");
    const hasUrlFilters = Boolean(partnerParam || integrationParam || instanceParam || fiParam);

    let initEnd = clampToYesterday(initEndRaw);
    let initStart = urlParams.get("start") || isoDaysAgo(89, initEnd);
    let initPreset = "";
    if (!urlParams.has("start") && !urlParams.has("end")) {
      initPreset = "last90";
      initEnd = isoYesterday();
      initStart = isoDaysAgo(89, initEnd);
    }
    startEl.value = initStart;
    endEl.value = initEnd;
    if (partnerSelect && partnerParam) partnerSelect.value = partnerParam;
    if (integrationSelect && integrationParam) integrationSelect.value = integrationParam;
    if (instanceSelect && instanceParam) instanceSelect.value = instanceParam;
    if (datePreset && initPreset) datePreset.value = initPreset;

      // mode chips
      for (const el of document.querySelectorAll(".chip[data-mode]")) {
        el.addEventListener("click", () => {
          for (const b of document.querySelectorAll(".chip[data-mode]")) b.classList.remove("on");
          el.classList.add("on");
          MODE = el.dataset.mode;
          // Availability uses both prod + test; lock toggles while active
          if (MODE === "availability") {
            if (includeProdToggle) {
              includeProdToggle.checked = true;
              includeProdToggle.disabled = true;
            }
            if (includeTestToggle) {
              includeTestToggle.checked = true;
              includeTestToggle.disabled = true;
            }
          } else {
            if (includeProdToggle) includeProdToggle.disabled = false;
            if (includeTestToggle) includeTestToggle.disabled = false;
          }
          applyFilters();
        });
      }

    function applyCurrentRange() {
      const s = startEl.value;
      const e = endEl.value;
      const u = new URL(location.href);
      u.searchParams.set("start", s);
      u.searchParams.set("end", e);
      history.replaceState(null, "", u);
      loadAndRender(s, e).then(() => applyFilters());
    }

    function applyPresetRange(preset) {
      const base = isoYesterday();
      let start = startEl.value || base;
      let end = endEl.value || base;
      if (end > base) {
        end = base;
      }
      if (start > end) {
        start = end;
      }
      const yearStart = `${new Date().getFullYear()}-01-01`;
      switch (preset) {
        case "last7":
          start = isoDaysAgo(6, base);
          end = base;
          break;
        case "last14":
          start = isoDaysAgo(13, base);
          end = base;
          break;
        case "last30":
          start = isoDaysAgo(29, base);
          end = base;
          break;
        case "last60":
          start = isoDaysAgo(59, base);
          end = base;
          break;
        case "last90":
          start = isoDaysAgo(89, base);
          end = base;
          break;
        case "ytd":
          start = yearStart;
          end = base;
          break;
        default:
          return;
      }
      startEl.value = start;
      endEl.value = end;
      applyCurrentRange();
    }

    applyBtn.addEventListener("click", () => {
      applyCurrentRange();
    });

    datePreset?.addEventListener("change", (ev) => {
      const val = ev.target.value;
      if (!val) return; // Custom
      applyPresetRange(val);
    });

    // ===== Data shape expected from server =====
    // GET /data/merchant-heatmap?start=YYYY-MM-DD&end=YYYY-MM-DD
    // {
    //   start: "YYYY-MM-DD", end: "YYYY-MM-DD", days: ["..."],
    //   merchants: [
    //     {
    //       name: "amazon.com",
    //       total: 123, billable: 77, siteFailures: 21, userFlowIssues: 25,
    //       daily: { "2025-10-01": { total, billable, siteFailures, userFlowIssues }, ... }
    //     }, ...
    //   ]
    // }

    let currentData = null;

    function setLoading(isLoading, message) {
      if (!pageLoader) return;
      pageLoader.hidden = !isLoading;
      pageLoader.style.display = isLoading ? "flex" : "none";
      const textEl = pageLoader.querySelector(".loading-text");
      if (textEl && message) textEl.textContent = message;
    }

    function updateLoadingMessage(message) {
      const textEl = pageLoader?.querySelector(".loading-text");
      if (textEl && message) textEl.textContent = message;
    }

    async function loadAndRender(start, end) {
      try {
        setLoading(true, "Loading merchant dataâ€¦");
        $("#grid").setAttribute("aria-busy", "true");
        if (leftCol) leftCol.innerHTML = "";
        if (rowsWrap) rowsWrap.innerHTML = "";
        if (headTicks) headTicks.innerHTML = "";
        if (legendEl) legendEl.innerHTML = "";

        // Pull slices and merchants in two steps to show progress
        updateLoadingMessage("Loading merchant slicesâ€¦");
        const res = await fetch(`/merchant-heatmap?start=${start}&end=${end}`);
        if (!res.ok) {
          rowsWrap.innerHTML = `<div style="padding:16px" class="muted">Failed to load data (${res.status}).</div>`;
          return;
        }
        const text = await res.text();
        updateLoadingMessage("Parsing merchant dataâ€¦");
        const json = JSON.parse(text);
        currentData = json;
        latestMerchantPayload = json;
        applyFilters();
      } catch (err) {
        console.error("heatmap load failed", err);
        if (rowsWrap) {
          rowsWrap.innerHTML = `<div style="padding:16px" class="muted">Failed to load data.</div>`;
        }
      } finally {
        $("#grid").removeAttribute("aria-busy");
        setLoading(false);
      }
    }

    function populateFilterOptionsFromSlices(slices) {
      if (!Array.isArray(slices)) return;
      const fis = new Set([FI_ALL_VALUE]);
      slices.forEach((s) => {
        fis.add(s.fi || "unknown_fi");
      });
      // Only FI options matter; partner/integration/instance filters are ignored in this simplified model
      if (integrationSelect) {
        integrationSelect.innerHTML = `<option value="(all)">(all)</option>`;
        integrationSelect.value = "(all)";
      }
      if (partnerSelect) {
        partnerSelect.innerHTML = `<option value="${PARTNER_ALL_VALUE}">(all partners)</option>`;
        partnerSelect.value = PARTNER_ALL_VALUE;
      }
      if (instanceSelect) {
        instanceSelect.innerHTML = `<option value="${INSTANCE_ALL_VALUE}">(all instances)</option>`;
        instanceSelect.value = INSTANCE_ALL_VALUE;
      }
    }

    function slicesFromLegacy(payload) {
      if (!payload || !Array.isArray(payload.merchants) || !Array.isArray(payload.days)) return [];
      const out = [];
      payload.merchants.forEach((m) => {
        const merchant = m.merchant || m.name || "unknown";
        const daysArr = Array.isArray(payload.days) ? payload.days : [];
        const buckets = Array.isArray(m.buckets) ? m.buckets : [];
        if (buckets.length === 0) {
          // Fallback: use prod_stats/test_stats per day if buckets missing
          const addFromStats = (stats = {}, is_test = false) => {
            (stats.days || []).forEach((d) => {
              out.push({
                day: d.day,
                merchant,
                fi: "unknown_fi",
                instance: "unknown",
                integration: "UNKNOWN",
                partner: "Unknown",
                is_test,
                total: Number(d.total || 0),
                billable: Number(d.billable || 0),
                siteFailures: Number(d.siteFailures || d.siteFail || 0),
                userFlowIssues: Number(d.userFlowIssues || 0),
              });
            });
          };
          addFromStats(m.prod_stats, false);
          addFromStats(m.test_stats, true);
          return;
        }
        buckets.forEach((b) => {
          const stats = b.stats || {};
          const days = Array.isArray(stats.days) ? stats.days : [];
          if (days.length) {
            days.forEach((d) => {
              out.push({
                day: d.day,
                merchant,
                fi: b.fi || "unknown_fi",
                instance: b.instance || "unknown",
                integration: b.integration || "UNKNOWN",
                partner: b.partner || "Unknown",
                is_test: Boolean(b.is_test),
                total: Number(d.total || 0),
                billable: Number(d.billable || 0),
                siteFailures: Number(d.siteFailures || d.siteFail || 0),
                userFlowIssues: Number(d.userFlowIssues || 0),
              });
            });
          } else {
            // no per-day; spread total across payload days as a single entry for start day
            const dayKey = daysArr[0] || "";
            out.push({
              day: dayKey,
              merchant,
              fi: b.fi || "unknown_fi",
              instance: b.instance || "unknown",
              integration: b.integration || "UNKNOWN",
              partner: b.partner || "Unknown",
              is_test: Boolean(b.is_test),
              total: Number(stats.total || 0),
              billable: Number(stats.billable || 0),
              siteFailures: Number(stats.siteFailures || 0),
              userFlowIssues: Number(stats.userFlowIssues || 0),
            });
          }
        });
      });
      return out;
    }

    function render(json) {
      if (!json || !Array.isArray(json.days) || !Array.isArray(json.merchants)) {
        rowsWrap.innerHTML = `<div style="padding:16px" class="muted">No data.</div>`;
        return;
      }
      hideTooltip();
      const days = json.days;
      const includeProd = includeProdToggle?.checked !== false;
      const includeTests = includeTestToggle?.checked ?? false;
      const transformed = (json.merchants || []).map((m) =>
        transformMerchantRow(
          m,
          { includeProd, includeTest: includeTests },
          days
        )
      );
      const merchants = transformed;
      countEl.textContent = `${merchants.length} merchants â€¢ ${days.length} days`;

      // header ticks (visual rhythm)
      headTicks.innerHTML = "";
      for (let i = 0; i < days.length; i++) {
        const t = document.createElement("div");
        t.className = "tick";
        headTicks.appendChild(t);
      }

      // sort merchants by total traffic across window (desc)
      const sorted = [...merchants].sort((a,b) => (b.total||0) - (a.total||0));

      // build left labels
      leftCol.innerHTML = "";
      for (const m of sorted) {
        const name = m.merchant || m.name || "unknown";
        const successes = Number(m.billable || m.successes || 0);
        const attempts = Number(m.total || 0);
        const label =
          attempts > 0
            ? `${name} (${successes}/${attempts})`
            : name;
        const row = document.createElement("div");
        row.className = "site-row";
        row.title = label;
        const statusMeta = getMerchantStatusMeta(name) || classifyStatus(m.tags || []);
        const statusClass = statusMeta?.css || "unknown";
        const statusLabel = statusMeta?.label || "Status unknown";
        const statusShort =
          statusLabel === "Up"
            ? "U"
            : statusLabel === "Down"
            ? "D"
            : statusLabel === "Limited"
            ? "L"
            : "?";
        const dot = document.createElement("span");
        dot.className = `status-pill ${statusClass}`;
        dot.title = statusLabel;
        dot.setAttribute("aria-label", statusLabel);
        dot.textContent = statusShort;
        const text = document.createElement("span");
        text.textContent = label;
        row.appendChild(dot);
        row.appendChild(text);
        leftCol.appendChild(row);
      }

      // Precompute per-merchant normalization for traffic (so the green scale pops fairly)
      const perMerchantMax = new Map();
      for (const m of sorted) {
        const name = m.merchant || m.name || "unknown";
        const dayMap = new Map((m.days || []).map((cell) => [cell.day, cell]));
        let maxT = 0;
        for (const d of days) {
          const cell = dayMap.get(d);
          if (cell && cell.total) maxT = Math.max(maxT, cell.total);
        }
        perMerchantMax.set(name, Math.max(1, maxT));
      }

      // Render rows
      rowsWrap.innerHTML = "";
      sorted.forEach((m, idx) => {
        const name = m.merchant || m.name || "unknown";
        const dayMap = new Map((m.days || []).map((cell) => [cell.day, cell]));
        const row = document.createElement("div");
        row.className = "day-row";
        row.setAttribute("role", "row");
        days.forEach((d, dayIdx) => {
          const cell = dayMap.get(d) || {};
          const tot = Number(cell.total) || 0;
          const bill = Number(cell.billable) || 0;
          const sf = Number((cell.siteFail ?? cell.siteFailures) || 0);
          const ux = Number(cell.userFlowIssues) || 0;
          const denom = bill + sf;
          const failRate = denom > 0 ? sf / denom : null;
          const convRate = tot > 0 ? bill / tot : null;
          const anomalyInfo = computeAnomalyInfo(dayMap, days, dayIdx, {
            total: tot,
            billable: bill,
            siteFailures: sf,
            userFlowIssues: ux,
          });

          let color = veryLight;
          if (MODE === "traffic") {
            const maxT = perMerchantMax.get(name) || 1;
            const ratio = maxT ? tot / maxT : 0;
            color = tot > 0 ? greenScale(ratio) : veryLight;
          } else if (MODE === "health") {
            color = denom > 0 ? redScale(failRate ?? 0) : veryLight;
          } else if (MODE === "conversion") {
            color = convRate !== null ? greenScale(convRate) : veryLight;
          } else if (MODE === "availability") {
            color = tot > 0 ? greenScale(1) : redScale(1);
          } else if (MODE === "anomaly") {
            const intensity = anomalyInfo.intensity || 0;
            color = intensity > 0 ? purpleScale(intensity) : veryLight;
          }

          const statsForTooltip = {
            ...cell,
            total: tot,
            billable: bill,
            siteFailures: sf,
            siteFail: sf,
            userFlowIssues: ux,
            anomalyInfo,
          };

          const sq = document.createElement("div");
          sq.className = "square";
          sq.style.background = color;
          sq.setAttribute("aria-label", `${name} â€¢ ${d}`);

          sq.addEventListener("mouseenter", (ev) => {
            showTooltip(ev, { merchant: name, date: d, stats: statsForTooltip, mode: MODE });
          });
          sq.addEventListener("mousemove", positionTooltip);
          sq.addEventListener("mouseleave", hideTooltip);

          row.appendChild(sq);
        });
        rowsWrap.appendChild(row);
      });

      // legend
      renderLegend(MODE);
      renderHealthSummary(sorted);
    }

    function renderLegend(mode) {
      const L = legendEl;
      L.innerHTML = "";
      const make = (txt, color) => {
        const c = document.createElement("div"); c.className="legend";
        const s = document.createElement("div"); s.className="swatch"; s.style.background=color;
        const t = document.createElement("div"); t.textContent = txt;
        c.appendChild(s); c.appendChild(t); return c;
      };
      if (mode === "traffic") {
        L.appendChild(make("Higher traffic", greenScale(1)));
        L.appendChild(make("Lower traffic", greenScale(0.2)));
        L.appendChild(make("No data", veryLight));
      } else if (mode === "health") {
        L.appendChild(make("Worse site failure rate", redScale(1)));
        L.appendChild(make("Better (few failures)", redScale(0.15)));
        L.appendChild(make("No signal", veryLight));
      } else if (mode === "conversion") {
        L.appendChild(make("Higher conversion", greenScale(1)));
        L.appendChild(make("Lower conversion", greenScale(0.2)));
        L.appendChild(make("No signal", veryLight));
      } else if (mode === "availability") {
        L.appendChild(make("Available (traffic seen)", greenScale(1)));
        L.appendChild(make("No traffic (down)", redScale(1)));
      } else {
        L.appendChild(make("Stronger anomaly", purpleScale(1)));
        L.appendChild(make("Mild anomaly", purpleScale(0.25)));
        L.appendChild(make("No anomaly", veryLight));
      }
    }

    function computeAnomalyInfo(dayMap, days, dayIdx, stats = {}) {
      const total = Number(stats.total) || 0;
      const billable = Number(stats.billable) || 0;
      const siteFailures = Number(stats.siteFailures) || 0;
      const userFlowIssues = Number(stats.userFlowIssues) || 0;

      const denom = billable + siteFailures;
      const failRate = denom > 0 ? siteFailures / denom : null;
      const uxRate = total > 0 ? userFlowIssues / total : null;

      const baseSamples = [];
      for (let i = dayIdx - 1; i >= 0 && baseSamples.length < 6; i--) {
        const prev = dayMap.get(days[i]);
        if (!prev) continue;
        const prevBill = Number(prev.billable) || 0;
        const prevSf = Number((prev.siteFail ?? prev.siteFailures) || 0);
        const prevDenom = prevBill + prevSf;
        if (prevDenom > 0) {
          baseSamples.push(prevSf / prevDenom);
        }
      }
      const base = baseSamples.length
        ? baseSamples.reduce((sum, val) => sum + val, 0) / baseSamples.length
        : null;

      let intensity = 0;
      const reasons = [];
      if (uxRate !== null && uxRate >= 0.5) {
        intensity = Math.max(intensity, Math.min(1, (uxRate - 0.5) / 0.5 + 0.3));
        reasons.push(`UX friction ${fmtPct(uxRate)} (â‰¥ 50%)`);
      }

      let deltaHealth = null;
      if (failRate !== null && base !== null) {
        const jump = failRate - base;
        if (jump >= 0.20) {
          intensity = Math.max(intensity, Math.min(1, (jump - 0.20) / 0.30 + 0.4));
          reasons.push(`Site failures +${(jump * 100).toFixed(1)}pp vs baseline`);
        }
        deltaHealth = (base - failRate) * 100; // positive = improvement
      }

      let level = "none";
      if (intensity >= 0.65) {
        level = "strong";
      } else if (intensity >= 0.3) {
        level = "mild";
      }

      return { intensity, reasons, level, deltaHealth };
    }

    function formatAnomalyLabel(anomaly) {
      if (!anomaly) return "No anomaly detected";
      const rawLevel = (anomaly.level || anomaly.severity || "").toString().toLowerCase();
      let baseLabel = "No anomaly detected";
      if (rawLevel === "strong") {
        baseLabel = "Strong";
      } else if (rawLevel === "mild") {
        baseLabel = "Mild";
      } else if (rawLevel && rawLevel !== "none") {
        baseLabel = rawLevel.charAt(0).toUpperCase() + rawLevel.slice(1);
      } else if ((anomaly.intensity || 0) > 0) {
        baseLabel = "Mild";
      }

      let detail = "";
      if (Number.isFinite(anomaly.deltaHealth) && Math.abs(anomaly.deltaHealth) >= 1) {
        const dir = anomaly.deltaHealth < 0 ? "dropped" : "increased";
        const pp = Math.abs(anomaly.deltaHealth).toFixed(1).replace(/\.0$/, "");
        detail = `site health ${dir} ${pp}pp vs recent avg`;
      } else if (Array.isArray(anomaly.reasons) && anomaly.reasons.length) {
        detail = anomaly.reasons.join("; ");
      }

      if (baseLabel === "No anomaly detected") {
        return detail ? `${baseLabel} (${detail})` : baseLabel;
      }
      return detail ? `${baseLabel} (${detail})` : baseLabel;
    }

    function buildTooltipHtml({ merchant, date, stats, mode }) {
      const total = Number(stats?.total) || 0;
      const billable = Number(stats?.billable) || 0;
      const siteFailures = Number(stats?.siteFailures ?? stats?.siteFail ?? 0);
      const userFlowIssues = Number(stats?.userFlowIssues) || 0;
      const siteDenom = billable + siteFailures;
      const healthPct = siteDenom > 0 ? (billable / siteDenom) * 100 : null;
      const conversionPct = total > 0 ? (billable / total) * 100 : null;
      const anomalyLabel = formatAnomalyLabel(stats?.anomalyInfo || stats?.anomaly || null);

      const modeLower = (mode || "").toLowerCase();
      let modeLine = "";
      if (modeLower === "traffic") {
        modeLine = total > 0
          ? `Traffic â€” ${total} attempt${total === 1 ? "" : "s"}`
          : "Traffic â€” No attempts";
      } else if (modeLower === "health") {
        if (healthPct === null) {
          modeLine = "Health â€” No signal yet";
        } else {
          const pctStr = formatPercentValue(healthPct) || "";
          modeLine = `Health â€” ${pctStr} ok (${billable} billable / ${siteFailures} site-related)`;
        }
      } else if (modeLower === "conversion") {
        if (conversionPct === null) {
          modeLine = "Conversion â€” No attempts";
        } else {
          const pctStr = formatPercentValue(conversionPct) || "";
          modeLine = `Conversion â€” ${pctStr} billable (${billable}/${total})`;
        }
      } else if (modeLower === "anomaly") {
        modeLine = `Anomaly â€” ${anomalyLabel}`;
      } else {
        modeLine = total > 0
          ? `Summary â€” ${billable}/${total} billable attempts`
          : "Summary â€” No attempts";
      }

      const merchantLabel = escapeHtml(merchant || "");
      const dateLabel = escapeHtml(date || "");
      const safeModeLine = escapeHtml(modeLine);
      const safeAnomalyLabel = escapeHtml(anomalyLabel);
      const anomalySection =
        modeLower === "anomaly"
          ? ""
          : `<div class="tt-anomaly">Anomaly â€” ${safeAnomalyLabel}</div>`;

      return `
        <div class="tt-inner">
          <div class="tt-title">${merchantLabel} â€¢ ${dateLabel}</div>
          <div class="tt-mode">${safeModeLine}</div>
          ${anomalySection}
        </div>
      `;
    }

    function formatPct(value) {
      if (value === null || value === undefined || Number.isNaN(value)) return "â€”";
      return `${value.toFixed(1)}%`;
    }

    function computeTrendArrow(dailyStats = {}, selector) {
      if (typeof selector !== "function") return "";
      const values = Object.entries(dailyStats)
        .map(([day, stats]) => ({ day, value: selector(stats || {}) }))
        .filter(({ value }) => Number.isFinite(value))
        .sort((a, b) => (a.day < b.day ? -1 : a.day > b.day ? 1 : 0));

      if (values.length < 7) return "";

      const recent = values[values.length - 1].value;
      const baselineValues = [];
      for (let i = values.length - 2; i >= 0 && baselineValues.length < 6; i -= 1) {
        baselineValues.push(values[i].value);
      }
      if (baselineValues.length < 6) return "";

      const baseline =
        baselineValues.reduce((sum, val) => sum + val, 0) / baselineValues.length;

      if (!Number.isFinite(recent) || !Number.isFinite(baseline)) return "";

      const delta = recent - baseline;
      const absDelta = Math.abs(delta);
      if (absDelta < 2) return "â†’";
      if (delta >= 10) return "â†‘";
      if (delta <= -10) return "â†“";
      if (delta >= 2) return "â†—";
      if (delta <= -2) return "â†˜";
      return "â†’";
    }

    function summarizeMerchantHealth(merchantRow = {}) {
      let statusInfo = classifyStatus(merchantRow.tags || []);
      if (statusInfo.css === "unknown") {
        const meta = getMerchantStatusMeta(merchantRow.merchant || merchantRow.name || "");
        if (meta) statusInfo = meta;
      }
      const statusShort =
        statusInfo.label === "Up"
          ? "U"
          : statusInfo.label === "Down"
          ? "D"
          : statusInfo.label === "Limited"
          ? "L"
          : "?";
      const total = Number(merchantRow.total || 0);
      const billable = Number(merchantRow.billable || 0);
      const siteFailures = Number(merchantRow.siteFailures ?? merchantRow.siteFail ?? 0);
      const userFlowIssues = Number(merchantRow.userFlowIssues || 0);
      const healthDenom = billable + siteFailures;
      const healthPct = healthDenom > 0 ? (billable / healthDenom) * 100 : null;
      const uxPct = total > 0 ? (userFlowIssues / total) * 100 : null;

      const perDay = Array.isArray(merchantRow.days) ? merchantRow.days : [];
      const dailyMap = {};
      perDay.forEach((d) => {
        const dayKey = d.day || d.date;
        if (!dayKey) return;
        dailyMap[dayKey] = {
          total: Number(d.total || 0),
          billable: Number(d.billable || 0),
          siteFailures: Number(d.siteFailures ?? d.siteFail ?? 0),
          userFlowIssues: Number(d.userFlowIssues || 0),
        };
      });

      const healthArrow = computeTrendArrow(dailyMap, (dayStats) => {
        const denom = Number(dayStats.billable || 0) + Number(dayStats.siteFailures || 0);
        if (denom === 0) return null;
        return (Number(dayStats.billable || 0) / denom) * 100;
      });

      const uxArrow = computeTrendArrow(dailyMap, (dayStats) => {
        const tot = Number(dayStats.total || 0);
        if (tot === 0) return null;
        return (Number(dayStats.userFlowIssues || 0) / tot) * 100;
      });

      return {
        merchant: merchantRow.merchant || merchantRow.name || "unknown",
        total,
        billable,
        siteFailures,
        userFlowIssues,
        healthPct,
        uxPct,
        healthArrow,
        uxArrow,
        severeUx: uxPct !== null && uxPct >= 80,
        statusCss: statusInfo.css,
        statusLabel: statusInfo.label,
        statusShort,
      };
    }

    function renderHealthSummary(merchants = []) {
      if (!healthSummaryEl) return;
      if (!Array.isArray(merchants) || merchants.length === 0) {
        healthSummaryEl.innerHTML = '<div class="muted tiny">No data.</div>';
        return;
      }
      const MIN_ATTEMPTS = 5;
      const summaries = merchants
        .filter((m) => !m.merchant || !m.merchant.toLowerCase().includes("synthetic"))
        .map((m) => summarizeMerchantHealth(m));
      summaries.sort((a, b) => (b.total || 0) - (a.total || 0));
      const main = summaries.filter((s) => (s.total || 0) >= MIN_ATTEMPTS);
      const lowVol = summaries.length - main.length;
      const linesHtml = main
        .map((s) => {
          const name = s.merchant.padEnd(22, " ");
          let healthEmoji = s.healthPct === null ? "âšªï¸" : s.healthPct >= 80 ? "ðŸŸ¢" : s.healthPct >= 50 ? "ðŸŸ " : "ðŸ”´";
          if (s.severeUx && healthEmoji === "ðŸŸ¢") healthEmoji = "ðŸ”´";
          const uxEmoji = s.uxPct === null ? "âšªï¸" : s.uxPct < 25 ? "ðŸŸ¢" : s.uxPct < 50 ? "ðŸŸ¡" : "ðŸ”´";
          const warningIcon = s.severeUx ? "âš ï¸" : "";
          const billableText = (s.billable || 0).toString().padEnd(4);
          const totalText = (s.total || 0).toString().padEnd(4);
          const billablePct = s.total > 0 ? ((s.billable / s.total) * 100).toFixed(1).padStart(6) + "%" : "   â€”  ";
          const healthText = formatPct(s.healthPct).padStart(7);
          const uxText = formatPct(s.uxPct).padStart(7);
          const healthArrow = s.healthArrow || " ";
          const uxArrow = s.uxArrow || " ";
          const warnSpan = `<span style="display:inline-block; min-width:18px; text-align:center;">${warningIcon}</span>`;
          const statusPill = `<span class="status-pill ${s.statusCss || "unknown"}" title="${s.statusLabel || "Unknown"}">${s.statusShort || "?"}</span>`;
          return `<div class="mono" style="white-space:pre;">${statusPill} ${name} | billable ${billableText} | total ${totalText} (${billablePct}) | health ${healthEmoji} ${healthArrow} ${healthText} | UX ${warnSpan}${uxEmoji} ${uxArrow} ${uxText}</div>`;
        })
        .join("");
      healthSummaryEl.innerHTML = `
        <div style="font-size:12px; line-height:1.4;">${linesHtml}</div>
        <div class="muted tiny" style="margin-top:6px;">
          Sorted by total attempts; rows with &lt; ${MIN_ATTEMPTS} attempts (${lowVol} merchants) omitted. Arrows compare the latest day vs prior 6-day average.
        </div>
      `;
    }

    function showTooltip(ev, payload) {
      if (!tip || !payload) return;
      tip.innerHTML = buildTooltipHtml(payload);
      tip.hidden = false;
      positionTooltip(ev);
    }

    function positionTooltip(ev) {
      if (!tip || tip.hidden || !ev) return;
      const pad = 14;
      tip.style.left = `${ev.pageX + pad}px`;
      tip.style.top = `${ev.pageY + pad}px`;
    }

    function hideTooltip() {
      if (!tip) return;
      tip.hidden = true;
    }

    // Boot
    (async () => {
      await loadMerchantStatuses();
      await fetchRegistry();
      await loadAndRender(initStart, initEnd);
      const mappingAvailable = (currentData?.merchants || []).some(
        (m) => Array.isArray(m.fi_list) && m.fi_list.length
      );
      window.__DISABLE_FI_FILTERS_HEATMAP = !mappingAvailable;
      (function ensureFilters(pageId){
        const run = () => {
          if (window.initFilters) {
            console.log("[filters] invoking initFilters for", pageId);
            window.initFilters(pageId);
          }
        };
        if (window.initFilters) return run();
        const candidates = [
          "/assets/js/filters.js?v=shared-fallback",
          "/public/assets/js/filters.js?v=shared-fallback",
        ];
        const loadNext = (idx) => {
          if (idx >= candidates.length) {
            console.error("[filters] unable to load shared filters script");
            return;
          }
          const s = document.createElement("script");
          s.src = candidates[idx] + "&ts=" + Date.now();
          s.onload = () => {
            console.log("[filters] loaded fallback script", candidates[idx]);
            run();
          };
          s.onerror = () => {
            console.warn("[filters] failed to load", candidates[idx]);
            loadNext(idx + 1);
          };
          document.head.appendChild(s);
        };
        loadNext(0);
      })("heatmap");
    })();
  </script>
</body>
</html>
