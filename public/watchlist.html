<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Strivve â€¢ FI Alerts Watchlist</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="./sis-shared.css?v=navfix" />
  <link rel="stylesheet" href="./assets/css/sis.css">
  <script src="./assets/js/passcode-gate.js"></script>
  <script defer src="./assets/js/sis.js"></script>
  <script src="./assets/js/config.js"></script>
  <script defer src="./assets/js/nav.js"></script>
  <script type="module" defer src="./assets/js/data-cache.js?v=3"></script>
  <script>
    document.addEventListener("DOMContentLoaded", function(){
      if (window.renderHeaderNav && !window.__sisHeaderNav_watchlist) {
        window.__sisHeaderNav_watchlist = true;
        window.renderHeaderNav({
          currentId: "watchlist",
          title: "Alerts & Watchlist",
          subtitle: "Anomalies, traffic spikes/drops, and reliability changes."
        });
      }
    });
  </script>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: "Inter", "Segoe UI", ui-sans-serif, system-ui, -apple-system, Roboto, "Helvetica Neue", Arial, sans-serif;
      background: radial-gradient(circle at top, rgba(37,99,235,.08), transparent 42%) var(--bg);
      color: var(--ink);
    }
    [data-theme="dark"] body {
      background: radial-gradient(circle at top, rgba(90,115,255,.18), transparent 42%) var(--bg);
      color: var(--ink);
    }
    .sis-panel {
      background: var(--panel);
    }
    .watchlist-grid {
      display: flex;
      flex-direction: column;
      gap: 24px;
      max-width: 1100px;
      margin: 0 auto;
      width: 100%;
    }
    .card {
      border: 1px solid var(--border, #d7deea);
      border-radius: 16px;
      padding: 22px;
      background: var(--card, #fff);
      display: flex;
      flex-direction: column;
      gap: 18px;
      box-shadow: var(--shadow, 0 10px 30px rgba(0,0,0,0.06));
    }
    .card h2 {
      margin: 0;
      font-size: 20px;
      letter-spacing: 0.2px;
      color: var(--ink);
    }
    .card .subhead {
      margin: -6px 0 4px 0;
      color: var(--muted);
      font-size: 15px;
      line-height: 1.5;
    }
    .card-body {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    /* Funnel-style tables (copied) */
    .watch-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 8px;
      font-size: 0.92rem;
    }
    .watch-table th,
    .watch-table td {
      border: 1px solid var(--table-border, #d7deea);
      text-align: left;
    }
    .watch-table th {
      background: var(--table-header, #e2e8f0);
      position: sticky;
      top: 0;
      z-index: 1;
      padding: 8px 8px;
      font-size: 0.92rem;
    }
    [data-theme="dark"] .watch-table th {
      background: rgba(255,255,255,0.05);
      color: var(--ink, #e5edff);
    }
    [data-theme="dark"] .watch-table td {
      color: var(--ink, #e5edff);
      border-color: rgba(255,255,255,0.12);
    }
    .watch-table tbody td {
      padding: 10px 8px;
      font-size: 0.92rem;
    }
    .watch-table td.num {
      text-align: right;
      font-variant-numeric: tabular-nums;
      white-space: nowrap;
    }
    .watch-table th:first-child,
    .watch-table td:first-child { width: 26%; white-space: nowrap; }
    .watch-table th:nth-child(2),
    .watch-table td:nth-child(2),
    .watch-table th:nth-child(3),
    .watch-table td:nth-child(3),
    .watch-table th:nth-child(4),
    .watch-table td:nth-child(4),
    .watch-table th:nth-child(5),
    .watch-table td:nth-child(5),
    .watch-table th:nth-child(6),
    .watch-table td:nth-child(6) { width: 13%; text-align: right; }
    .delta-bad { color: #b91c1c; }
    .delta-good { color: #15803d; }
    .status-pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 800;
      letter-spacing: 0.4px;
      text-transform: uppercase;
      border: 1px solid transparent;
      margin-left: 6px;
      white-space: nowrap;
      background: linear-gradient(135deg, rgba(255,255,255,0.7), rgba(255,255,255,0.2));
      box-shadow: 0 4px 12px rgba(0,0,0,0.08);
      cursor: default; /* keep arrow cursor across the whole badge */
    }
    .status-pill::before {
      content: "";
      width: 10px;
      height: 10px;
      border-radius: 50%;
      display: inline-block;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.08);
    }
    .status-pill.up {
      color: #0f5132;
      border-color: rgba(34, 197, 94, 0.4);
      background: linear-gradient(135deg, rgba(16, 185, 129, 0.16), rgba(16, 185, 129, 0.04));
    }
    .status-pill.up::before { background: #22c55e; }
    .status-pill.down {
      color: #7f1d1d;
      border-color: rgba(220, 38, 38, 0.45);
      background: linear-gradient(135deg, rgba(248, 113, 113, 0.2), rgba(248, 113, 113, 0.06));
    }
    .status-pill.down::before { background: #ef4444; }
    .status-pill.limited {
      color: #854d0e;
      border-color: rgba(234, 179, 8, 0.5);
      background: linear-gradient(135deg, rgba(234, 179, 8, 0.2), rgba(234, 179, 8, 0.06));
    }
    .status-pill.limited::before { background: #f59e0b; }
    .status-pill.unknown {
      color: #334155;
      border-color: rgba(100, 116, 139, 0.5);
      background: linear-gradient(135deg, rgba(148, 163, 184, 0.2), rgba(148, 163, 184, 0.06));
    }
    .status-pill.unknown::before { background: #94a3b8; }
    .watchlist-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(520px, 1fr));
      max-width: 1200px;
      margin: 12px auto 0;
      gap: 14px;
    }
    .watch-card {
      padding: 14px;
      overflow: auto;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 14px;
      box-shadow: 0 16px 40px rgba(15, 23, 42, 0.08);
    }
    .merchant-name,
    .fi-name {
      cursor: help;
      text-decoration: underline dotted rgba(15, 23, 42, 0.4);
      text-decoration-thickness: 1px;
      text-underline-offset: 3px;
    }
    [data-theme="dark"] .merchant-name,
    [data-theme="dark"] .fi-name {
      text-decoration-color: rgba(229, 237, 255, 0.5);
    }
    [data-theme="dark"] .watch-card {
      box-shadow: 0 20px 50px rgba(0,0,0,0.35);
    }
    .watch-card h3 {
      font-size: 0.9rem;
      margin-bottom: 6px;
      color: var(--text, #0f172a);
    }
    .loading-banner {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      border: 1px solid #f59e0b;
      border-radius: 12px;
      background: rgba(245, 158, 11, 0.12);
      box-shadow: 0 10px 24px rgba(15, 23, 42, 0.08);
      color: #92400e;
      font-size: 13px;
      margin-bottom: 10px;
    }
    .loading-banner .spinner {
      width: 16px;
      height: 16px;
      border: 2px solid #f59e0b;
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
      flex-shrink: 0;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <div id="sis-header"></div>
  <div class="sis-content">
    <main class="sis-main">
      <section class="sis-panel">
      <div id="pageLoader" class="loading-banner" hidden>
        <div class="spinner" aria-hidden="true"></div>
        <div class="loading-text">Loading alertsâ€¦</div>
      </div>
      <div class="muted" id="status"></div>
      <div style="margin-top:12px;">
        <div class="muted tiny" id="windowLabel"></div>
      </div>
      <div class="watchlist-grid" id="cards" style="margin-top:12px;"></div>
    </section>
    </main>
  </div>

  <script>
    const dayMs = 86400000;
    const urlParams = new URLSearchParams(window.location.search);
    console.log('ðŸ” Watchlist URL params:', Object.fromEntries(urlParams.entries()));
    const isoYesterday = () => {
      const d = new Date();
      d.setDate(d.getDate() - 1);
      d.setHours(0,0,0,0);
      return d.toISOString().slice(0,10);
    };
    const isoDaysAgo = (n, refIso) => {
      const [y,m,dd] = refIso.split("-").map((v)=>parseInt(v,10));
      const d = new Date(Date.UTC(y,(m||1)-1,dd||1));
      d.setUTCDate(d.getUTCDate()-n);
      return d.toISOString().slice(0,10);
    };
    async function fetchDaily(date) {
      // Check cache first (use getAsync for IndexedDB support)
      if (window.DataCache) {
        const cached = await window.DataCache.getAsync(`daily_${date}`);
        if (cached) {
          console.log(`âœ“ Loaded daily_${date} from cache`);
          return cached;
        }
      }

      try {
        console.log(`â†’ Fetching daily_${date} from server`);
        const res = await fetch(`/daily?date=${date}`);
        if (!res.ok) return null;
        const data = await res.json();
        const result = data?.error ? null : data;

        // Store in cache if valid
        if (result && window.DataCache) {
          await window.DataCache.set(`daily_${date}`, result);
        }

        return result;
      } catch {
        return null;
      }
    }

    const statusEl = document.getElementById("status");
    const loaderEl = document.getElementById("pageLoader");
    const loaderTextEl = loaderEl?.querySelector(".loading-text");
    const setLoaderText = (msg) => {
      if (loaderTextEl && msg) loaderTextEl.textContent = msg;
    };
    function startLoading(message = "Loading alertsâ€¦") {
      if (!loaderEl) return;
      loaderEl.hidden = false;
      loaderEl.style.display = "flex";
      setLoaderText(message);
    }
    function stopLoading() {
      if (!loaderEl) return;
      loaderEl.hidden = true;
      loaderEl.style.display = "none";
      setLoaderText("");
    }
    const cardsEl = document.getElementById("cards");
    let fiInstanceDefaults = new Map();
    let merchantStatusMap = new Map();
    const escapeAttr = (val) => (val ?? "").toString().replace(/"/g, "&quot;");

    async function loadFiRegistryDefaults() {
      try {
        const res = await fetch("/fi-registry");
        if (!res.ok) return;
        const json = await res.json();
        const map = new Map();
        Object.values(json || {}).forEach((entry) => {
          if (!entry || typeof entry !== "object") return;
          const fiKey = (entry.fi_lookup_key || entry.fi_name || "").toString().toLowerCase();
          if (!fiKey) return;
          const inst = entry.instance || "";
          if (!map.has(fiKey)) map.set(fiKey, new Set());
          if (inst) map.get(fiKey).add(inst.toString());
        });
        fiInstanceDefaults = map;
      } catch {
        // ignore registry load failures
      }
    }

    function aggregateMerchantsToFis(merchants = [], days = []) {
      const dayIndex = new Map(days.map((d, idx) => [d, idx]));
      const makeStore = () => ({
        total: 0,
        billable: 0,
        siteFailures: 0,
        userFlowIssues: 0,
        days: Array.from({ length: days.length }, (_, i) => ({
          day: days[i],
          total: 0,
          billable: 0,
          siteFailures: 0,
          userFlowIssues: 0,
        })),
      });
      const fis = new Map();
      merchants.forEach((m) => {
        const fiList = Array.isArray(m.fi_list) && m.fi_list.length ? m.fi_list : ["unknown_fi"];
        const perDay = Array.isArray(m.days) ? m.days : [];
        fiList.forEach((fiName) => {
          const key = `${fiName}:unknown`;
          if (!fis.has(key)) {
            fis.set(key, { ...makeStore(), fiName, instance: "unknown" });
          }
          const store = fis.get(key);
          perDay.forEach((d) => {
            const idx = dayIndex.has(d.day) ? dayIndex.get(d.day) : -1;
            const tot = Number(d.total || 0);
            const bill = Number(d.billable || 0);
            const sf = Number(d.siteFailures || d.siteFail || 0);
            const ux = Number(d.userFlowIssues || 0);
            store.total += tot;
            store.billable += bill;
            store.siteFailures += sf;
            store.userFlowIssues += ux;
            if (idx >= 0) {
              const entry = store.days[idx];
              entry.total += tot;
              entry.billable += bill;
              entry.siteFailures += sf;
              entry.userFlowIssues += ux;
            }
          });
        });
      });
      return Array.from(fis.entries()).map(([fi, stats]) => ({
        fi,
        fiName: stats.fiName,
        instance: stats.instance,
        total: stats.total,
        billable: stats.billable,
        siteFailures: stats.siteFailures,
        userFlowIssues: stats.userFlowIssues,
        days: stats.days,
      }));
    }

    async function aggregateDailyFiTotals(lastDays = [], prevDays = []) {
      const combined = Array.from(new Set([...lastDays, ...prevDays]));
      if (!combined.length) return [];
      const fiMap = new Map();
      for (let i = 0; i < combined.length; i++) {
        const day = combined[i];
        setLoaderText(`Loading FI daily dataâ€¦ ${i + 1}/${combined.length}`);
        const daily = await fetchDaily(day);
        if (!daily || !daily.fi) continue;
        const fiInstances = daily.fi_instances || {};
        for (const [fiName, entry] of Object.entries(daily.fi)) {
          const instArr = Array.isArray(fiInstances[fiName]) ? fiInstances[fiName] : [];
          const inst = instArr[0] || "unknown";
          const key = `${fiName}:${inst}`;
          if (!fiMap.has(key)) {
            fiMap.set(key, {
              fiName,
              instance: inst,
              days: [],
            });
          }
          const store = fiMap.get(key);
          const sessions = entry.sessions || {};
          const total = Number(sessions.total || 0);
          store.days.push({ day, total, billable: total, siteFailures: 0, userFlowIssues: 0 });
        }
      }
      return Array.from(fiMap.values());
    }

    function classifyStatus(tags = []) {
      const lower = tags.map((t) => t.toString().toLowerCase());
      if (lower.some((t) => t.includes("down") || t.includes("disabled"))) {
        return { label: "Down", css: "down" };
      }
      if (lower.some((t) => t.includes("limited") || t.includes("beta") || t.includes("degraded"))) {
        return { label: "Limited", css: "limited" };
      }
      if (lower.some((t) => t.includes("unrestricted") || t === "prod")) {
        return { label: "Up", css: "up" };
      }
      return { label: "Unknown", css: "unknown" };
    }

    async function loadMerchantStatuses() {
      try {
        const res = await fetch("/merchant-sites", { cache: "no-store" });
        if (!res.ok) return;
        const data = await res.json();
        const map = new Map();
        const sites = Array.isArray(data?.sites) ? data.sites : [];
        sites.forEach((s) => {
          const rawHost = (s.host || s.hostname || "").toString();
          const host = rawHost.toLowerCase();
          if (!host) return;
          const tags = Array.isArray(s.tags) ? s.tags : [];
          const status = classifyStatus(tags);
          const name = s.name || s.display_name || "";
          map.set(host, { ...status, tags, name: name || host, host: rawHost || host });
        });
        merchantStatusMap = map;
      } catch {
        // silently ignore
      }
    }

    function hasBadTag(tags = [], key) {
      const lower = (tags || []).map((t) => t && t.toString().toLowerCase());
      return lower.some((t) => key && t.includes(key));
    }

    function isSynthetic(merchantName) {
      const host = (merchantName || "").toString().toLowerCase();
      const meta = merchantStatusMap.get(host);
      if (meta && Array.isArray(meta.tags)) {
        if (meta.tags.some((t) => t && t.toString().toLowerCase().includes("synthetic"))) {
          return true;
        }
      }
      return false;
    }

    function isTestAutomation(merchantName) {
      const host = (merchantName || "").toString().toLowerCase();
      const meta = merchantStatusMap.get(host);
      if (meta && Array.isArray(meta.tags)) {
        if (meta.tags.some((t) => t && t.toString().toLowerCase().includes("test-automation"))) {
          return true;
        }
      }
      return false;
    }

    function renderMerchantCell(name) {
      const host = (name || "").toString().toLowerCase();
      const meta = merchantStatusMap.get(host);
      if (!meta) {
        const safeName = name || "unknown";
        return `${safeName}${statusBadge(name)}`;
      }
      const displayName = meta.name || name || "unknown";
      const titleHost = meta.host || host;
      const titleAttr = titleHost ? ` title="${escapeAttr(titleHost)}"` : "";
      return `<span class="merchant-name"${titleAttr}>${displayName}</span>${statusBadge(name)}`;
    }

    function renderFiCell(row = {}) {
      const label = row.fiName || row.name || "unknown";
      const instance = row.instance || "";
      const titleAttr = instance ? ` title="${escapeAttr(instance)}"` : "";
      return `<span class="fi-name"${titleAttr}>${label}</span>`;
    }

    function aggregateSlicesToMerchants(slices = [], days = []) {
      const dayIndex = new Map(days.map((d, idx) => [d, idx]));
      const makeStore = () => ({
        total: 0,
        billable: 0,
        siteFailures: 0,
        userFlowIssues: 0,
        days: Array.from({ length: days.length }, (_, i) => ({
          day: days[i],
          total: 0,
          billable: 0,
          siteFailures: 0,
          userFlowIssues: 0,
        })),
      });
      const merchants = new Map();
      slices.forEach((s) => {
        if (!s || !s.merchant) return;
        if (!merchants.has(s.merchant)) {
          merchants.set(s.merchant, makeStore());
        }
        const store = merchants.get(s.merchant);
        const idx = dayIndex.has(s.day) ? dayIndex.get(s.day) : -1;
        const tot = Number(s.total || 0);
        const bill = Number(s.billable || 0);
        const sf = Number(s.siteFailures || 0);
        const ux = Number(s.userFlowIssues || 0);
        store.total += tot;
        store.billable += bill;
        store.siteFailures += sf;
        store.userFlowIssues += ux;
        if (idx >= 0) {
          const entry = store.days[idx];
          entry.total += tot;
          entry.billable += bill;
          entry.siteFailures += sf;
          entry.userFlowIssues += ux;
        }
      });
      return Array.from(merchants.entries()).map(([merchant, stats]) => ({
        merchant,
        total: stats.total,
        billable: stats.billable,
        siteFailures: stats.siteFailures,
        userFlowIssues: stats.userFlowIssues,
        days: stats.days,
      }));
    }

    function aggregateSlicesToFis(slices = [], days = [], fiInstanceDefaults = new Map()) {
      const dayIndex = new Map(days.map((d, idx) => [d, idx]));
      const makeStore = () => ({
        total: 0,
        billable: 0,
        siteFailures: 0,
        userFlowIssues: 0,
        days: Array.from({ length: days.length }, (_, i) => ({
          day: days[i],
          total: 0,
          billable: 0,
          siteFailures: 0,
          userFlowIssues: 0,
        })),
      });
      const fis = new Map();
      slices.forEach((s) => {
        if (!s || !s.fi) return;
        const fiNorm = (s.fi || "unknown_fi").toString().toLowerCase();
        let inst = s.instance || s.instance_name || s.org_name || "";
        if (!inst) {
          const defInst = fiInstanceDefaults.get(fiNorm);
          if (defInst && defInst.size === 1) {
            inst = Array.from(defInst)[0];
          }
        }
        const fiKey = `${s.fi || "unknown_fi"}:${inst || "unknown"}`;
        if (!fis.has(fiKey)) {
          fis.set(fiKey, { ...makeStore(), fiName: s.fi || "unknown_fi", instance: inst || "unknown" });
        }
        const store = fis.get(fiKey);
        const idx = dayIndex.has(s.day) ? dayIndex.get(s.day) : -1;
        const tot = Number(s.total || 0);
        const bill = Number(s.billable || 0);
        const sf = Number(s.siteFailures || 0);
        const ux = Number(s.userFlowIssues || 0);
        store.total += tot;
        store.billable += bill;
        store.siteFailures += sf;
        store.userFlowIssues += ux;
        if (idx >= 0) {
          const entry = store.days[idx];
          entry.total += tot;
          entry.billable += bill;
          entry.siteFailures += sf;
          entry.userFlowIssues += ux;
        }
      });
      return Array.from(fis.entries()).map(([fi, stats]) => ({
        fi,
        fiName: stats.fiName || fi.split(":")[0],
        instance: stats.instance || fi.split(":")[1] || "unknown",
        total: stats.total,
        billable: stats.billable,
        siteFailures: stats.siteFailures,
        userFlowIssues: stats.userFlowIssues,
        days: stats.days,
      }));
    }

    function summarizeMerchant(merchant, daysArr, endDateOverride = null) {
      const dayIndex = new Map(daysArr.map((d,i)=>[d,i]));
      const daily = (merchant.days || []).map((d)=>({ day:d.day||d.date, total:Number(d.total||0), billable:Number(d.billable||0), siteFailures:Number(d.siteFailures||d.siteFail||0), userFlowIssues:Number(d.userFlowIssues||0) }));
      const byDay = new Map();
      daily.forEach((d)=>{ if(!d.day) return; byDay.set(d.day,d); });
      const effectiveDays = endDateOverride
        ? daysArr.filter((d) => d <= endDateOverride)
        : daysArr;
      const last7 = effectiveDays.slice(-7);
      const prev7 = effectiveDays.slice(-14,-7);
      const last90 = effectiveDays.slice(-90);
      const sumBlock = (block) => block.reduce((acc,day)=>{
        const v = byDay.get(day) || {total:0,billable:0,siteFailures:0,userFlowIssues:0};
        acc.total += v.total; acc.billable += v.billable; acc.siteFailures += v.siteFailures; acc.userFlowIssues += v.userFlowIssues; return acc;
      },{total:0,billable:0,siteFailures:0,userFlowIssues:0});
      const last = sumBlock(last7);
      const prev = sumBlock(prev7);
      const baseline90 = sumBlock(last90);
      const health = (()=>{ const denom = last.billable+last.siteFailures; return denom>0 ? (last.billable/denom)*100 : null;})();
      const healthPrev = (()=>{ const denom = prev.billable+prev.siteFailures; return denom>0 ? (prev.billable/denom)*100 : null;})();
      const ux = last.total>0 ? (last.userFlowIssues/last.total)*100 : null;
      const uxPrev = prev.total>0 ? (prev.userFlowIssues/prev.total)*100 : null;
      const siteFailShare = (()=>{ const denom = last.billable+last.siteFailures; return denom>0 ? (last.siteFailures/denom)*100 : null;})();
      const siteFailPrev = (()=>{ const denom = prev.billable+prev.siteFailures; return denom>0 ? (prev.siteFailures/denom)*100 : null;})();
      const deltaPct = (cur, prevVal) => {
        if (!Number.isFinite(cur) || !Number.isFinite(prevVal)) return null;
        if (prevVal === 0) return null;
        return ((cur - prevVal) / prevVal) * 100;
      };
      return {
        name: merchant.merchant || merchant.name || "unknown",
        total: last.total,
        prevTotal: prev.total,
        health,
        healthPrev,
        ux,
        uxPrev,
        avgWeekly: last90.length ? (baseline90.total / (last90.length || 1)) * 7 : null,
        totalDelta: deltaPct(last.total, prev.total),
        healthDelta: deltaPct(health, healthPrev),
        uxDelta: deltaPct(ux, uxPrev),
        siteFailShare,
        siteFailPrev,
        siteFailDelta: deltaPct(siteFailShare, siteFailPrev),
        missingDays: Math.max(0, daysArr.length - byDay.size),
      };
    }

    function summarizeFi(fiRow, daysArr, endDateOverride = null) {
      const daily = (fiRow.days || []).map((d)=>({ day:d.day||d.date, total:Number(d.total||0), billable:Number(d.billable||0), siteFailures:Number(d.siteFailures||d.siteFail||0), userFlowIssues:Number(d.userFlowIssues||0) }));
      const byDay = new Map();
      daily.forEach((d)=>{ if(!d.day) return; byDay.set(d.day,d); });
      const effectiveDays = endDateOverride
        ? daysArr.filter((d) => d <= endDateOverride)
        : daysArr;
      const last7 = effectiveDays.slice(-7);
      const prev7 = effectiveDays.slice(-14,-7);
      const last90 = effectiveDays.slice(-90);
      const sumBlock = (block) => block.reduce((acc,day)=>{
        const v = byDay.get(day) || {total:0,billable:0,siteFailures:0,userFlowIssues:0};
        acc.total += v.total; acc.billable += v.billable; acc.siteFailures += v.siteFailures; acc.userFlowIssues += v.userFlowIssues; return acc;
      },{total:0,billable:0,siteFailures:0,userFlowIssues:0});
      const last = sumBlock(last7);
      const prev = sumBlock(prev7);
      const baseline90 = sumBlock(last90);
      const health = (()=>{ const denom = last.billable+last.siteFailures; return denom>0 ? (last.billable/denom)*100 : null;})();
      const healthPrev = (()=>{ const denom = prev.billable+prev.siteFailures; return denom>0 ? (prev.billable/denom)*100 : null;})();
      const ux = last.total>0 ? (last.userFlowIssues/last.total)*100 : null;
      const uxPrev = prev.total>0 ? (prev.userFlowIssues/prev.total)*100 : null;
      const siteFailShare = (()=>{ const denom = last.billable+last.siteFailures; return denom>0 ? (last.siteFailures/denom)*100 : null;})();
      const siteFailPrev = (()=>{ const denom = prev.billable+prev.siteFailures; return denom>0 ? (prev.siteFailures/denom)*100 : null;})();
      const deltaPct = (cur, prevVal) => {
        if (!Number.isFinite(cur) || !Number.isFinite(prevVal)) return null;
        if (prevVal === 0) return null;
        return ((cur - prevVal) / prevVal) * 100;
      };
      const fiName = fiRow.fiName || fiRow.fi || "unknown_fi";
      const instance = fiRow.instance || "unknown";
      return {
        name: fiName,
        fiName,
        instance,
        total: last.total,
        prevTotal: prev.total,
        avgWeekly: last90.length ? (baseline90.total / (last90.length || 1)) * 7 : null,
        health,
        healthPrev,
        ux,
        uxPrev,
        totalDelta: deltaPct(last.total, prev.total),
        healthDelta: deltaPct(health, healthPrev),
        uxDelta: deltaPct(ux, uxPrev),
        siteFailShare,
        siteFailPrev,
        siteFailDelta: deltaPct(siteFailShare, siteFailPrev),
        missingDays: Math.max(0, daysArr.length - byDay.size),
      };
    }

    function fmtDelta(val) {
      if (!Number.isFinite(val)) return "â€”";
      const sign = val > 0 ? "+" : "";
      return `${sign}${val.toFixed(1)}%`;
    }
    function fmtPctVal(val) {
      if (!Number.isFinite(val)) return "â€”";
      return `${val.toFixed(1)}%`;
    }
    function fmtNum(val) {
      if (!Number.isFinite(val)) return "â€”";
      return val.toLocaleString();
    }
    function fmtAvg(val) {
      if (!Number.isFinite(val)) return "â€”";
      return val.toLocaleString(undefined, { minimumFractionDigits: 1, maximumFractionDigits: 1 });
    }

    function statusBadge(name) {
      if (!name) return "";
      const host = name.toString().toLowerCase();
      const status = merchantStatusMap.get(host);
      if (!status) return "";
      return `<span class="status-pill ${status.css}">${status.label}</span>`;
    }

    function buildCard(title, rows, deltaKey, reverse=false) {
      const lowerTitle = title.toLowerCase();
      const isReliability = deltaKey === "siteFailDelta";
      const isTraffic = lowerTitle.includes("traffic");
      const isFiLevel = lowerTitle.includes("fis");
      const subtitle = (() => {
        if (title.toLowerCase().includes("drops â€¢ merchants")) return "Lowest recent 7-day traffic vs prior week; watch for outages or pullbacks.";
        if (title.toLowerCase().includes("spikes â€¢ merchants")) return "Highest recent 7-day traffic vs prior week; watch capacity and fraud signals.";
        if (title.toLowerCase().includes("reliability drops")) return "Site-fail share increased vs prior 7 days; rising failure rates.";
        if (title.toLowerCase().includes("reliability gains")) return "Site-fail share decreased vs prior 7 days; improving reliability.";
        if (title.toLowerCase().includes("ux spikes")) return "Largest week-over-week jump in UX issues; triage UI/flow problems.";
        if (title.toLowerCase().includes("data gaps")) return "Missing daily data within the window.";
        if (title.startsWith("FI:")) return "Aggregated at FI level using placement slices.";
        return "";
      })();
      const body = rows
        .map((r)=> {
          const nameCell = isFiLevel ? renderFiCell(r) : renderMerchantCell(r.name);
          const deltaClass = r[deltaKey] !== null && ((r[deltaKey] > 0 && !reverse) || (r[deltaKey] < 0 && reverse))
            ? "delta-bad"
            : "delta-good";
          if (isReliability) {
            const reliabClass = r[deltaKey] > 0 ? "delta-bad" : "delta-good";
            return `<tr>
              <td>${nameCell}</td>
              <td class="num">${fmtNum(r.total)}</td>
              <td class="num">${fmtNum(r.prevTotal)}</td>
              <td class="num">${fmtPctVal(r.siteFailShare)}</td>
              <td class="num ${reliabClass}">${fmtDelta(r.siteFailDelta)}</td>
              <td class="num">${fmtDelta(r.healthDelta)}</td>
            </tr>`;
          }
          if (isTraffic) {
            const deltaClassTraffic = Number(r[deltaKey]) < 0 ? "delta-bad" : "delta-good";
            return `<tr>
              <td>${nameCell}</td>
              <td class="num">${fmtNum(r.total)}</td>
              <td class="num">${fmtNum(r.prevTotal)}</td>
              <td class="num ${deltaClassTraffic}">${fmtDelta(r[deltaKey])}</td>
              <td class="num">${fmtAvg(r.avgWeekly)}</td>
            </tr>`;
          }
          return `<tr>
            <td>${nameCell}</td>
            <td class="num">${fmtNum(r.total)}</td>
            <td class="num">${fmtNum(r.prevTotal)}</td>
            <td class="num ${deltaClass}">${fmtDelta(r[deltaKey])}</td>
            <td class="num">${fmtDelta(r.healthDelta)}</td>
            <td class="num">${fmtDelta(r.uxDelta)}</td>
          </tr>`;
        })
        .join("");
        return `
        <div class="card">
          <h2>${title}</h2>
          ${subtitle ? `<div class="subhead">${subtitle}</div>` : ""}
          <div class="card-body">
            <div class="table-scroll">
              <table class="watch-table">
                <thead>
                  ${isReliability
                    ? `<tr><th>${isFiLevel ? "Financial Institution" : "Merchant"}</th><th class="num">Last 7d</th><th class="num">Prev 7d</th><th class="num">Site-fail%</th><th class="num">Site-fail Î”</th><th class="num">Health Î”</th></tr>`
                    : isTraffic
                    ? `<tr><th>${isFiLevel ? "Financial Institution" : "Merchant"}</th><th class="num">Last 7d</th><th class="num">Prev 7d</th><th class="num">Traffic Î”</th><th class="num">Avg/wk (90d)</th></tr>`
                    : `<tr><th>${isFiLevel ? "Financial Institution" : "Merchant"}</th><th class="num">Last 7d</th><th class="num">Prev 7d</th><th class="num">Traffic Î”</th><th class="num">Health Î”</th><th class="num">UX Î”</th></tr>`}
                </thead>
                <tbody>${body}</tbody>
              </table>
            </div>
          </div>
        </div>
      `;
    }

    const WATCHLIST_DATES_KEY = 'watchlist_last_dates';

    async function loadWatchlist() {
      try {
        // Determine dates first (before showing loading spinner)
        let end, start;
        if (urlParams.has("start") && urlParams.has("end")) {
          // Use URL params if present
          start = urlParams.get("start");
          end = urlParams.get("end");
          console.log('ðŸ“… Using dates from URL:', { start, end });
        } else {
          // Try to load last used dates from localStorage
          try {
            const stored = localStorage.getItem(WATCHLIST_DATES_KEY);
            if (stored) {
              const parsed = JSON.parse(stored);
              start = parsed.start;
              end = parsed.end;
              console.log('ðŸ“… Using dates from localStorage:', { start, end });
            } else {
              throw new Error('No stored dates');
            }
          } catch {
            // Calculate default dates
            end = isoYesterday();
            start = isoDaysAgo(29, end);
            console.log('ðŸ“… No saved dates, calculating default dates:', { start, end });
          }

          // Persist to URL for sharing/bookmarking
          const u = new URL(location.href);
          u.searchParams.set("start", start);
          u.searchParams.set("end", end);
          history.replaceState(null, "", u);
          console.log('ðŸ“Œ Persisted dates to URL:', { start, end, url: u.toString() });
        }

        // Save dates to localStorage for next visit
        try {
          localStorage.setItem(WATCHLIST_DATES_KEY, JSON.stringify({ start, end }));
        } catch (err) {
          console.warn('Failed to save dates to localStorage:', err);
        }

        // Check cache FIRST before showing loading spinner
        const bulkCacheKey = `watchlist_processed_${start}_${end}`;
        console.log(`ðŸ” Checking watchlist cache with key: "${bulkCacheKey}"`);
        if (window.DataCache) {
          const cached = await window.DataCache.getAsync(bulkCacheKey);
          if (cached && cached.cards) {
            console.log(`âœ“ Loaded watchlist from cache (${start} to ${end}) - instant load!`);
            renderAllCards(cached.cards, cached.windowLabel);
            return;
          }
          console.log(`â†’ Watchlist cache miss for key "${bulkCacheKey}", loading from server...`);
        }

        // Cache miss - show loading spinner and fetch data
        startLoading("Loading alertsâ€¦");
        await loadFiRegistryDefaults();
        await loadMerchantStatuses();
        statusEl.textContent = `Loading ${start} â†’ ${end}â€¦`;
        const res = await fetch(`/merchant-heatmap?start=${start}&end=${end}`);
        if (!res.ok) {
          statusEl.textContent = `Failed to load data (${res.status})`;
          return;
        }
        const data = await res.json();
        const days = Array.isArray(data.days) ? data.days : [];
        let merchants = Array.isArray(data.merchants) ? data.merchants : [];
        let slices = Array.isArray(data.slices) ? data.slices : [];
        if ((!merchants || merchants.length === 0) && Array.isArray(data.slices)) {
          merchants = aggregateSlicesToMerchants(data.slices, days);
        }
        if (!slices.length && Array.isArray(data.merchants)) {
          // no slices in payload; derive minimal slices from merchants if present
          slices = (data.merchants || []).flatMap((m) => {
            const dArr = Array.isArray(m.days) ? m.days : [];
            return dArr.map((d) => ({
              day: d.day || d.date,
              fi: "unknown_fi",
              total: Number(d.total || 0),
              billable: Number(d.billable || 0),
              siteFailures: Number(d.siteFailures || d.siteFail || 0),
              userFlowIssues: Number(d.userFlowIssues || 0),
            }));
          });
        }
        const last7 = days.slice(-7);
        const prev7 = days.slice(-14, -7);
        const totalMerchants = merchants.length;
        let processed = 0;
        const summaries = [];
        for (const m of merchants) {
          processed += 1;
          if (processed === 1 || processed % 200 === 0 || processed === totalMerchants) {
            setLoaderText(`Processing merchantsâ€¦ ${processed}/${totalMerchants}`);
          }
          if (hasBadTag(m.tags, "synthetic")) continue;
          if (hasBadTag(m.tags, "test-automation")) continue;
          const summed = summarizeMerchant(m, days, end);
          if (!(summed.total > 0 || summed.prevTotal > 0)) continue;
          if (isSynthetic(summed.name) || isTestAutomation(summed.name)) continue;
          summaries.push(summed);
        }
        let fiSummaries = aggregateSlicesToFis(slices, days, fiInstanceDefaults)
          .filter((fi)=> {
            const name = (fi.fiName || fi.fi || "").toString().toLowerCase();
            const inst = (fi.instance || "").toString().toLowerCase();
            if (name === "default") return false;
            if (name.includes("test-automation")) return false;
            if (inst.includes("customer-dev")) return false;
            return true;
          })
          .map((fi)=>summarizeFi(fi, days, end))
          .filter((f)=>f.total>0 || f.prevTotal>0);
        if (!fiSummaries.length) {
          fiSummaries = aggregateMerchantsToFis(merchants, days)
            .map((fi)=>summarizeFi(fi, days, end))
            .filter((f)=>f.total>0 || f.prevTotal>0);
        }
        if (!fiSummaries.length) {
          const last7 = days.slice(-7);
          const prev7 = days.slice(-14, -7);
          const dailyFi = await aggregateDailyFiTotals(last7, prev7);
          const derivedDays =
            days.length > 0
              ? days
              : Array.from(
                  new Set(
                    dailyFi.flatMap((fi) =>
                      Array.isArray(fi.days) ? fi.days.map((d) => d.day).filter(Boolean) : []
                    )
                  )
                ).sort();
          fiSummaries = dailyFi
            .map((fi)=>summarizeFi(fi, derivedDays))
            .filter((f)=>f.total>0 || f.prevTotal>0);
        }
        setLoaderText("Building watchlistâ€¦");
        const byTrafficDrop = [...summaries]
          .filter((s)=>Number.isFinite(s.totalDelta) && s.totalDelta < 0) // drop only, ignore 0%
          .sort((a,b)=> (a.total || 0) - (b.total || 0)) // lowest recent traffic first
          .slice(0,10);
        const byTrafficRise = [...summaries]
          .filter((s)=>Number.isFinite(s.totalDelta) && s.totalDelta > 0) // rise only, ignore 0%
          .sort((a,b)=> (b.total || 0) - (a.total || 0)) // highest recent traffic first
          .slice(0,10);
        const byReliabilityDrop = [...summaries]
          .filter((s)=>Number.isFinite(s.siteFailDelta))
          .sort((a,b)=> (b.siteFailDelta || 0) - (a.siteFailDelta || 0))
          .slice(0,10);
        const byReliabilityImprove = [...summaries]
          .filter((s)=>Number.isFinite(s.siteFailDelta))
          .sort((a,b)=> (a.siteFailDelta || 0) - (b.siteFailDelta || 0))
          .slice(0,10);
        const withMissing = summaries
          .filter((s)=>s.missingDays > 0)
          .sort((a,b)=> (b.missingDays||0) - (a.missingDays||0))
          .slice(0,10);

      const cards = [];
      const windowLabel = document.getElementById("windowLabel");
      if (windowLabel) {
        const lastStart = last7.length ? last7[0] : start;
        const lastEnd = last7.length ? last7[last7.length - 1] : end;
        const prevStart = prev7.length ? prev7[0] : start;
        const prevEnd = prev7.length ? prev7[prev7.length - 1] : lastStart;
        windowLabel.textContent = `Last 7 days: ${lastStart} â†’ ${lastEnd}, Prev 7: ${prevStart} â†’ ${prevEnd}`;
      }
      cards.push(buildCard("Traffic drops â€¢ Merchants", byTrafficDrop, "totalDelta", true));
      cards.push(buildCard("Traffic spikes â€¢ Merchants", byTrafficRise, "totalDelta", false));
      cards.push(buildCard("Reliability drops â€¢ Merchants", byReliabilityDrop, "siteFailDelta", true));
      cards.push(buildCard("Reliability gains â€¢ Merchants", byReliabilityImprove, "siteFailDelta", false));
      if (withMissing.length) {
        const body = withMissing.map((r)=>`<tr>
          <td>${r.name}</td>
          <td class="num">${fmtNum(r.total)}</td>
          <td class="num">${r.missingDays}</td>
        </tr>`).join("");
        cards.push(`
          <div class="watch-card">
            <h3>Data gaps (missing days in window)</h3>
            <table class="watch-table" style="font-size:12px;">
              <thead><tr><th>Merchant</th><th class="num">Last 7d</th><th class="num">Missing days</th></tr></thead>
              <tbody>${body}</tbody>
            </table>
          </div>
        `);
      }
      // FI-level cards
      const fiHasData = fiSummaries.some((f)=> (f.total||0)>0 || (f.prevTotal||0)>0);
      if (fiHasData) {
        const fiByTrafficDrop = [...fiSummaries]
          .filter((s)=>Number.isFinite(s.totalDelta))
          .sort((a,b)=> (a.total || 0) - (b.total || 0))
          .slice(0,10);
        const fiByTrafficRise = [...fiSummaries]
          .filter((s)=>Number.isFinite(s.totalDelta))
          .sort((a,b)=> (b.total || 0) - (a.total || 0))
          .slice(0,10);
        const fiReliabilityDrop = [...fiSummaries]
          .filter((s)=>Number.isFinite(s.siteFailDelta))
          .sort((a,b)=> (b.siteFailDelta || 0) - (a.siteFailDelta || 0))
          .slice(0,10);
        cards.push(buildCard("Traffic drops â€¢ FIs", fiByTrafficDrop, "totalDelta", true));
        cards.push(buildCard("Traffic spikes â€¢ FIs", fiByTrafficRise, "totalDelta", false));
        cards.push(buildCard("Reliability drops â€¢ FIs", fiReliabilityDrop, "siteFailDelta", true));
      } else {
        cards.push(`
          <div class="watch-card">
            <h3>FI-level signals</h3>
            <p class="muted">FI-level traffic/reliability signals were unavailable for this window.</p>
          </div>
        `);
      }
      // Render cards and save to bulk cache
      const windowLabelText = windowLabel ? windowLabel.textContent : '';
      renderAllCards(cards, windowLabelText);

      // Save to bulk cache for next time (using async set for IndexedDB)
      if (window.DataCache) {
        console.log(`ðŸ’¾ Saving watchlist to cache (${cards.length} cards)...`);
        await window.DataCache.set(bulkCacheKey, {
          cards: cards,
          windowLabel: windowLabelText,
          summaryCount: summaries.length,
          daysCount: days.length
        });
        console.log('âœ“ Watchlist cached successfully');
      }

      statusEl.textContent = `Signals computed for ${summaries.length} merchants over ${days.length} days`;
      } catch (err) {
        console.error("watchlist load failed", err);
        statusEl.textContent = "Failed to load alerts.";
      } finally {
        stopLoading();
      }
    }

    // Helper function to render cards (used for both fresh load and cache)
    function renderAllCards(cards, windowLabelText) {
      if (cardsEl) {
        cardsEl.innerHTML = cards.join("");
      }
      const windowLabel = document.getElementById("windowLabel");
      if (windowLabel && windowLabelText) {
        windowLabel.textContent = windowLabelText;
      }
    }

    loadWatchlist().catch((err)=>{
      console.error(err);
      statusEl.textContent = "Failed to load alerts.";
      stopLoading();
    });
  </script>
  <script src="./theme-toggle.js"></script>
</body>
</html>
