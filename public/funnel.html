<!doctype html>
<html lang="en">
  <head>
  <meta charset="utf-8" />
  <title>GA + SIS CardUpdatr Funnel</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="./sis-shared.css?v=navfix" />
  <link rel="stylesheet" href="./assets/css/sis.css">
  <script defer src="./assets/js/sis.js"></script>
  <script defer src="./assets/js/filters.js?v=shared"></script>
  <link rel="stylesheet" href="./assets/css/filters.css">
    <style>
      :root {
        --bg: #f6f8fb;
        --panel: #ffffff;
        --panel-light: #f1f5f9;
        --text: #0f172a;
        --muted: #475569;
        --accent: #2563eb;
        --accent-2: #0ea5e9;
        --border: #d7deea;
        --input-bg: #ffffff;
        --input-border: #cbd5e1;
        --table-border: #d7deea;
        --table-header: #e2e8f0;
        --table-alt: #f8fafc;
      }
      [data-theme="dark"] {
        --bg: #070a0f;
        --panel: #111827;
        --panel-light: #1a2333;
        --text: #e2e8f0;
        --muted: #94a3b8;
        --accent: #38bdf8;
        --accent-2: #6366f1;
        --border: rgba(148, 163, 184, 0.22);
        --input-bg: #0b1120;
        --input-border: rgba(148,163,184,0.3);
        --table-border: #1f2937;
        --table-header: #0b1220;
        --table-alt: rgba(11,18,32,0.65);
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        padding: 0;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        background: var(--bg);
        color: var(--text);
        font-size: 16px;
        --sis-panel-bg: var(--panel);
      }
      .sis-panel-title {
        font-size: 1.2rem;
        margin-bottom: 12px;
      }
      .form-grid {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        align-items: flex-end;
      }
      .form-grid--dates {
        margin-top: 8px;
      }
      .form-field {
        display: flex;
        flex-direction: column;
        gap: 6px;
        min-width: 160px;
        min-height: 54px;
      }
      .form-field label {
        font-size: 0.85rem;
        color: var(--muted);
        letter-spacing: 0.03em;
        text-transform: uppercase;
        padding-left: 2px;
      }
      .form-input,
      .form-select {
        background: var(--input-bg);
        border: 1px solid var(--input-border);
        border-radius: 10px;
        color: var(--text);
        padding: 10px 12px;
        font-size: 0.92rem;
        min-width: 160px;
        height: 42px;
        line-height: 22px;
        box-sizing: border-box;
      }
      .form-input:focus,
      .form-select:focus {
        outline: none;
        border-color: var(--accent);
        box-shadow: 0 0 0 3px rgba(37,99,235,0.2);
      }
      .form-actions {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        align-items: center;
      }
      .form-checkbox label {
        display: flex;
        align-items: center;
        gap: 6px;
        font-size: 0.85rem;
        color: var(--muted);
        text-transform: none;
        letter-spacing: 0;
      }
      .form-checkbox input[type="checkbox"] {
        width: 16px;
        height: 16px;
        accent-color: var(--accent);
      }
      .form-button {
        background: linear-gradient(120deg, var(--accent), var(--accent-2));
        border: none;
        border-radius: 999px;
        padding: 10px 28px;
        min-width: 170px;
        font-size: 0.9rem;
        cursor: pointer;
        color: #f8fafc;
        font-weight: 600;
        letter-spacing: 0.2px;
      }
      .form-button.secondary {
        background: transparent;
        border: 1px solid var(--border);
        color: var(--muted);
      }
      .group-header {
        margin-top: 16px;
        font-weight: 700;
        font-size: 0.9rem;
      }
      .group-block {
        margin-top: 16px;
      }
      .single-fi-section {
        margin-top: 16px;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 8px;
        font-size: 0.8rem;
      }
      th,
      td {
        border: 1px solid var(--table-border);
        padding: 5px 7px;
        text-align: left;
      }
      th {
        background: var(--table-header);
        position: sticky;
        top: 0;
        z-index: 2;
      }
      .highlights-table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 8px;
        font-size: 0.78rem;
      }
      .highlights-table th,
      .highlights-table td {
        border: 1px solid var(--table-border);
        padding: 5px 7px;
        text-align: left;
      }
      .highlights-table th {
        background: var(--table-header);
      }
      .loading-status {
        min-height: 18px;
        font-size: 0.9rem;
        font-weight: 600;
        color: var(--accent);
        margin: 4px 0 8px;
        display: block;
      }
      .quarter-summary {
        margin-top: 12px;
      }
      .quarter-summary table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 8px;
        font-size: 0.8rem;
      }
      .quarter-summary th,
      .quarter-summary td {
        border: 1px solid var(--table-border);
        padding: 5px 7px;
        text-align: left;
      }
      .quarter-summary th {
        background: var(--table-header);
      }
      .highlights-table th:first-child,
      .highlights-table td:first-child {
        min-width: 180px;
      }
      .muted {
        color: var(--muted);
      }
      .tab-bar {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-bottom: 12px;
      }
      .tab-button {
        background: transparent;
        border: 1px solid var(--border);
        color: var(--muted);
        border-radius: 999px;
        padding: 6px 14px;
        font-size: 0.78rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        cursor: pointer;
        transition: background 0.15s ease, color 0.15s ease;
      }
      .tab-button.active {
        background: var(--panel);
        color: var(--text);
        border-color: var(--accent);
      }
      .tab-panel {
        display: none;
        margin-top: 8px;
      }
      .tab-panel.active {
        display: block;
      }
      .tab-panel h3 {
        margin: 0 0 6px;
        font-size: 0.9rem;
        color: var(--muted);
        letter-spacing: 0.08em;
        text-transform: uppercase;
      }
      .totals-row td {
        font-weight: 600;
        border-top: 2px solid var(--table-border);
        background: var(--table-alt);
      }
      .sources-missing {
        font-size: 0.72rem;
        color: #f97316;
      }
      .funnel-header {
        margin-bottom: 8px;
      }
      .form-actions {
        margin-top: 0;
      }
      .funnel-body {
        padding-top: 4px;
      }
      .funnel-body .group-header:first-of-type {
        margin-top: 0;
      }
      .date-window {
        display: inline-flex;
        align-items: center;
        height: 28px;
        padding: 0 8px;
        margin-left: 8px;
        font-size: 0.9rem;
        background: var(--panel-light);
        border-radius: 12px;
        border: 1px solid var(--border);
      }
      .partner-summary {
        margin-top: 16px;
        padding: 16px;
        border-radius: 14px;
        border: 1px solid var(--table-border);
        background: var(--panel-light);
      }
      .partner-summary h3 {
        margin: 0 0 8px;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        font-size: 0.85rem;
        color: var(--muted);
      }
      .partner-summary p {
        margin: 0 0 12px;
        color: var(--muted);
        font-size: 0.8rem;
      }
      .partner-summary__table {
        width: 100%;
        border-collapse: collapse;
      }
      .partner-summary__table th,
      .partner-summary__table td {
        border: 1px solid var(--table-border);
        padding: 6px 8px;
        text-align: left;
        font-size: 0.78rem;
      }
      .partner-summary__table th {
        background: var(--table-header);
        position: static;
      }
      .partner-summary__table tfoot td {
        font-weight: 600;
      }
      .date-warning {
        margin: 4px 0 0;
        color: #f97316;
        font-size: 0.9rem;
        display: none;
      }
      .date-warning a {
        color: inherit;
        text-decoration: underline;
      }
    </style>
  </head>
  <body>
    <header class="sis-header">
      <div class="sis-topbar">
        <div class="sis-title">Strivve Insights Service</div>

        <nav class="sis-nav">
          <a href="index.html">Overview</a>
          <a href="funnel.html">FI Funnel</a>
          <a href="heatmap.html">Merchant Heatmap</a>
          <a href="troubleshoot.html">Troubleshooting</a>
          <a href="maintenance.html">Maintenance</a>
        </nav>
      </div>

    <h1 class="sis-page-name">GA + SIS CardUpdatr Funnel</h1>
    <p class="sis-page-desc">Inspect daily rollups and conversion steps from GA through SIS sessions to placements. Slice by integration type, partner, or instances to spot deltas fast.</p>
  </header>
  <div class="sis-content">
  <main class="sis-main">
      <section class="sis-panel">
        <div id="filter-bar"></div>
        <div class="funnel-header">
          <div class="form-grid form-grid--dates">
            <div class="form-field">
              <label for="datePreset">Range preset</label>
              <select id="datePreset" class="form-select">
                <option value="last7" selected>Last 7 days</option>
                <option value="last14">Last 14 days</option>
                <option value="last30">Last 30 days</option>
                <option value="last60">Last 60 days</option>
                <option value="last90">Last 90 days</option>
                <option value="ytd">Year to date</option>
                <option value="last4q">Past 4 quarters</option>
                <option value="">Custom</option>
              </select>
            </div>
            <div class="form-field">
              <label for="startDate">Start date</label>
              <input id="startDate" type="date" class="form-input" />
            </div>
            <div class="form-field">
              <label for="endDate">End date</label>
              <input id="endDate" type="date" class="form-input" />
            </div>
            <div class="form-field" style="min-width: 200px">
              <label for="applyBtn">Actions</label>
              <div class="form-actions">
                <button id="applyBtn" class="form-button">Apply filters</button>
                <button id="exportCsvBtn" class="form-button secondary">Export CSV</button>
                <label class="form-checkbox" style="margin: 0">
                  <input type="checkbox" id="includeTestDataCheckbox" />
                  Include test data
                </label>
              </div>
            </div>
          </div>
          <div id="dateWarning" class="date-warning" aria-live="polite"></div>
        </div>

    <div class="funnel-body">
      <div class="group-header">Highlights <span class="muted date-window" id="dateWindowLabel"></span></div>
      <div id="bestWindows" style="margin-bottom: 8px;"></div>
      <div id="totalsBar" class="group-header" style="display: none;"></div>
      <div id="partnerSummary" class="partner-summary" style="display: none;"></div>
      <div id="funnelLoading" class="loading-status" aria-live="polite">Loading…</div>

      <div id="multiFiView">
      <div class="group-block" data-group="SSO">
        <div class="group-header">SSO</div>
        <table id="table-SSO">
        <thead>
          <tr>
            <th data-sort-key="fi" data-col="fi">FI</th>
            <th data-sort-key="instances" data-col="instances">instances</th>
            <th data-sort-key="integration" data-col="integration">integration</th>
            <th data-sort-key="ga_select" data-col="ga_select">GA select</th>
            <th data-sort-key="ga_user" data-col="ga_user">GA user</th>
            <th data-sort-key="ga_cred" data-col="ga_cred">GA cred</th>
            <th data-sort-key="reach" data-col="reach">monthly reach %</th>
            <th data-sort-key="sel_user_pct" data-col="sel_user_pct">sel→user %</th>
            <th data-sort-key="sel_cred_pct" data-col="sel_cred_pct">sel→cred %</th>
            <th data-sort-key="sel_success_pct" data-col="sel_success_pct">sel→success %</th>
            <th data-sort-key="sessions" data-col="sessions">sessions</th>
            <th data-sort-key="sess_with_jobs" data-col="sess_with_jobs">sess w/jobs</th>
            <th data-sort-key="sess_jobs_pct" data-col="sess_jobs_pct">sess→jobs %</th>
            <th data-sort-key="sess_with_success" data-col="sess_with_success">sess w/success</th>
            <th data-sort-key="sess_success_pct" data-col="sess_success_pct">sess→success %</th>
            <th data-sort-key="placements" data-col="placements">placements</th>
            <th data-sort-key="sources_missing" data-col="sources_missing">sources missing</th>
          </tr>
        </thead>
        <tbody></tbody>
        </table>
      </div>

      <div class="group-block" data-group="NON-SSO">
        <div class="group-header">NON-SSO</div>
        <table id="table-NON-SSO">
        <thead>
          <tr>
            <th data-sort-key="fi" data-col="fi">FI</th>
            <th data-sort-key="instances" data-col="instances">instances</th>
            <th data-sort-key="integration" data-col="integration">integration</th>
            <th data-sort-key="ga_select" data-col="ga_select">GA select</th>
            <th data-sort-key="ga_user" data-col="ga_user">GA user</th>
            <th data-sort-key="ga_cred" data-col="ga_cred">GA cred</th>
            <th data-sort-key="reach" data-col="reach">monthly reach %</th>
            <th data-sort-key="sel_user_pct" data-col="sel_user_pct">sel→user %</th>
            <th data-sort-key="sel_cred_pct" data-col="sel_cred_pct">sel→cred %</th>
            <th data-sort-key="sel_success_pct" data-col="sel_success_pct">sel→success %</th>
            <th data-sort-key="sessions" data-col="sessions">sessions</th>
            <th data-sort-key="sess_with_jobs" data-col="sess_with_jobs">sess w/jobs</th>
            <th data-sort-key="sess_jobs_pct" data-col="sess_jobs_pct">sess→jobs %</th>
            <th data-sort-key="sess_with_success" data-col="sess_with_success">sess w/success</th>
            <th data-sort-key="sess_success_pct" data-col="sess_success_pct">sess→success %</th>
            <th data-sort-key="placements" data-col="placements">placements</th>
            <th data-sort-key="sources_missing" data-col="sources_missing">sources missing</th>
          </tr>
        </thead>
        <tbody></tbody>
        </table>
      </div>

      <div class="group-block" data-group="CardSavr">
        <div class="group-header">CardSavr</div>
        <table id="table-CardSavr">
        <thead>
          <tr>
            <th data-col="fi">FI</th>
            <th data-col="instances">instances</th>
            <th data-col="integration">integration</th>
            <th data-col="ga_select">GA select</th>
            <th data-col="ga_user">GA user</th>
            <th data-col="ga_cred">GA cred</th>
            <th data-col="reach">monthly reach %</th>
            <th data-col="sel_user_pct">sel→user %</th>
            <th data-col="sel_cred_pct">sel→cred %</th>
            <th data-col="sel_success_pct">sel→success %</th>
            <th data-col="sessions">sessions</th>
            <th data-col="sess_with_jobs">sess w/jobs</th>
            <th data-col="sess_jobs_pct">sess→jobs %</th>
            <th data-col="sess_with_success">sess w/success</th>
            <th data-col="sess_success_pct">sess→success %</th>
            <th data-col="placements">placements</th>
            <th data-col="sources_missing">sources missing</th>
          </tr>
        </thead>
        <tbody></tbody>
        </table>
      </div>

      <div class="group-block" data-group="TEST">
        <div class="group-header">TEST</div>
        <table id="table-TEST">
        <thead>
          <tr>
            <th data-col="fi">FI</th>
            <th data-col="instances">instances</th>
            <th data-col="integration">integration</th>
            <th data-col="ga_select">GA select</th>
            <th data-col="ga_user">GA user</th>
            <th data-col="ga_cred">GA cred</th>
            <th data-col="reach">monthly reach %</th>
            <th data-col="sel_user_pct">sel→user %</th>
            <th data-col="sel_cred_pct">sel→cred %</th>
            <th data-col="sel_success_pct">sel→success %</th>
            <th data-col="sessions">sessions</th>
            <th data-col="sess_with_jobs">sess w/jobs</th>
            <th data-col="sess_jobs_pct">sess→jobs %</th>
            <th data-col="sess_with_success">sess w/success</th>
            <th data-col="sess_success_pct">sess→success %</th>
            <th data-col="placements">placements</th>
            <th data-col="sources_missing">sources missing</th>
          </tr>
        </thead>
        <tbody></tbody>
        </table>
      </div>

      <div class="group-block" data-group="UNKNOWN">
        <div class="group-header">UNKNOWN</div>
        <table id="table-UNKNOWN">
        <thead>
          <tr>
            <th data-col="fi">FI</th>
            <th data-col="instances">instances</th>
            <th data-col="integration">integration</th>
            <th data-col="ga_select">GA select</th>
            <th data-col="ga_user">GA user</th>
            <th data-col="ga_cred">GA cred</th>
            <th data-col="reach">monthly reach %</th>
            <th data-col="sel_user_pct">sel→user %</th>
            <th data-col="sel_cred_pct">sel→cred %</th>
            <th data-col="sel_success_pct">sel→success %</th>
            <th data-col="sessions">sessions</th>
            <th data-col="sess_with_jobs">sess w/jobs</th>
            <th data-col="sess_jobs_pct">sess→jobs %</th>
            <th data-col="sess_with_success">sess w/success</th>
            <th data-col="sess_success_pct">sess→success %</th>
            <th data-col="placements">placements</th>
            <th data-col="sources_missing">sources missing</th>
          </tr>
        </thead>
        <tbody></tbody>
        </table>
      </div>
      </div>

      <div id="singleFiView" style="display:none;"></div>
      </div>
    </section>
  </main>
  </div>

    <script>
      const startDateInput = document.getElementById("startDate");
      const endDateInput = document.getElementById("endDate");
      const dateWarningEl = document.getElementById("dateWarning");
      const fiFilterSelect = document.getElementById("fiFilter");
      const integrationSelect = document.getElementById("integrationFilter");
      const partnerSelect = document.getElementById("partnerFilter");
      const instanceSelect = document.getElementById("instanceFilter");
      const includeTestCheckbox = document.getElementById("includeTestDataCheckbox");
      const applyBtn = document.getElementById("applyBtn");
      const exportCsvBtn = document.getElementById("exportCsvBtn");
      const dateWindowLabel = document.getElementById("dateWindowLabel");
      const bestWindowsDiv = document.getElementById("bestWindows");
      const totalsBar = document.getElementById("totalsBar");
      const partnerSummaryBox = document.getElementById("partnerSummary");
      const quarterSummaryBox = document.createElement("div");
      quarterSummaryBox.id = "quarterSummary";
      quarterSummaryBox.className = "quarter-summary";
      if (partnerSummaryBox?.parentNode) {
        partnerSummaryBox.parentNode.insertBefore(quarterSummaryBox, partnerSummaryBox.nextSibling);
      }
      const multiFiView = document.getElementById("multiFiView");
      const singleFiView = document.getElementById("singleFiView");
      const loadingEl = document.getElementById("funnelLoading");
      let loadingInterval = null;
      if (includeTestCheckbox) includeTestCheckbox.checked = false;
      let latestDailyDate = null;
      let earliestDailyDate = null;

      const tableBodies = {
        SSO: document.querySelector("#table-SSO tbody"),
        "NON-SSO": document.querySelector("#table-NON-SSO tbody"),
        CardSavr: document.querySelector("#table-CardSavr tbody"),
        TEST: document.querySelector("#table-TEST tbody"),
        UNKNOWN: document.querySelector("#table-UNKNOWN tbody"),
      };
      const groupBlocks = {
        SSO: document.querySelector('[data-group="SSO"]'),
        "NON-SSO": document.querySelector('[data-group="NON-SSO"]'),
        CardSavr: document.querySelector('[data-group="CardSavr"]'),
        TEST: document.querySelector('[data-group="TEST"]'),
        UNKNOWN: document.querySelector('[data-group="UNKNOWN"]'),
      };
      const groupHeaders = Object.fromEntries(
        Object.entries(groupBlocks).map(([key, block]) => [
          key,
          block ? block.querySelector(".group-header") : null,
        ])
      );
      const GROUP_LABELS = {
        SSO: "SSO",
        "NON-SSO": "NON-SSO",
        CardSavr: "CardSavr",
        TEST: "TEST",
        UNKNOWN: "UNKNOWN",
      };

      const dayMs = 86400000;
      const today = new Date();
      const isoLocalFromDate = (d) => {
        const copy = new Date(d.getTime());
        copy.setHours(0, 0, 0, 0);
        const tzOffset = copy.getTimezoneOffset() * 60000;
        return new Date(copy.getTime() - tzOffset).toISOString().slice(0, 10);
      };
      const isoLocalToday = () => isoLocalFromDate(new Date());
      const isoLocalDaysAgo = (n) => {
        const d = new Date();
        d.setDate(d.getDate() - n);
        return isoLocalFromDate(d);
      };
      const isoLocalYesterday = () => isoLocalDaysAgo(1);
      const defaultEndDateStr = isoLocalYesterday(); // yesterday by default
      const defaultStartDateStr = isoLocalDaysAgo(6); // last 7 days ending yesterday

      const getLatestUsableDateIso = () => {
        const yesterday = isoLocalYesterday();
        if (latestDailyDate) {
          return latestDailyDate < yesterday ? latestDailyDate : yesterday;
        }
        return yesterday;
      };

      function getReferenceDate() {
        const latestIso = getLatestUsableDateIso();
        return new Date(`${latestIso}T00:00:00Z`);
      }

      function enforceEndDateBounds() {
        try {
          const baseRef = getReferenceDate();
          const baseIso = isoLocalFromDate(baseRef);
          if (endDateInput && endDateInput.value && endDateInput.value > baseIso) {
            endDateInput.value = baseIso;
          }
          if (
            startDateInput &&
            endDateInput &&
            startDateInput.value &&
            endDateInput.value &&
            startDateInput.value > endDateInput.value
          ) {
            startDateInput.value = endDateInput.value;
          }
        } catch (err) {
          console.warn("enforceEndDateBounds failed", err);
        }
      }

      function renderDateWarning() {
        if (!dateWarningEl) return;
        try {
          if (!latestDailyDate) {
            dateWarningEl.style.display = "none";
            dateWarningEl.textContent = "";
            return;
          }
          const chosenEnd = endDateInput?.value;
          if (!chosenEnd || chosenEnd <= latestDailyDate) {
            dateWarningEl.style.display = "none";
            dateWarningEl.textContent = "";
            return;
          }
          const linkHref = `maintenance.html?date=${encodeURIComponent(chosenEnd)}`;
          dateWarningEl.innerHTML = `Heads up: data is only available through ${latestDailyDate}. You selected ${chosenEnd}. <a href="${linkHref}">Open maintenance for that date</a>.`;
          dateWarningEl.style.display = "block";
        } catch (err) {
          console.warn("renderDateWarning failed", err);
        }
      }

      function applyPresetRange(value) {
        const ref = getReferenceDate();
        const iso = (d) => d.toISOString().slice(0, 10);
        const daysAgo = (n) => iso(new Date(ref.getTime() - n * dayMs));
        const startOfYear = `${ref.getUTCFullYear()}-01-01`;
        const lastFullQuarterRange = () => {
          const q = Math.floor(ref.getUTCMonth() / 3); // 0-based current quarter
          const endQuarter = q === 0 ? 3 : q; // last full quarter index (1..4)
          const endYear = q === 0 ? ref.getUTCFullYear() - 1 : ref.getUTCFullYear();
          const endMonth = endQuarter * 3; // 3,6,9,12
          const end = new Date(Date.UTC(endYear, endMonth, 0)); // last day of that quarter
          const start = new Date(Date.UTC(endYear, endMonth - 3, 1)); // first day of that quarter
          const start4q = new Date(Date.UTC(start.getUTCFullYear(), start.getUTCMonth() - 9, 1));
          return { start: iso(start4q), end: iso(end) };
        };

        let start = daysAgo(6); // default last 7
        let end = iso(ref);
        switch (value) {
          case "last7":
            start = daysAgo(6);
            break;
          case "last14":
            start = daysAgo(13);
            break;
          case "last30":
            start = daysAgo(29);
            break;
          case "last60":
            start = daysAgo(59);
            break;
          case "last90":
            start = daysAgo(89);
            break;
          case "last4q": {
            const qRange = lastFullQuarterRange();
            start = qRange.start;
            end = qRange.end;
            break;
          }
          case "ytd":
            start = startOfYear;
            break;
          default:
            start = daysAgo(6);
        }
        startDateInput.value = start;
        endDateInput.value = end;
        renderDateWarning();
      }

      function ensureDateDefaults() {
        if (!startDateInput.value) startDateInput.value = defaultStartDateStr;
        if (!endDateInput.value) endDateInput.value = defaultEndDateStr;
        enforceEndDateBounds();
        const preset = document.getElementById("datePreset");
        if (preset && !preset.value) preset.value = "last7";
      }

      function applyDefaultDateRange(force = false) {
        if (force || !startDateInput.value || !endDateInput.value) {
          applyPresetRange("last7");
          const preset = document.getElementById("datePreset");
          if (preset) preset.value = "last7";
        }
      }

      function safeApplyFilters() {
        ensureDateDefaults();
        enforceEndDateBounds();
        renderDateWarning();
        applyFilters();
      }

      function updatePartnerOptions(perFi) {
        if (!partnerSelect || !perFi) return;
        const integrationValue = integrationSelect?.value || "(all)";
        const partners = Array.from(
          new Set(
            Object.values(perFi)
              .filter((row) =>
                integrationValue === "(all)" ? true : row.integration_type === integrationValue
              )
              .map((row) => row.partner || "Unknown")
          )
        ).sort((a, b) => a.localeCompare(b));
        const existingValue = partnerSelect.value || PARTNER_ALL_VALUE;
        partnerSelect.innerHTML = "";
        const addOption = (value, label) => {
          const opt = document.createElement("option");
          opt.value = value;
          opt.textContent = label;
          partnerSelect.appendChild(opt);
        };
        addOption(PARTNER_ALL_VALUE, "(all partners)");
        partners.forEach((partner) => addOption(partner, partner));
        if (existingValue && partners.includes(existingValue)) {
          partnerSelect.value = existingValue;
        } else {
          partnerSelect.value = PARTNER_ALL_VALUE;
        }
      }

      applyDefaultDateRange(true);

const MIN_SELECTS = 10;
const registryInfoMap = new Map();
const registryCardholderMap = new Map();

function buildRegistryLookupKey(fiName, instanceValue) {
  const fiKey = normalizeFiKey(fiName);
  const instKey = normalizeInstanceKey(instanceValue);
  return makeFiInstanceKey(fiKey, instKey);
}

function updateRegistryLookups(registryData = {}) {
  registryInfoMap.clear();
  registryCardholderMap.clear();
  Object.values(registryData || {}).forEach((entry) => {
    if (!entry || typeof entry !== "object") return;
    const fiKey = normalizeFiKey(entry.fi_lookup_key || entry.fi_name);
    const instanceValue = entry.instance || (Array.isArray(entry.instances) ? entry.instances[0] : null);
    const comboKey = buildRegistryLookupKey(fiKey, instanceValue);
    if (comboKey && !registryInfoMap.has(comboKey)) {
      registryInfoMap.set(comboKey, entry);
    }
    if (fiKey && !registryInfoMap.has(fiKey)) {
      registryInfoMap.set(fiKey, entry);
    }
    const total = Number(entry.cardholder_total);
    if (!Number.isFinite(total) || total <= 0) return;
    const info = {
      total,
      as_of: entry.cardholder_as_of || null,
      source: entry.cardholder_source || null,
    };
    if (comboKey && !registryCardholderMap.has(comboKey)) {
      registryCardholderMap.set(comboKey, info);
    }
    if (fiKey && !registryCardholderMap.has(fiKey)) {
      registryCardholderMap.set(fiKey, info);
    }
  });
}

function getRegistryEntry(fiName, instanceValue) {
  const fiKey = normalizeFiKey(fiName);
  const comboKey = buildRegistryLookupKey(fiName, instanceValue);
  return (
    registryInfoMap.get(comboKey) ||
    registryInfoMap.get(fiKey) ||
    null
  );
}

function getRegistryCardholderInfo(fiName, instanceValue) {
  const fiKey = normalizeFiKey(fiName);
  const comboKey = buildRegistryLookupKey(fiName, instanceValue);
  return (
    registryCardholderMap.get(comboKey) ||
    registryCardholderMap.get(fiKey) ||
    null
  );
}

function normalizeIntegrationLabel(value) {
  if (!value) return "NON-SSO";
  const raw = value.toString().trim().toUpperCase().replace(/[_\s-]+/g, "-");
  if (raw === "SSO") return "SSO";
  if (raw === "CARDSAVR" || raw === "CARD-SAVR" || raw === "CARDSAVER") {
    return "CardSavr";
  }
  if (raw === "TEST") return "TEST";
  if (raw === "UNKNOWN") return "UNKNOWN";
  return "NON-SSO";
}

function formatPartnerLabel(value) {
  if (!value) return "Unknown";
  return value.toString();
}

const COLUMN_TITLES = {
  highlight: "Name of the highlight window.",
  fi: "Financial institution name.",
  instances: "Cardsavr instance(s) producing this data.",
  integration: "Integration type for the FI (SSO, CardSavr, etc.).",
  dates: "Date range covered by the highlight window.",
  ga_select: "Number of GA select-merchants page views.",
  ga_user: "GA user-data-collection page views.",
  ga_cred: "GA credential-entry page views.",
  reach: "Monthly reach estimate (select views normalized by cardholders).",
  sel_user_pct: "Percent of select views that reached the user data collection step.",
  sel_cred_pct: "Percent of select views that reached the credential entry step.",
  sel_success_pct: "Percent of select views that produced a successful SIS session.",
  sessions: "Total SIS sessions fetched for this FI/instance.",
  sess_with_jobs: "Sessions that contained one or more placement jobs.",
  sess_jobs_pct: "Percent of sessions that contained placement jobs.",
  sess_with_success: "Sessions with at least one successful job.",
  sess_success_pct: "Percent of sessions with a successful job.",
  placements: "Billable placement attempts over the period.",
  sources_missing: "Days where GA or SIS data was missing.",
  period: "Time bucket label for the single-FI view.",
};

function columnAttr(key) {
  const tip = COLUMN_TITLES[key];
  const title = tip ? ` title="${tip}"` : "";
  return ` data-col="${key}"${title}`;
}

function applyColumnTitles(root = document) {
  Object.entries(COLUMN_TITLES).forEach(([key, tip]) => {
    if (!tip) return;
    root.querySelectorAll(`[data-col="${key}"]`).forEach((el) => {
      if (!el.getAttribute("title")) {
        el.setAttribute("title", tip);
      }
    });
  });
}

      const normalizeFiKey = (value) =>
        value ? value.toString().trim().toLowerCase() : "";
      const normalizeInstanceKey = (value) => {
        if (!value) return "unknown";
        const str = value.toString().trim().toLowerCase();
        const normalized = str.replace(/[^a-z0-9]/g, "");
        return normalized || "unknown";
      };
      const makeFiInstanceKey = (fi, instance) =>
        `${normalizeFiKey(fi)}__${normalizeInstanceKey(instance)}`;
      const parseFiInstanceKey = (key = "") => {
        if (!key.includes("__")) {
          return { fi: key, instance: "unknown" };
        }
        const [fi, instance] = key.split("__");
        return { fi, instance: instance || "unknown" };
      };
      const FI_ALL_VALUE = "__all__";
      const PARTNER_ALL_VALUE = "__all_partners__";
      const INSTANCE_ALL_VALUE = "__all_instances__";

      let registryMap = {};
      let dailyFiles = [];
      const dailyData = {};
      let lastAggregated = null;
      let lastRenderContext = null;
      let lastFilterSnapshot = null;
      let latestVisibleRows = [];
      let latestSingleFiBreakdowns = null;
      let latestHighlights = [];
      let latestPartnerSummary = null;
      let latestQuarterSummary = null;

      function buildLast4QuarterRanges(endIso) {
        const parseIso = (iso) => new Date(`${iso}T00:00:00Z`);
        const endDate = endIso ? parseIso(endIso) : new Date();
        let q = Math.floor(endDate.getUTCMonth() / 3) + 1;
        let year = endDate.getUTCFullYear();
        // use last full quarter
        if (q === Math.floor(new Date().getUTCMonth() / 3) + 1 && endDate.getUTCDate() < 31) {
          // already end of quarter? assume preset ensures full quarter; keep as is
        }
        if (endDate > new Date()) {
          q = Math.floor(new Date().getUTCMonth() / 3);
          year = new Date().getUTCFullYear();
        }
        if (q === Math.floor(new Date().getUTCMonth() / 3) + 1) {
          q = q - 1 || 4;
          if (q === 4) year -= 1;
        }
        const ranges = [];
        for (let i = 0; i < 4; i++) {
          const endMonth = q * 3; // 3,6,9,12
          const end = new Date(Date.UTC(year, endMonth, 0));
          const start = new Date(Date.UTC(year, endMonth - 3, 1));
          ranges.unshift({
            label: `Q${q} ${year}`,
            start: start.toISOString().slice(0, 10),
            end: end.toISOString().slice(0, 10),
          });
          q -= 1;
          if (q === 0) {
            q = 4;
            year -= 1;
          }
        }
        return ranges;
      }

      function summarizeRange(perFi = {}, includeTests = true) {
        const totals = {
          ga_select: 0,
          ga_user: 0,
          ga_cred: 0,
          sessions: 0,
          sess_with_jobs: 0,
          sess_with_success: 0,
          placements: 0,
          cardholders: 0,
        };
        const seenFi = new Set();
        Object.values(perFi || {}).forEach((row) => {
          if (!includeTests && row.is_test) return;
          totals.ga_select += Number(row.ga_select || 0);
          totals.ga_user += Number(row.ga_user || 0);
          totals.ga_cred += Number(row.ga_cred || 0);
          totals.sessions += Number(row.sessions || 0);
          totals.sess_with_jobs += Number(row.sess_with_jobs || 0);
          totals.sess_with_success += Number(row.sess_with_success || 0);
          totals.placements += Number(row.placements || 0);
          const fiKey = row.fi || row.key || "";
          if (!seenFi.has(fiKey) && Number.isFinite(row.cardholders)) {
            totals.cardholders += Number(row.cardholders);
            seenFi.add(fiKey);
          }
        });
        return totals;
      }

      function summarizeQuarterRanges(ranges = [], includeTests = true, cardholderMap) {
        const rows = ranges.map((range) => {
          const perFi = aggregateData(range.start, range.end, cardholderMap);
          const totals = summarizeRange(perFi, includeTests);
          return { ...range, totals };
        });
        const total = rows.reduce(
          (acc, row) => {
            Object.keys(acc).forEach((k) => {
              acc[k] += Number(row.totals[k] || 0);
            });
            return acc;
          },
          {
            ga_select: 0,
            ga_user: 0,
            ga_cred: 0,
            sessions: 0,
            sess_with_jobs: 0,
            sess_with_success: 0,
            placements: 0,
            cardholders: 0,
          }
        );
        return { rows, total };
      }

      function renderQuarterSummary(summary) {
        const box = document.getElementById("quarterSummary");
        if (!box) return;
        if (!summary || !summary.rows || !summary.rows.length) {
          box.style.display = "none";
          box.innerHTML = "";
          return;
        }
        const percent = (num, den) =>
          den && Number.isFinite(num) ? ((num / den) * 100).toFixed(1) + "%" : "—";
        const rowsHtml = summary.rows
          .map((row) => {
            const t = row.totals || {};
            const sessSuccessPct = percent(t.sess_with_success, t.sessions);
            const rangeLabel = row.start === row.end ? row.start : `${row.start} → ${row.end}`;
            return `
              <tr>
                <td>${row.label}</td>
                <td>${rangeLabel}</td>
                <td>${t.ga_select}</td>
                <td>${t.ga_user}</td>
                <td>${t.ga_cred}</td>
                <td>${t.sessions}</td>
                <td>${t.sess_with_success}</td>
                <td>${sessSuccessPct}</td>
                <td>${t.placements}</td>
                <td>${t.cardholders}</td>
              </tr>
            `;
          })
          .join("");
        const total = summary.total || {};
        const totalPct = percent(total.sess_with_success, total.sessions);
        box.innerHTML = `
          <h3>Past 4 quarters</h3>
          <table>
            <thead>
              <tr>
                <th>Quarter</th>
                <th>Dates</th>
                <th>GA select</th>
                <th>GA user</th>
                <th>GA cred</th>
                <th>Sessions</th>
                <th>Sessions w/success</th>
                <th>sess→success %</th>
                <th>Placements</th>
                <th>Cardholders</th>
              </tr>
            </thead>
            <tbody>
              ${rowsHtml}
              <tr>
                <th>Total</th>
                <td>4Q aggregate</td>
                <td>${total.ga_select || 0}</td>
                <td>${total.ga_user || 0}</td>
                <td>${total.ga_cred || 0}</td>
                <td>${total.sessions || 0}</td>
                <td>${total.sess_with_success || 0}</td>
                <td>${totalPct}</td>
                <td>${total.placements || 0}</td>
                <td>${total.cardholders || 0}</td>
              </tr>
            </tbody>
          </table>
        `;
        box.style.display = "";
      }

      const tableSortState = {
        multi: {},
        single: {},
      };

      const DEFAULT_SORT = { column: "sessions", direction: "desc" };
      // Initialize date inputs with default window on load
      if (startDateInput && !startDateInput.value) startDateInput.value = defaultStartDateStr;
      if (endDateInput && !endDateInput.value) endDateInput.value = defaultEndDateStr;
      const presetEl = document.getElementById("datePreset");
      if (presetEl) presetEl.value = "last30";

      async function fetchJson(url) {
        const res = await fetch(url);
        if (!res.ok) {
          throw new Error(`${url} → ${res.status}`);
        }
        return res.json();
      }

      function deriveIntegration(meta) {
        const raw = (meta?.integration_type || "").toString().toLowerCase();
        const instances = (meta?.instances || []).map((inst) =>
          (inst || "").toString().toLowerCase()
        );
        const hasOnDot = instances.some((inst) => inst.includes("ondot"));
        if (hasOnDot || raw === "cardsavr") return "CardSavr";
        if (raw === "sso") return "SSO";
        return "NON-SSO";
      }

      function extractInstances(meta) {
        if (!meta || typeof meta !== "object") return [];
        const list = Array.isArray(meta.instances) ? meta.instances.slice() : [];
        if (meta.instance) {
          list.push(meta.instance);
        }
        return Array.from(
          new Set(
            list
              .filter(Boolean)
              .map((inst) => inst.toString())
          )
        ).sort((a, b) => a.localeCompare(b));
      }

      async function fetchRegistry() {
        const data = await fetchJson("/fi-registry");
        const map = {};
        const precedence = { CardSavr: 3, SSO: 2, "NON-SSO": 1 };

        const mergeEntry = (key, payload) => {
          if (!key) return;
          if (!map[key]) {
            map[key] = { ...payload };
            return;
          }
          const existing = map[key];
          const incomingPriority = precedence[payload.integration || "NON-SSO"] || 0;
          const existingPriority = precedence[existing.integration || "NON-SSO"] || 0;
          if (incomingPriority > existingPriority) {
            existing.integration = payload.integration;
          }
          const mergedInstances = new Set(existing.instances || []);
          (payload.instances || []).forEach((inst) => mergedInstances.add(inst));
          existing.instances = Array.from(mergedInstances).sort((a, b) =>
            a.localeCompare(b)
          );
          if (!existing.instance && payload.instance) {
            existing.instance = payload.instance;
          }
          if (!existing.fi_lookup_key && payload.fi_lookup_key) {
            existing.fi_lookup_key = payload.fi_lookup_key;
          }
          if (!existing.fi_name && payload.fi_name) {
            existing.fi_name = payload.fi_name;
          }
          if (!existing.partner && payload.partner) {
            existing.partner = payload.partner;
          }
          const incomingCardholders = Number(payload.cardholder_total);
          if (
            Number.isFinite(incomingCardholders) &&
            incomingCardholders > 0 &&
            (!Number.isFinite(Number(existing.cardholder_total)) ||
              Number(existing.cardholder_total) <= 0)
          ) {
            existing.cardholder_total = payload.cardholder_total;
          }
          if (!existing.cardholder_source && payload.cardholder_source) {
            existing.cardholder_source = payload.cardholder_source;
          }
          if (!existing.cardholder_as_of && payload.cardholder_as_of) {
            existing.cardholder_as_of = payload.cardholder_as_of;
          }
        };

        const assignMeta = (metaLike = {}) => {
          const fiKey = normalizeFiKey(
            metaLike.fi_lookup_key || metaLike.fi_name || metaLike.fi || ""
          );
          if (!fiKey) return;
          const integration = deriveIntegration(metaLike);
          const instances = extractInstances(metaLike);
          const cardholderTotal =
            metaLike.cardholder_total !== undefined
              ? metaLike.cardholder_total
              : null;
          const basePayload = {
            integration,
            instances,
            fi_lookup_key: fiKey,
            fi_name: metaLike.fi_name || metaLike.fi || metaLike.fi_lookup_key || "",
            partner: metaLike.partner || null,
            cardholder_total: cardholderTotal,
            cardholder_as_of: metaLike.cardholder_as_of || null,
            cardholder_source: metaLike.cardholder_source || null,
          };
          mergeEntry(fiKey, {
            ...basePayload,
          });
          if (instances.length) {
            instances.forEach((instance) => {
              const normInstance = normalizeInstanceKey(instance);
              const comboKey = makeFiInstanceKey(fiKey, normInstance);
              mergeEntry(comboKey, {
                ...basePayload,
                instances: [instance],
                instance,
              });
            });
          } else {
            const comboKey = makeFiInstanceKey(fiKey, "unknown");
            mergeEntry(comboKey, {
              ...basePayload,
              instances: ["unknown"],
              instance: "unknown",
            });
          }
        };

        if (Array.isArray(data)) {
          data.forEach((row) => assignMeta(row || {}));
        } else if (data && typeof data === "object") {
          for (const [fiName, meta] of Object.entries(data)) {
            assignMeta({ fi_name: fiName, ...(meta || {}) });
          }
        }

        return map;
      }

      async function fetchDailyList() {
        const payload = await fetchJson("/list-daily");
        return payload.files || [];
      }

      async function fetchDaily(date) {
        const payload = await fetchJson(`/daily?date=${date}`);
        return payload?.error ? null : payload;
      }

      function getCardholderMap() {
        // Cardholders come from fi_registry metadata only now.
        return {};
      }

      function updateInstanceOptions(perFi) {
        if (!instanceSelect) return;
        if (!perFi) return;
        const integrationValue = integrationSelect?.value || "(all)";
        const filterFi = fiFilterSelect?.value || FI_ALL_VALUE;
        const partnerValue = partnerSelect?.value || PARTNER_ALL_VALUE;
        const eligible = Array.from(
          new Set(
            Object.values(perFi)
              .filter((row) =>
                integrationValue === "(all)" ? true : row.integration_type === integrationValue
              )
              .filter((row) =>
                !filterFi || filterFi === FI_ALL_VALUE ? true : row.fi === filterFi
              )
              .filter((row) =>
                partnerValue === PARTNER_ALL_VALUE ? true : (row.partner || "Unknown") === partnerValue
              )
              .flatMap((row) =>
                Array.isArray(row.instances) && row.instances.length
                  ? row.instances
                  : row.instance
                  ? [row.instance]
                  : []
              )
              .map((value) => formatInstanceDisplay(value))
          )
        )
          .filter(Boolean)
          .sort((a, b) => a.localeCompare(b));

        const existingValue = instanceSelect.value || INSTANCE_ALL_VALUE;
        instanceSelect.innerHTML = "";

        const addOption = (value, label, selected = false) => {
          const opt = document.createElement("option");
          opt.value = value;
          opt.textContent = label;
          if (selected) {
            opt.selected = true;
          }
          instanceSelect.appendChild(opt);
        };

        addOption(INSTANCE_ALL_VALUE, "(all instances)", existingValue === INSTANCE_ALL_VALUE);
        eligible.forEach((instance) => {
          addOption(instance, instance, existingValue === instance);
        });

        if (!instanceSelect.value) {
          instanceSelect.value = INSTANCE_ALL_VALUE;
        }
      }

      function updateFiOptions(perFi) {
        if (!perFi || !fiFilterSelect) return;
        const integrationValue = integrationSelect?.value || "(all)";
        const partnerValue = partnerSelect?.value || PARTNER_ALL_VALUE;
        const eligible = Array.from(
          new Set(
            Object.values(perFi)
              .filter((row) =>
                integrationValue === "(all)" ? true : row.integration_type === integrationValue
              )
              .filter((row) =>
                partnerValue === PARTNER_ALL_VALUE ? true : (row.partner || "Unknown") === partnerValue
              )
              .map((row) => row.fi)
          )
        ).sort((a, b) => a.localeCompare(b));

        const existingValue = fiFilterSelect?.value;
        fiFilterSelect.innerHTML = "";
        const addOption = (value, label) => {
          const opt = document.createElement("option");
          opt.value = value;
          opt.textContent = label;
          fiFilterSelect.appendChild(opt);
        };

        addOption(FI_ALL_VALUE, "(all FIs)");
        eligible.forEach((fi) => addOption(fi, fi));

        if (existingValue && existingValue !== FI_ALL_VALUE) {
          const stillPresent = eligible.includes(existingValue);
          fiFilterSelect.value = stillPresent ? existingValue : FI_ALL_VALUE;
        } else {
          fiFilterSelect.value = FI_ALL_VALUE;
        }

        updateInstanceOptions(perFi);
      }

      function getSelectedInstances() {
        if (!instanceSelect) return [];
        const value = instanceSelect.value;
        if (!value || value === INSTANCE_ALL_VALUE) return [];
        return [normalizeInstanceKey(value)];
      }

      const normalizeIntegrationKey = (val) => {
        const upper = (val || "").toString().trim().toUpperCase();
        if (upper === "NON-SSO" || upper === "NON_SSO" || upper === "NONSSO") return "NON-SSO";
        if (upper === "SSO") return "SSO";
        return upper;
      };

      function getVisibleRows(perFi) {
        const shared = window.__FILTER_STATE;
        const includeTests = includeTestCheckbox?.checked;
        const fiTouched = shared && shared.__fiTouched;
        const canonicalSet =
          shared && shared.canonicalFiInstances && shared.canonicalFiInstances.size
            ? shared.canonicalFiInstances
            : null;
        const matchesCanonical = (row) => {
          if (!canonicalSet) return true;
          const fiKey = normalizeFiKey(row.fi);
          const instRaw =
            row.instance ||
            (Array.isArray(row.instances) && row.instances.length ? row.instances[0] : "any");
          const instKey = normalizeInstanceKey(instRaw || "any");
          const keyExact = makeFiInstanceKey(fiKey, instKey);
          const keyAny = makeFiInstanceKey(fiKey, "any");
          return canonicalSet.has(keyExact) || canonicalSet.has(keyAny);
        };
        if (shared && shared.page === "funnel") {
          const sharedFiSet = shared.fis
            ? new Set(Array.from(shared.fis).map((fi) => normalizeFiKey(fi)))
            : new Set();
          const sharedIntegration = normalizeIntegrationKey(shared.integration);
          const selectedInstances =
            shared.instance && shared.instance !== "All"
              ? [normalizeInstanceKey(shared.instance)]
              : [];
          return Object.values(perFi).filter((row) => {
            if (!includeTests && row.is_test) return false;
            if (!matchesCanonical(row)) return false;
            const rowPartner = row.partner || "Unknown";
            if (shared.partner !== "All" && rowPartner !== shared.partner) return false;
            const rowIntegration = normalizeIntegrationKey(row.integration_type);
            if (shared.integration !== "All" && rowIntegration !== sharedIntegration) return false;
            if (fiTouched && sharedFiSet.size === 0) return false;
            if (sharedFiSet.size) {
              const fiKey = normalizeFiKey(row.fi);
              if (!sharedFiSet.has(fiKey)) return false;
            }
            if (selectedInstances.length > 0) {
              const rowInstances =
                Array.isArray(row.instances) && row.instances.length
                  ? row.instances.map((inst) => normalizeInstanceKey(inst))
                  : [normalizeInstanceKey(row.instance)];
              if (!rowInstances.some((inst) => selectedInstances.includes(inst))) return false;
            }
            return true;
          });
        }

        const filterFi = fiFilterSelect?.value || FI_ALL_VALUE;
        const filterIntegration = integrationSelect?.value || "(all)";
        const filterPartner = partnerSelect?.value || PARTNER_ALL_VALUE;
        const selectedInstances = getSelectedInstances();
        return Object.values(perFi).filter((row) => {
          if (!includeTests && row.is_test) return false;
          if (!matchesCanonical(row)) return false;
          if (filterFi && filterFi !== FI_ALL_VALUE && row.fi !== filterFi) return false;
          if (filterIntegration !== "(all)" && row.integration_type !== filterIntegration) return false;
          if (filterPartner !== PARTNER_ALL_VALUE) {
            const rowPartner = row.partner || "Unknown";
            if (rowPartner !== filterPartner) return false;
          }
          if (selectedInstances.length > 0) {
            const rowInstances =
              Array.isArray(row.instances) && row.instances.length
                ? row.instances.map((inst) => normalizeInstanceKey(inst))
                : [normalizeInstanceKey(row.instance)];
            if (!rowInstances.some((inst) => selectedInstances.includes(inst))) return false;
          }
          return true;
        });
      }

      function isSingleFiSelected() {
        const shared = window.__FILTER_STATE;
        if (shared && shared.page === "funnel") {
          return shared.fis && shared.fis.size === 1;
        }
        return fiFilterSelect && fiFilterSelect.value && fiFilterSelect.value !== FI_ALL_VALUE;
      }

      function parseDateUtc(dateStr) {
        return new Date(`${dateStr}T00:00:00Z`);
      }

      function formatDateUtc(dateObj) {
        return dateObj.toISOString().slice(0, 10);
      }

      function addDaysUtc(dateObj, days) {
        const d = new Date(dateObj);
        d.setUTCDate(d.getUTCDate() + days);
        return d;
      }

      function dayCountInclusive(start, end) {
        if (!start || !end) return null;
        const startDt = parseDateUtc(start);
        const endDt = parseDateUtc(end);
        const diff = Math.floor((endDt - startDt) / (1000 * 60 * 60 * 24));
        return diff >= 0 ? diff + 1 : null;
      }

      function getMonthlyReachValue(row) {
        const cardholders = row?.cardholders;
        if (!cardholders || cardholders <= 0) return 0;
        const dayCount =
          row.dayCount ||
          dayCountInclusive(row.periodStart || row.start, row.periodEnd || row.end) ||
          lastRenderContext?.daySpan ||
          1;
        const reachBase = row.ga_select > 0 ? row.ga_select : row.sessions;
        if (!reachBase || dayCount <= 0) return 0;
        const reachMonthly = reachBase * (30 / dayCount);
        return reachMonthly > 0 ? reachMonthly / cardholders : 0;
      }

      function formatMonthlyReachPct(row) {
        const value = getMonthlyReachValue(row);
        return value > 0 ? (value * 100).toFixed(1) + "%" : "";
      }

      function getSessSuccessRatio(row) {
        if (!row.sessions) return 0;
        return (row.sess_with_success || 0) / row.sessions;
      }

      function getSessJobsRatio(row) {
        if (!row.sessions) return 0;
        return (row.sess_with_jobs || 0) / row.sessions;
      }

      function formatSessSuccessPct(row) {
        if (!row.sessions) return "";
        const ratio = getSessSuccessRatio(row);
        return (ratio * 100).toFixed(1) + "%";
      }

      function formatSessJobsPct(row) {
        if (!row.sessions) return "";
        const ratio = getSessJobsRatio(row);
        return (ratio * 100).toFixed(1) + "%";
      }

      function getSelectToSuccessRatio(row) {
        if (!row) return 0;
        const selectCount =
          typeof row.ga_select === "number" && row.ga_select > 0
            ? row.ga_select
            : typeof row.sel === "number" && row.sel > 0
            ? row.sel
            : typeof row.select === "number" && row.select > 0
            ? row.select
            : 0;
        if (!selectCount) return 0;
        const successSessions =
          typeof row.sess_with_success === "number"
            ? row.sess_with_success
            : typeof row.sessions_with_success === "number"
            ? row.sessions_with_success
            : typeof row.success_sessions === "number"
            ? row.success_sessions
            : 0;
        if (!successSessions) return 0;
        return successSessions / selectCount;
      }

      function formatSelectToSuccessPct(row) {
        const ratio = getSelectToSuccessRatio(row);
        return ratio ? (ratio * 100).toFixed(1) + "%" : "";
      }

      function getBillablePlacementCount(placements) {
        if (!placements || typeof placements !== "object") return 0;
        if (typeof placements.successful_placements === "number") {
          return placements.successful_placements;
        }
        if (
          placements.by_termination &&
          typeof placements.by_termination.BILLABLE === "number"
        ) {
          return placements.by_termination.BILLABLE;
        }
        if (typeof placements.total_placements === "number") {
          return placements.total_placements;
        }
        if (typeof placements.total === "number") {
          return placements.total;
        }
        return 0;
      }

      function sanitizeKey(label) {
        return label.toLowerCase().replace(/[^a-z0-9]+/g, "-") || "section";
      }

      const SORT_ACCESSORS = {
        fi: (row) => (row.fi || "").toLowerCase(),
        instances: (row) => (row.instance || (row.instances || []).join(",")).toLowerCase(),
        integration: (row) => (row.integration_type || "").toLowerCase(),
        ga_select: (row) => Number(row.ga_select) || 0,
        ga_user: (row) => Number(row.ga_user) || 0,
        ga_cred: (row) => Number(row.ga_cred) || 0,
        reach: (row) => getMonthlyReachValue(row),
        sel_user_pct: (row) => (row.ga_select ? (row.ga_user || 0) / row.ga_select : 0),
        sel_cred_pct: (row) => (row.ga_select ? (row.ga_cred || 0) / row.ga_select : 0),
        sel_success_pct: (row) => getSelectToSuccessRatio(row),
        sessions: (row) => Number(row.sessions) || 0,
        sess_with_jobs: (row) => Number(row.sess_with_jobs) || 0,
        sess_jobs_pct: (row) => getSessJobsRatio(row),
        sess_with_success: (row) => Number(row.sess_with_success) || 0,
        sess_success_pct: (row) => getSessSuccessRatio(row),
        placements: (row) => Number(row.placements) || 0,
        sources_missing: (row) => (row.sources_missing ? row.sources_missing.length : 0),
        period: (row) => {
          const iso = row.start || row.periodStart || row.period;
          if (iso) return iso.toString().toLowerCase();
          return (row.periodLabel || "").toLowerCase();
        },
      };

      const CSV_COLUMNS = [
        { label: "Section", getter: (row) => row.__section || "" },
        { label: "FI", getter: (row) => row.fi || "" },
        { label: "Partner", getter: (row) => row.partner || "" },
        { label: "Integration", getter: (row) => row.integration_type || "" },
        {
          label: "Instances",
          getter: (row) =>
            row.instance
              ? row.instance
              : Array.isArray(row.instances) && row.instances.length
              ? row.instances.join("; ")
              : "",
        },
        { label: "Period Start", getter: (row) => row.periodStart || row.start || "" },
        { label: "Period End", getter: (row) => row.periodEnd || row.end || "" },
        { label: "GA Select", getter: (row) => row.ga_select || 0 },
        { label: "GA User", getter: (row) => row.ga_user || 0 },
        { label: "GA Cred", getter: (row) => row.ga_cred || 0 },
        {
          label: "Monthly Reach %",
          getter: (row) => formatMonthlyReachPct(row) || "",
        },
        {
          label: "Select→User %",
          getter: (row) =>
            row.ga_select ? (((row.ga_user || 0) / row.ga_select) * 100).toFixed(1) + "%" : "",
        },
        {
          label: "Select→Cred %",
          getter: (row) =>
            row.ga_select ? (((row.ga_cred || 0) / row.ga_select) * 100).toFixed(1) + "%" : "",
        },
        {
          label: "Select→Session Success %",
          getter: (row) => formatSelectToSuccessPct(row) || "",
        },
        { label: "Sessions", getter: (row) => row.sessions || 0 },
        { label: "Sessions w/Jobs", getter: (row) => row.sess_with_jobs || 0 },
        {
          label: "Sessions→Jobs %",
          getter: (row) => formatSessJobsPct(row) || "",
        },
        { label: "Sessions w/Success", getter: (row) => row.sess_with_success || 0 },
        {
          label: "Session Success %",
          getter: (row) => formatSessSuccessPct(row) || "",
        },
        { label: "Placements", getter: (row) => row.placements || 0 },
        {
          label: "Sources Missing",
          getter: (row) => (row.sources_missing || []).join(" | "),
        },
      ];

      function csvEscape(value) {
        if (value === null || value === undefined) return "";
        const str = String(value);
        if (/[",\n]/.test(str)) {
          return `"${str.replace(/"/g, '""')}"`;
        }
        return str;
      }

      function rowToCsvLine(label, row) {
        const rowWithSection = { ...row, __section: label };
        return CSV_COLUMNS.map((col) => csvEscape(col.getter(rowWithSection))).join(",");
      }

      function highlightEntryToRow(entry = {}) {
        const instances =
          Array.isArray(entry.instances) && entry.instances.length
            ? entry.instances
            : entry.instances && typeof entry.instances === "string"
            ? entry.instances.split(",").map((value) => value.trim()).filter(Boolean)
            : entry.instance
            ? [entry.instance]
            : [];
        return {
          fi: entry.fi || "",
          partner: entry.partner || "",
          integration_type: entry.integration || "",
          instances,
          periodStart: entry.start || "",
          periodEnd: entry.end || "",
          ga_select: entry.sel || 0,
          ga_user: entry.user || 0,
          ga_cred: entry.cred || 0,
          sessions: entry.sessions || 0,
          sess_with_jobs: entry.sess_with_jobs || 0,
          sess_with_success: entry.sess_with_success || 0,
          placements: entry.placements || 0,
          sources_missing: entry.sources_missing ? entry.sources_missing.split(" | ") : [],
        };
      }

      function buildTotalsCsvRow(rows, integrationLabel, start, end) {
        const totals = rows.reduce(
          (acc, row) => {
            acc.ga_select += row.ga_select || 0;
            acc.ga_user += row.ga_user || 0;
            acc.ga_cred += row.ga_cred || 0;
            acc.sessions += row.sessions || 0;
            acc.sess_with_jobs += row.sess_with_jobs || 0;
            acc.sess_with_success += row.sess_with_success || 0;
            acc.placements += row.placements || 0;
            acc.cardholders += row.cardholders || 0;
            return acc;
          },
          {
            ga_select: 0,
            ga_user: 0,
            ga_cred: 0,
            sessions: 0,
            sess_with_jobs: 0,
            sess_with_success: 0,
            placements: 0,
            cardholders: 0,
          }
        );
        return {
          fi: "Total",
          partner: rows[0]?.partner || "",
          integration_type: integrationLabel,
          instances: ["—"],
          periodStart: start,
          periodEnd: end,
          ga_select: totals.ga_select,
          ga_user: totals.ga_user,
          ga_cred: totals.ga_cred,
          sessions: totals.sessions,
          sess_with_jobs: totals.sess_with_jobs,
          sess_with_success: totals.sess_with_success,
          placements: totals.placements,
          cardholders: totals.cardholders > 0 ? totals.cardholders : null,
          sources_missing: [],
        };
      }

      function buildCsvDocument({
        summary,
        monthly,
        weekly,
        daily,
        quarterly,
        quarterSummary,
        highlights,
        partnerSummary,
        start,
        end,
      }) {
        const header = CSV_COLUMNS.map((col) => csvEscape(col.label)).join(",");
        const lines = [];
        const title = `Strivve Insights Service Report ${start || ""} → ${end || ""}`.trim();
        lines.push(`"${title}"`, "", "");

        const highlightRows = (highlights || []).filter((h) => h && !h.empty);
        if (highlightRows.length) {
          lines.push("Highlights");
          lines.push(header);
          highlightRows.forEach((entry) => {
            const mapped = highlightEntryToRow(entry);
            lines.push(rowToCsvLine(entry.label || "Highlight", mapped));
          });
          lines.push("", "");
        }

        // Integration buckets (SSO/Non-SSO/etc)
        const summaryRows = summary || [];
        const bucketOrder = ["SSO", "NON-SSO", "CardSavr", "TEST", "UNKNOWN"];
        bucketOrder.forEach((label) => {
          const bucketRows = summaryRows.filter((row) => row.integration_type === label);
          if (!bucketRows.length) return;
          lines.push("", "");
          lines.push(`"${label} Table"`);
          lines.push(header);
          bucketRows.forEach((row) => lines.push(rowToCsvLine(label, row)));
          const totalsRow = buildTotalsCsvRow(bucketRows, label, start, end);
          lines.push(rowToCsvLine(`${label} Total`, totalsRow));
        });

        // Partner integration mix (SSO vs NON-SSO for selected partner)
        if (partnerSummary && partnerSummary.rows && partnerSummary.rows.length) {
          const percentString = (value) =>
            typeof value === "number" && Number.isFinite(value)
              ? value.toFixed(1) + "%"
              : "";
          const partnerHeader = [
            "Integration",
            "FIs",
            "GA Select",
            "Sel→Success %",
            "Sessions",
            "Sessions w/Success",
            "Sessions→Success %",
            "Cardholders",
            "Cardholder Mix %",
            "Monthly Reach %",
          ]
            .map(csvEscape)
            .join(",");
          lines.push("", "");
          lines.push(`${partnerSummary.partner} Integration Mix`);
          lines.push(partnerHeader);
          partnerSummary.rows.forEach((row) => {
            const values = [
              row.integration,
              row.fiCount,
              row.ga_select,
              percentString(row.selSuccessPct),
              row.sessions,
              row.sess_with_success,
              percentString(row.sessionSuccessPct),
              row.cardholders,
              percentString(row.cardholderMixPct),
              percentString(row.reachPct),
            ];
            lines.push(values.map(csvEscape).join(","));
          });
          const totals = partnerSummary.totals || {};
          const totalValues = [
            totals.integration || "Total",
            totals.fiCount || 0,
            totals.ga_select || 0,
            percentString(totals.selSuccessPct),
            totals.sessions || 0,
            totals.sess_with_success || 0,
            percentString(totals.sessionSuccessPct),
            totals.cardholders || 0,
            percentString(totals.cardholderMixPct),
            percentString(totals.reachPct),
          ];
          lines.push(totalValues.map(csvEscape).join(","));
        }

        // Quarterly rollups (multi-FI when last4q)
        if (quarterSummary && quarterSummary.rows && quarterSummary.rows.length) {
          const pct = (n, d) => (d ? ((n / d) * 100).toFixed(1) + "%" : "—");
          lines.push("", "");
          lines.push(`"Quarterly (past 4 quarters)"`);
          lines.push(
            [
              "Quarter",
              "Dates",
              "GA select",
              "GA user",
              "GA cred",
              "Sessions",
              "Sessions w/success",
              "sess→success %",
              "Placements",
              "Cardholders",
            ]
              .map(csvEscape)
              .join(",")
          );
          quarterSummary.rows.forEach((row) => {
            const t = row.totals || {};
            const rangeLabel = row.start === row.end ? row.start : `${row.start} → ${row.end}`;
            lines.push(
              [
                row.label,
                rangeLabel,
                t.ga_select || 0,
                t.ga_user || 0,
                t.ga_cred || 0,
                t.sessions || 0,
                t.sess_with_success || 0,
                pct(t.sess_with_success, t.sessions),
                t.placements || 0,
                t.cardholders || 0,
              ]
                .map(csvEscape)
                .join(",")
            );
          });
          const tot = quarterSummary.total || {};
          lines.push(
            [
              "4Q total",
              "aggregate",
              tot.ga_select || 0,
              tot.ga_user || 0,
              tot.ga_cred || 0,
              tot.sessions || 0,
              tot.sess_with_success || 0,
              ((tot.sess_with_success && tot.sessions)
                ? ((tot.sess_with_success / tot.sessions) * 100).toFixed(1) + "%"
                : "—"),
              tot.placements || 0,
              tot.cardholders || 0,
            ]
              .map(csvEscape)
              .join(",")
          );
        }

        const appendSection = (labelText, rows) => {
          if (!rows || !rows.length) return;
          lines.push("", "");
          lines.push(`"${labelText}"`);
          lines.push(header);
          rows.forEach((row) => lines.push(rowToCsvLine(labelText, row)));
        };

        appendSection("Quarterly Rollups", quarterly);
        appendSection("Monthly Rollups", monthly);
        appendSection("Weekly Rollups", weekly);
        appendSection("Daily Rollups", daily);

        return lines.join("\n");
      }

      function downloadCsv(filename, contents) {
        const blob = new Blob([contents], { type: "text/csv;charset=utf-8" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(() => URL.revokeObjectURL(url), 0);
      }

      const CRC_TABLE = (() => {
        const table = new Uint32Array(256);
        for (let i = 0; i < 256; i++) {
          let c = i;
          for (let k = 0; k < 8; k++) {
            c = (c & 1) ? 0xedb88320 ^ (c >>> 1) : c >>> 1;
          }
          table[i] = c >>> 0;
        }
        return table;
      })();

      function crc32(buf) {
        let crc = -1;
        for (let i = 0; i < buf.length; i++) {
          crc = (crc >>> 8) ^ CRC_TABLE[(crc ^ buf[i]) & 0xff];
        }
        return (crc ^ -1) >>> 0;
      }

      function encodeUtf8(str) {
        return new TextEncoder().encode(str);
      }

      function getDosDateTime(date = new Date()) {
        const year = date.getFullYear();
        const month = date.getMonth() + 1;
        const day = date.getDate();
        const hours = date.getHours();
        const minutes = date.getMinutes();
        const seconds = Math.floor(date.getSeconds() / 2);
        const dosDate = ((year - 1980) << 9) | (month << 5) | day;
        const dosTime = (hours << 11) | (minutes << 5) | seconds;
        return { dosDate, dosTime };
      }

      function buildZip(files) {
        const parts = [];
        const central = [];
        let offset = 0;
        const { dosDate, dosTime } = getDosDateTime();

        files.forEach(({ name, content }) => {
          const nameBytes = encodeUtf8(name);
          const dataBytes = typeof content === "string" ? encodeUtf8(content) : content;
          const crc = crc32(dataBytes);
          const size = dataBytes.length;

          const localHeader = new Uint8Array(30 + nameBytes.length);
          const view = new DataView(localHeader.buffer);
          view.setUint32(0, 0x04034b50, true);
          view.setUint16(4, 20, true); // version needed
          view.setUint16(6, 0, true); // flags
          view.setUint16(8, 0, true); // compression = 0 (store)
          view.setUint16(10, dosTime, true);
          view.setUint16(12, dosDate, true);
          view.setUint32(14, crc, true);
          view.setUint32(18, size, true);
          view.setUint32(22, size, true);
          view.setUint16(26, nameBytes.length, true);
          view.setUint16(28, 0, true); // extra length
          localHeader.set(nameBytes, 30);

          parts.push(localHeader, dataBytes);

          const centralHeader = new Uint8Array(46 + nameBytes.length);
          const cview = new DataView(centralHeader.buffer);
          cview.setUint32(0, 0x02014b50, true);
          cview.setUint16(4, 0x14, true); // version made by
          cview.setUint16(6, 20, true);
          cview.setUint16(8, 0, true);
          cview.setUint16(10, 0, true);
          cview.setUint16(12, dosTime, true);
          cview.setUint16(14, dosDate, true);
          cview.setUint32(16, crc, true);
          cview.setUint32(20, size, true);
          cview.setUint32(24, size, true);
          cview.setUint16(28, nameBytes.length, true);
          cview.setUint16(30, 0, true);
          cview.setUint16(32, 0, true);
          cview.setUint16(34, 0, true);
          cview.setUint16(36, 0, true);
          cview.setUint32(38, 0, true); // external attrs
          cview.setUint32(42, offset, true);
          centralHeader.set(nameBytes, 46);
          central.push(centralHeader);

          offset += localHeader.length + dataBytes.length;
        });

        const centralSize = central.reduce((sum, entry) => sum + entry.length, 0);
        const centralOffset = offset;
        parts.push(...central);

        const end = new Uint8Array(22);
        const eview = new DataView(end.buffer);
        eview.setUint32(0, 0x06054b50, true);
        eview.setUint16(4, 0, true);
        eview.setUint16(6, 0, true);
        eview.setUint16(8, files.length, true);
        eview.setUint16(10, files.length, true);
        eview.setUint32(12, centralSize, true);
        eview.setUint32(16, centralOffset, true);
        eview.setUint16(20, 0, true);
        parts.push(end);

        const total = parts.reduce((sum, part) => sum + part.length, 0);
        const output = new Uint8Array(total);
        let cursor = 0;
        parts.forEach((part) => {
          output.set(part, cursor);
          cursor += part.length;
        });
        return output;
      }

      function downloadZip(filename, files) {
        const zipData = buildZip(files);
        const blob = new Blob([zipData], { type: "application/zip" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(() => URL.revokeObjectURL(url), 0);
      }

      function getSortState(tableId, scope = "multi") {
        const store = scope === "single" ? tableSortState.single : tableSortState.multi;
        if (!store[tableId]) {
          store[tableId] = scope === "single"
            ? { column: "period", direction: "asc" }
            : { ...DEFAULT_SORT };
        }
        return store[tableId];
      }

      function sortRowsForTable(rows, tableId, scope = "multi") {
        const state = getSortState(tableId, scope);
        const accessor = SORT_ACCESSORS[state.column] || SORT_ACCESSORS.sessions;
        const direction = state.direction === "asc" ? 1 : -1;
        return rows.slice().sort((a, b) => {
          const va = accessor(a);
          const vb = accessor(b);
          if (typeof va === "string" || typeof vb === "string") {
            return va.localeCompare(vb) * direction;
          }
          return (va - vb) * direction;
        });
      }

      function handleSortClick(tableId, column, scope = "multi") {
        const state = getSortState(tableId, scope);
        if (state.column === column) {
          state.direction = state.direction === "asc" ? "desc" : "asc";
        } else {
          state.column = column;
          state.direction = column === "fi" || column === "instances" || column === "integration" || column === "period" ? "asc" : "desc";
        }
        rerenderFromCache();
      }

      function attachSortHandlers(table, tableId, scope = "multi") {
        if (!table || table.dataset.sortHandlerAttached === "true") return;
        table.addEventListener("click", (event) => {
          const th = event.target.closest("th[data-sort-key]");
          if (!th || !table.contains(th)) return;
          event.preventDefault();
          const key = th.dataset.sortKey;
          if (!key) return;
          handleSortClick(tableId, key, scope);
        });
        table.dataset.sortHandlerAttached = "true";
        table.querySelectorAll("th[data-sort-key]").forEach((th) => {
          th.style.cursor = "pointer";
        });
      }
      function dayCountInclusive(start, end) {
        if (!start || !end) return null;
        const startDt = parseDateUtc(start);
        const endDt = parseDateUtc(end);
        const diff = Math.floor((endDt - startDt) / (1000 * 60 * 60 * 24));
        return diff >= 0 ? diff + 1 : null;
      }

      function buildDailyRowsForFi(fiName, startDate, endDate, meta) {
        const norm = normalizeFiKey(fiName);
        const rows = [];
        const dates = Object.keys(dailyData).sort();
        for (const date of dates) {
          if (!inRange(date, startDate, endDate)) continue;
          const day = dailyData[date];
          if (!day?.fi) continue;
          let fiEntry = null;
          for (const [name, data] of Object.entries(day.fi)) {
            if (normalizeFiKey(name) === norm) {
              fiEntry = data;
              break;
            }
          }
          if (!fiEntry) continue;
          const ga = fiEntry.ga || {};
          const sessions = fiEntry.sessions || {};
          const placements = fiEntry.placements || {};
          const missingSources = [];
          if (!day.sources?.ga) missingSources.push(`${date}: GA`);
          if (!day.sources?.sis_sessions) missingSources.push(`${date}: Sess`);
          if (!day.sources?.sis_placements) missingSources.push(`${date}: CPR`);
          rows.push({
            periodLabel: date,
            start: date,
            end: date,
            ga_select: ga.select_merchants || 0,
            ga_user: ga.user_data_collection || 0,
            ga_cred: ga.credential_entry || 0,
            sessions: sessions.total || 0,
            sess_with_jobs: sessions.with_jobs || 0,
            sess_with_success: sessions.with_success || 0,
            placements: getBillablePlacementCount(placements),
            sources_missing: missingSources,
            fi: meta.fi,
            instance: meta.instance,
            instances: meta.instances,
            integration_type: meta.integration,
            partner: meta.partner || "",
            cardholders: meta.cardholders,
            cardholder_source: meta.cardholder_source || null,
            cardholder_as_of: meta.cardholder_as_of || null,
            dayCount: 1,
          });
        }
        return rows;
      }

      function aggregateRowsForPeriod(rows, label, start, end, meta) {
        if (!rows.length) return null;
        const sourcesSet = new Set();
        const agg = {
          periodLabel: label,
          start,
          end,
          ga_select: 0,
          ga_user: 0,
          ga_cred: 0,
          sessions: 0,
          sess_with_jobs: 0,
          sess_with_success: 0,
          placements: 0,
          sources_missing: [],
          fi: meta.fi,
          instance: meta.instance,
          instances: meta.instances,
          integration_type: meta.integration,
          partner: meta.partner || "",
          cardholders: meta.cardholders,
          cardholder_source: meta.cardholder_source || null,
          cardholder_as_of: meta.cardholder_as_of || null,
          dayCount: dayCountInclusive(start, end) || rows.length || 1,
        };

        for (const row of rows) {
          agg.ga_select += row.ga_select || 0;
          agg.ga_user += row.ga_user || 0;
          agg.ga_cred += row.ga_cred || 0;
          agg.sessions += row.sessions || 0;
          agg.sess_with_jobs += row.sess_with_jobs || 0;
          agg.sess_with_success += row.sess_with_success || 0;
          agg.placements += row.placements || 0;
          (row.sources_missing || []).forEach((entry) => sourcesSet.add(entry));
        }
        agg.sources_missing = Array.from(sourcesSet);
        return agg;
      }

      function buildWeeklyRowsForFi(dailyRows, startDate, endDate, meta) {
        const buckets = new Map();
        for (const row of dailyRows) {
          const date = parseDateUtc(row.start);
          const weekStartDate = addDaysUtc(date, -date.getUTCDay());
          const weekEndDate = addDaysUtc(weekStartDate, 6);
          const weekStart = formatDateUtc(weekStartDate);
          const weekEnd = formatDateUtc(weekEndDate);
          if (weekStart < startDate || weekEnd > endDate) continue;
          const key = weekStart;
          if (!buckets.has(key)) {
            buckets.set(key, { start: weekStart, end: weekEnd, rows: [] });
          }
          buckets.get(key).rows.push(row);
        }
        return Array.from(buckets.values())
          .sort((a, b) => a.start.localeCompare(b.start))
          .map((bucket) =>
            aggregateRowsForPeriod(
              bucket.rows,
              `${bucket.start} → ${bucket.end}`,
              bucket.start,
              bucket.end,
              meta
            )
          )
          .filter(Boolean);
      }

      function buildMonthlyRowsForFi(dailyRows, startDate, endDate, meta) {
        const buckets = new Map();
        for (const row of dailyRows) {
          const monthKey = row.start.slice(0, 7);
          const [yearStr, monthStr] = monthKey.split("-");
          const year = Number(yearStr);
          const monthIndex = Number(monthStr) - 1;
          const monthStartDate = new Date(Date.UTC(year, monthIndex, 1));
          const monthEndDate = new Date(Date.UTC(year, monthIndex + 1, 0));
          const monthStart = formatDateUtc(monthStartDate);
          const monthEnd = formatDateUtc(monthEndDate);
          if (monthStart < startDate || monthEnd > endDate) continue;
          if (!buckets.has(monthKey)) {
            buckets.set(monthKey, { start: monthStart, end: monthEnd, rows: [] });
          }
          buckets.get(monthKey).rows.push(row);
        }
        return Array.from(buckets.values())
          .sort((a, b) => a.start.localeCompare(b.start))
          .map((bucket) =>
            aggregateRowsForPeriod(
              bucket.rows,
              `${bucket.start} → ${bucket.end}`,
              bucket.start,
              bucket.end,
              meta
            )
          )
          .filter(Boolean);
      }

      function buildQuarterlyRowsForFi(dailyRows, startDate, endDate, meta) {
        const buckets = new Map();
        for (const row of dailyRows) {
          const date = parseDateUtc(row.start);
          const q = Math.floor(date.getUTCMonth() / 3) + 1;
          const year = date.getUTCFullYear();
          const key = `${year}-Q${q}`;
          const quarterStartDate = new Date(Date.UTC(year, (q - 1) * 3, 1));
          const quarterEndDate = new Date(Date.UTC(year, q * 3, 0));
          const quarterStart = formatDateUtc(quarterStartDate);
          const quarterEnd = formatDateUtc(quarterEndDate);
          if (quarterStart < startDate || quarterEnd > endDate) continue;
          if (!buckets.has(key)) {
            buckets.set(key, { start: quarterStart, end: quarterEnd, label: `Q${q} ${year}`, rows: [] });
          }
          buckets.get(key).rows.push(row);
        }
        return Array.from(buckets.values())
          .sort((a, b) => a.start.localeCompare(b.start))
          .map((bucket) =>
            aggregateRowsForPeriod(bucket.rows, bucket.label, bucket.start, bucket.end, meta)
          )
          .filter(Boolean);
      }

      function startLoading() {
        if (!loadingEl) return;
        let dots = 0;
        loadingEl.style.display = "block";
        loadingEl.textContent = "Loading";
        clearInterval(loadingInterval);
        loadingInterval = setInterval(() => {
          dots = (dots + 1) % 6;
          loadingEl.textContent = "Loading" + ".".repeat(dots || 1);
        }, 400);
      }

      function stopLoading() {
        if (!loadingEl) return;
        clearInterval(loadingInterval);
        loadingInterval = null;
        loadingEl.textContent = "";
        loadingEl.style.display = "none";
      }

      function inRange(date, start, end) {
        if (!date) return false;
        if (start && date < start) return false;
        if (end && date > end) return false;
        return true;
      }

      const INSTANCE_DISPLAY_OVERRIDES = new Map([
        ["digital-onboarding", "digitalonboarding"],
      ]);

      function formatInstanceDisplay(value) {
        if (!value) return "unknown";
        const base = value.toString().trim().toLowerCase().replace(/[\s_]+/g, "-");
        const display = base || "unknown";
        return INSTANCE_DISPLAY_OVERRIDES.get(display) || display;
      }

      function getFiInstanceEntriesForDay(day) {
        if (day?.fi_instances && Object.keys(day.fi_instances).length) {
          return Object.entries(day.fi_instances).map(([key, row]) => {
            const parsed = parseFiInstanceKey(key);
            const instanceDisplay = formatInstanceDisplay(row.instance || parsed.instance);
            const comboKey = key || makeFiInstanceKey(row.fi_lookup_key || parsed.fi, instanceDisplay);
            return {
              key: comboKey,
              fi: row.fi_lookup_key || parsed.fi,
              instance: instanceDisplay,
              row,
            };
          });
        }
        if (!day?.fi) return [];
        return Object.entries(day.fi).map(([fiName, row]) => {
          const instances = Array.isArray(row.ga_instances) && row.ga_instances.length
            ? row.ga_instances
            : ["unknown"];
          const instanceDisplay = formatInstanceDisplay(instances[0]);
          const comboKey = makeFiInstanceKey(fiName, instanceDisplay);
          return {
            key: comboKey,
            fi: fiName,
            instance: instanceDisplay,
            row,
          };
        });
      }

      function aggregateData(startDate, endDate, cardholderMap) {
        const perFi = {};
        const dates = Object.keys(dailyData).sort();

        for (const date of dates) {
          if (!inRange(date, startDate, endDate)) continue;
          const day = dailyData[date];
          if (!day?.fi) continue;

          const missingSources = [];
          if (!day.sources?.ga) missingSources.push("GA");
          if (!day.sources?.sis_sessions) missingSources.push("Sess");
          if (!day.sources?.sis_placements) missingSources.push("CPR");

          const entries = getFiInstanceEntriesForDay(day);
          for (const entry of entries) {
            const fiName = entry.fi || "unknown_fi";
            const instanceName = entry.instance || "unknown";
            const fiNorm = normalizeFiKey(fiName);
            const comboKey = entry.key || makeFiInstanceKey(fiNorm, instanceName);
            const registryEntry = getRegistryEntry(fiName, instanceName);
            const row = entry.row || {};
            const rowIsTest = Boolean(row.is_test);
            const baseIntegration = normalizeIntegrationLabel(
              registryEntry?.integration || registryEntry?.integration_type
            );
            const integration = rowIsTest ? "TEST" : baseIntegration;
            const partnerLabel = formatPartnerLabel(registryEntry?.partner);
            const agg =
              perFi[comboKey] || {
                key: comboKey,
                fi: fiName,
                instance: instanceName,
                integration_type: integration,
                partner: partnerLabel,
                ga_select: 0,
                ga_user: 0,
                ga_cred: 0,
                sessions: 0,
                sess_with_jobs: 0,
                sess_with_success: 0,
                placements: 0,
                sources_missing: [],
                instances: [instanceName],
                is_test: rowIsTest,
                cardholders: null,
                cardholder_source: null,
                cardholder_as_of: null,
              };

            agg.integration_type = integration;
            agg.is_test = agg.is_test || rowIsTest;
            const existingInstanceKey = normalizeInstanceKey(agg.instance);
            const incomingInstanceKey = normalizeInstanceKey(instanceName);
            if (
              agg.instance === "unknown" ||
              (existingInstanceKey === incomingInstanceKey &&
                agg.instance.indexOf("-") === -1 &&
                instanceName.indexOf("-") !== -1)
            ) {
              agg.instance = instanceName;
            }
            const alreadyListed = agg.instances.some(
              (value) => normalizeInstanceKey(value) === incomingInstanceKey
            );
            if (!alreadyListed) {
              agg.instances.push(instanceName);
            }

            if (row.ga) {
              agg.ga_select += row.ga.select_merchants || 0;
              agg.ga_user += row.ga.user_data_collection || 0;
              agg.ga_cred += row.ga.credential_entry || 0;
            }
            if (row.sessions) {
              agg.sessions += row.sessions.total || 0;
              agg.sess_with_jobs += row.sessions.with_jobs || 0;
              agg.sess_with_success += row.sessions.with_success || 0;
            }
            if (row.placements) {
              agg.placements += getBillablePlacementCount(row.placements);
            }
            if (rowIsTest) {
              agg.is_test = true;
            }

            const cardholders = cardholderMap[fiNorm];
            if (typeof cardholders === "number" && cardholders > 0) {
              agg.cardholders = cardholders;
              agg.cardholder_source = "manual";
              agg.cardholder_as_of = null;
            } else {
              const registryInfo = getRegistryCardholderInfo(fiName, instanceName);
              if (registryInfo?.total) {
                agg.cardholders = registryInfo.total;
                agg.cardholder_source = registryInfo.source || null;
                agg.cardholder_as_of = registryInfo.as_of || null;
              }
            }
            if (!agg.partner || agg.partner === "Unknown") {
              agg.partner = partnerLabel;
            }

            if (missingSources.length) {
              agg.sources_missing.push({ date, missing: [...missingSources] });
            }

            perFi[comboKey] = agg;
          }
        }

        for (const agg of Object.values(perFi)) {
          const registryInfo = getRegistryEntry(agg.fi, agg.instance);
          const derivedIntegration =
            registryInfo?.integration || registryInfo?.integration_type || agg.integration_type;
          const instanceKey = normalizeInstanceKey(agg.instance);
          let normalized = agg.is_test ? "TEST" : normalizeIntegrationLabel(derivedIntegration);
          if (instanceKey === "ondot" && normalized !== "TEST") {
            normalized = "CardSavr";
          }
          agg.integration_type = normalized;
        }

        return perFi;
      }

      function computeBestWindows(
        startDate,
        endDate,
        perFiLookup = {},
        visibleRows = [],
        monthlyFactor = 1,
        options = {}
      ) {
        const dates = Object.keys(dailyData)
          .filter((d) => inRange(d, startDate, endDate))
          .sort();
        if (!dates.length) return [];
        const allowLowVolume = Boolean(options.allowLowVolume);

        const allowedSet = new Set(
          visibleRows.map((row) => row.key || makeFiInstanceKey(normalizeFiKey(row.fi), normalizeInstanceKey(row.instance)))
        );
        const restrict = allowedSet.size > 0;
        const dayMissingMap = {};
        const fiDaily = {};
        for (const date of dates) {
          const day = dailyData[date];
          if (!day?.fi) continue;
          const missingSources = [];
          if (!day.sources?.ga) missingSources.push("GA");
          if (!day.sources?.sis_sessions) missingSources.push("Sess");
          if (!day.sources?.sis_placements) missingSources.push("CPR");
          dayMissingMap[date] = missingSources;
          const entries = getFiInstanceEntriesForDay(day);
          for (const entry of entries) {
            const fiDay = entry.row;
            const comboKey = entry.key || makeFiInstanceKey(entry.fi, entry.instance);
            const ga = fiDay.ga || {};
            if (!fiDaily[comboKey]) {
              fiDaily[comboKey] = {};
            }
            fiDaily[comboKey][date] = {
              select: ga.select_merchants || 0,
              user: ga.user_data_collection || 0,
              cred: ga.credential_entry || 0,
              sessions: fiDay.sessions?.total || 0,
              sess_with_jobs: fiDay.sessions?.with_jobs || 0,
              sess_with_success: fiDay.sessions?.with_success || 0,
              placements: getBillablePlacementCount(fiDay.placements),
            };
          }
        }

        const perFiByKey = {};
        Object.entries(perFiLookup || {}).forEach(([key, data]) => {
          perFiByKey[key] = data;
          if (data && data.fi) {
            const combo = data.key || makeFiInstanceKey(data.fi, data.instance);
            if (!perFiByKey[combo]) {
              perFiByKey[combo] = data;
            }
          }
        });

        const defaultCompare = (cand, best) => {
          if (cand.sessionSuccessRatio !== best.sessionSuccessRatio) {
            return cand.sessionSuccessRatio - best.sessionSuccessRatio;
          }
          if (cand.sel !== best.sel) {
            return cand.sel - best.sel;
          }
          return cand.sessions - best.sessions;
        };

        const windows = [
          {
            label: "Most Select Merchant Loads",
            len: 7,
            minSelects: MIN_SELECTS,
            minSessions: 0,
            compare: (cand, best) => {
              if (cand.sel !== best.sel) return cand.sel - best.sel;
              if (cand.sessionSuccessRatio !== best.sessionSuccessRatio) {
                return cand.sessionSuccessRatio - best.sessionSuccessRatio;
              }
              return cand.sessions - best.sessions;
            },
          },
          {
            label: "Most Select Merchant Loads with Successful Placements",
            len: 7,
            minSelects: 25,
            minSessions: 14,
            compare: (cand, best) => {
              if (cand.selSuccessRatio !== best.selSuccessRatio) {
                return cand.selSuccessRatio - best.selSuccessRatio;
              }
              if (cand.sel !== best.sel) return cand.sel - best.sel;
              return cand.sessions - best.sessions;
            },
          },
          {
            label: "Most Total Sessions",
            len: 7,
            minSelects: MIN_SELECTS,
            minSessions: MIN_SELECTS,
            compare: (cand, best) => {
              if (cand.sessions !== best.sessions) return cand.sessions - best.sessions;
              if (cand.sessionSuccessRatio !== best.sessionSuccessRatio) {
                return cand.sessionSuccessRatio - best.sessionSuccessRatio;
              }
              return cand.sel - best.sel;
            },
          },
          {
            label: "Highest Sessions with Success %",
            len: 7,
            minSelects: MIN_SELECTS,
            minSessions: MIN_SELECTS,
            compare: (cand, best) => {
              if (cand.sess_with_success !== best.sess_with_success) {
                return cand.sess_with_success - best.sess_with_success;
              }
              if (cand.sessions !== best.sessions) return cand.sessions - best.sessions;
              return cand.sel - best.sel;
            },
          },
        ];

        const results = [];

        for (const config of windows) {
          const { label, len } = config;
          if (dates.length < len) {
            results.push({ label, empty: true });
            continue;
          }
          const compareFn = typeof config.compare === "function" ? config.compare : defaultCompare;
          const minSelects = allowLowVolume ? 1 : config.minSelects || MIN_SELECTS;
          const minSessions = allowLowVolume ? 1 : config.minSessions || 0;
          let best = null;
          for (const [comboKey, dailyMap] of Object.entries(fiDaily)) {
            if (restrict && !allowedSet.has(comboKey)) continue;
            for (let idx = 0; idx <= dates.length - len; idx += 1) {
              let sel = 0;
              let user = 0;
              let cred = 0;
              let sessions = 0;
              let sessWithJobs = 0;
              let sessWithSuccess = 0;
              let placements = 0;
              const missingEntries = [];
              for (let offset = 0; offset < len; offset += 1) {
                const dayKey = dates[idx + offset];
                const stats = dailyMap[dayKey];
                if (stats) {
                  sel += stats.select || 0;
                  user += stats.user || 0;
                  cred += stats.cred || 0;
                  sessions += stats.sessions || 0;
                  sessWithJobs += stats.sess_with_jobs || 0;
                  sessWithSuccess += stats.sess_with_success || 0;
                  placements += stats.placements || 0;
                }
                const missing = dayMissingMap[dayKey];
                if (missing && missing.length) {
                  missingEntries.push(`${dayKey}: ${missing.join(",")}`);
                }
              }
              if (sel < minSelects) continue;
              if (sessions < minSessions) continue;
              const sessionSuccessRatio = sessions ? sessWithSuccess / sessions : 0;
              const selSuccessRatio = sel ? sessWithSuccess / sel : 0;
              const candidate = {
                label,
                key: comboKey,
                fi: perFiByKey[comboKey]?.fi || comboKey,
                instance: perFiByKey[comboKey]?.instance || parseFiInstanceKey(comboKey).instance,
                start: dates[idx],
                end: dates[idx + len - 1],
                sel,
                user,
                cred,
                conv: sel ? cred / sel : 0,
                successPct: sessionSuccessRatio,
                sessionSuccessRatio,
                selSuccessRatio,
                sessions,
                sess_with_jobs: sessWithJobs,
                sess_with_success: sessWithSuccess,
                placements,
                sources_missing: missingEntries.join(" | "),
              };
              if (!best || compareFn(candidate, best) > 0) {
                best = candidate;
              }
            }
          }
          if (best) {
            const aggRow = perFiByKey[best.key] || {};
            const registryInfo = getRegistryEntry(best.fi, best.instance);
            const registryInstances = registryInfo?.instances || [];
            const instanceList = Array.isArray(aggRow.instances) && aggRow.instances.length
              ? aggRow.instances
              : registryInstances;
            best.instances = instanceList.join(", ") || best.instance || "";
            best.integration = normalizeIntegrationLabel(
              aggRow.integration_type ||
                registryInfo?.integration ||
                registryInfo?.integration_type ||
                "UNKNOWN"
            );
            best.partner = aggRow.partner || registryInfo?.partner || "";
            if (typeof aggRow.cardholders === "number" && aggRow.cardholders > 0) {
              const rowDays = dayCountInclusive(best.start, best.end) || 1;
              const reachBase = best.sel > 0 ? best.sel : best.sessions;
              const reachMonthly = reachBase * (30 / rowDays);
              best.reach = reachMonthly > 0
                ? ((reachMonthly / aggRow.cardholders) * 100).toFixed(1) + "%"
                : "";
            } else {
              best.reach = "";
            }
            best.dayCount = dayCountInclusive(best.start, best.end);
            results.push(best);
          } else {
            results.push({ label, empty: true });
          }
        }

        return results;
      }

      function renderBestWindows(entries, visibleRows) {
        bestWindowsDiv.innerHTML = "";
        if (!visibleRows || !visibleRows.length) {
          const emptyDiv = document.createElement("div");
          emptyDiv.className = "muted";
          emptyDiv.textContent = "No highlights because no FIs match the current filters.";
          bestWindowsDiv.appendChild(emptyDiv);
          return;
        }

        if (!entries || !entries.length) {
          const emptyDiv = document.createElement("div");
          emptyDiv.className = "muted";
          emptyDiv.textContent = `No GA highlights with ≥ ${MIN_SELECTS} select views in this window.`;
          bestWindowsDiv.appendChild(emptyDiv);
          return;
        }

        const table = document.createElement("table");
        table.className = "highlights-table";
        table.innerHTML = `
          <thead>
            <tr>
              <th${columnAttr("highlight")}>Highlight</th>
              <th${columnAttr("fi")}>FI</th>
              <th${columnAttr("instances")}>instances</th>
              <th${columnAttr("integration")}>integration</th>
              <th${columnAttr("dates")}>dates</th>
              <th${columnAttr("ga_select")}>GA select</th>
              <th${columnAttr("ga_user")}>GA user</th>
              <th${columnAttr("ga_cred")}>GA cred</th>
              <th${columnAttr("sel_user_pct")}>sel→user %</th>
              <th${columnAttr("sel_cred_pct")}>sel→cred %</th>
              <th${columnAttr("sel_success_pct")}>sel→success %</th>
              <th${columnAttr("sessions")}>sessions</th>
              <th${columnAttr("sess_with_jobs")}>sess w/jobs</th>
              <th${columnAttr("sess_jobs_pct")}>sess→jobs %</th>
              <th${columnAttr("sess_with_success")}>sess w/success</th>
              <th${columnAttr("sess_success_pct")}>sess→success %</th>
              <th${columnAttr("placements")}>placements</th>
            </tr>
          </thead>
        `;

        const tbody = document.createElement("tbody");
        entries.forEach((entry) => {
          const tr = document.createElement("tr");
          if (entry.empty) {
            tr.innerHTML = `
              <td${columnAttr("highlight")}>${entry.label}</td>
              <td colspan="16" class="muted">No data for this highlight window.</td>
            `;
          } else {
            const convPct = entry.conv ? (entry.conv * 100).toFixed(1) + "%" : "0%";
            const selUserPct = entry.sel
              ? ((entry.user || 0) / entry.sel * 100).toFixed(1) + "%"
              : "";
            const selSuccessPct = typeof entry.selSuccessRatio === "number"
              ? (entry.selSuccessRatio * 100).toFixed(1) + "%"
              : formatSelectToSuccessPct({
                  ga_select: entry.sel,
                  sess_with_success: entry.sess_with_success,
                });
            const sessJobsPct =
              entry.sessions && entry.sess_with_jobs
                ? ((entry.sess_with_jobs / entry.sessions) * 100).toFixed(1) + "%"
                : "";
            const sessSuccessPct = typeof entry.sessionSuccessRatio === "number"
              ? (entry.sessionSuccessRatio * 100).toFixed(1) + "%"
              : "";
            const dateRange = entry.start === entry.end ? entry.start : `${entry.start} → ${entry.end}`;
            tr.innerHTML = `
              <td${columnAttr("highlight")}>${entry.label}</td>
              <td${columnAttr("fi")}>${entry.fi}</td>
              <td${columnAttr("instances")}>${entry.instance || entry.instances || ""}</td>
              <td${columnAttr("integration")}>${entry.integration || ""}</td>
              <td${columnAttr("dates")}>${dateRange}</td>
              <td${columnAttr("ga_select")}>${entry.sel}</td>
              <td${columnAttr("ga_user")}>${entry.user || 0}</td>
              <td${columnAttr("ga_cred")}>${entry.cred}</td>
              <td${columnAttr("sel_user_pct")}>${selUserPct}</td>
              <td${columnAttr("sel_cred_pct")}>${convPct}</td>
              <td${columnAttr("sel_success_pct")}>${selSuccessPct}</td>
              <td${columnAttr("sessions")}>${entry.sessions || 0}</td>
              <td${columnAttr("sess_with_jobs")}>${entry.sess_with_jobs || 0}</td>
              <td${columnAttr("sess_jobs_pct")}>${sessJobsPct}</td>
              <td${columnAttr("sess_with_success")}>${entry.sess_with_success || 0}</td>
              <td${columnAttr("sess_success_pct")}>${sessSuccessPct}</td>
              <td${columnAttr("placements")}>${entry.placements || 0}</td>
            `;
          }
          tbody.appendChild(tr);
        });

        table.appendChild(tbody);
        bestWindowsDiv.appendChild(table);
        applyColumnTitles(bestWindowsDiv);
      }

      function buildPartnerSummaryData(rows = [], daySpan = 0, partnerValue = PARTNER_ALL_VALUE) {
        if (!rows || !rows.length || !partnerValue || partnerValue === PARTNER_ALL_VALUE) {
          return null;
        }
        const relevant = rows.filter((row) => (row.partner || "Unknown") === partnerValue);
        if (!relevant.length) {
          return null;
        }
        const makeBucket = () => ({
          fiCount: 0,
          ga_select: 0,
          sessions: 0,
          sess_with_success: 0,
          placements: 0,
          cardholders: 0,
        });
        const buckets = {
          SSO: makeBucket(),
          "NON-SSO": makeBucket(),
        };
        relevant.forEach((row) => {
          const key =
            row.integration_type === "SSO"
              ? "SSO"
              : row.integration_type === "NON-SSO"
              ? "NON-SSO"
              : null;
          if (!key) return;
          const bucket = buckets[key];
          bucket.ga_select += row.ga_select || 0;
          bucket.sessions += row.sessions || 0;
          bucket.sess_with_success += row.sess_with_success || 0;
          bucket.placements += row.placements || 0;
          if (typeof row.cardholders === "number" && row.cardholders > 0) {
            bucket.cardholders += row.cardholders;
          }
          bucket.fiCount += 1;
        });
        const monthlyFactor = daySpan ? 30 / daySpan : 1;
        const totals = makeBucket();
        const bucketSummaries = Object.entries(buckets).map(([key, bucket]) => {
          bucket.monthlySelect = bucket.ga_select * monthlyFactor;
          bucket.selSuccessPct =
            bucket.ga_select > 0 && bucket.sess_with_success > 0
              ? (bucket.sess_with_success / bucket.ga_select) * 100
              : null;
          bucket.sessionSuccessPct =
            bucket.sessions > 0 && bucket.sess_with_success > 0
              ? (bucket.sess_with_success / bucket.sessions) * 100
              : null;
          bucket.reachPct =
            bucket.cardholders > 0 && bucket.monthlySelect > 0
              ? (bucket.monthlySelect / bucket.cardholders) * 100
              : null;
          totals.ga_select += bucket.ga_select;
          totals.sessions += bucket.sessions;
          totals.sess_with_success += bucket.sess_with_success;
          totals.placements += bucket.placements;
          totals.cardholders += bucket.cardholders;
          totals.fiCount += bucket.fiCount;
          return { key, bucket };
        });
        const totalCardholders = totals.cardholders;
        const rowsOut = bucketSummaries.map(({ key, bucket }) => {
          const cardholderMixPct =
            totalCardholders > 0 && bucket.cardholders > 0
              ? (bucket.cardholders / totalCardholders) * 100
              : null;
          return {
            integration: key,
            fiCount: bucket.fiCount,
            ga_select: bucket.ga_select,
            selSuccessPct: bucket.selSuccessPct,
            sessions: bucket.sessions,
            sess_with_success: bucket.sess_with_success,
            sessionSuccessPct: bucket.sessionSuccessPct,
            cardholders: bucket.cardholders,
            cardholderMixPct,
            reachPct: bucket.reachPct,
          };
        });
        totals.monthlySelect = totals.ga_select * monthlyFactor;
        totals.selSuccessPct =
          totals.ga_select > 0 && totals.sess_with_success > 0
            ? (totals.sess_with_success / totals.ga_select) * 100
            : null;
        totals.sessionSuccessPct =
          totals.sessions > 0 && totals.sess_with_success > 0
            ? (totals.sess_with_success / totals.sessions) * 100
            : null;
        totals.cardholderMixPct = totalCardholders > 0 ? 100 : null;
        totals.reachPct =
          totals.cardholders > 0 && totals.monthlySelect > 0
            ? (totals.monthlySelect / totals.cardholders) * 100
            : null;
        return {
          partner: partnerValue,
          daySpan,
          rows: rowsOut,
          totals: {
            integration: "Total",
            fiCount: totals.fiCount,
            ga_select: totals.ga_select,
            selSuccessPct: totals.selSuccessPct,
            sessions: totals.sessions,
            sess_with_success: totals.sess_with_success,
            sessionSuccessPct: totals.sessionSuccessPct,
            cardholders: totals.cardholders,
            cardholderMixPct: totals.cardholderMixPct,
            reachPct: totals.reachPct,
          },
          instanceCount: relevant.length,
        };
      }

      function renderPartnerSummary(summaryData) {
        if (!partnerSummaryBox) return;
        if (!summaryData) {
          partnerSummaryBox.style.display = "none";
          partnerSummaryBox.innerHTML = "";
          return;
        }
        const formatNumber = (value) =>
          typeof value === "number" && !Number.isNaN(value)
            ? value.toLocaleString("en-US")
            : "0";
        const formatCardholders = (value) =>
          typeof value === "number" && value > 0
            ? value.toLocaleString("en-US")
            : "—";
        const formatPercent = (value) =>
          typeof value === "number" && Number.isFinite(value)
            ? value.toFixed(1) + "%"
            : "—";
        const integrationRows = summaryData.rows
          .map(
            (row) => `
            <tr>
              <td>${row.integration}</td>
              <td>${row.fiCount}</td>
              <td>${formatNumber(row.ga_select)}</td>
              <td>${formatPercent(row.selSuccessPct)}</td>
              <td>${formatNumber(row.sessions)}</td>
              <td>${formatNumber(row.sess_with_success)}</td>
              <td>${formatPercent(row.sessionSuccessPct)}</td>
              <td>${formatCardholders(row.cardholders)}</td>
              <td>${formatPercent(row.cardholderMixPct)}</td>
              <td>${formatPercent(row.reachPct)}</td>
            </tr>`
          )
          .join("");
        const totals = summaryData.totals || {};
        partnerSummaryBox.innerHTML = `
          <h3>${summaryData.partner} integration mix</h3>
          <p>Comparing ${summaryData.instanceCount} FI instances over ${summaryData.daySpan || 0}-day window.</p>
          <table class="partner-summary__table">
            <thead>
              <tr>
                <th>Integration</th>
                <th>FIs</th>
                <th>GA select</th>
                <th>Sel→success %</th>
                <th>Sessions</th>
                <th>Sessions w/success</th>
                <th>Sessions→success %</th>
                <th>Cardholders</th>
                <th>Cardholder mix %</th>
                <th>Monthly reach %</th>
              </tr>
            </thead>
            <tbody>
              ${integrationRows}
            </tbody>
            <tfoot>
              <tr>
                <td>Total</td>
                <td>${totals.fiCount || 0}</td>
                <td>${formatNumber(totals.ga_select || 0)}</td>
                <td>${formatPercent(totals.selSuccessPct)}</td>
                <td>${formatNumber(totals.sessions || 0)}</td>
                <td>${formatNumber(totals.sess_with_success || 0)}</td>
                <td>${formatPercent(totals.sessionSuccessPct)}</td>
                <td>${formatCardholders(totals.cardholders || 0)}</td>
                <td>${formatPercent(totals.cardholderMixPct)}</td>
                <td>${formatPercent(totals.reachPct)}</td>
              </tr>
            </tfoot>
          </table>
        `;
        partnerSummaryBox.style.display = "";
      }
      function renderSingleFiSections(visibleRows, startDate, endDate, daySpan) {
        if (!visibleRows || !visibleRows.length) {
          const div = document.createElement("div");
          div.className = "muted";
          div.textContent = "No data available for this FI.";
          singleFiView.appendChild(div);
          latestSingleFiBreakdowns = null;
          return;
        }

        const shared = window.__FILTER_STATE;
        const sharedFi =
          shared && shared.page === "funnel" && shared.fis && shared.fis.size === 1
            ? Array.from(shared.fis)[0]
            : null;
        const fiName =
          (fiFilterSelect && fiFilterSelect.value && fiFilterSelect.value !== FI_ALL_VALUE
            ? fiFilterSelect.value
            : sharedFi) ||
          (visibleRows[0]?.fi || "Unknown FI");
        const perFiRow = visibleRows[0] || {};
        const norm = normalizeFiKey(fiName);
        const instanceDisplay =
          perFiRow.instance || (perFiRow.instances?.[0]) || shared?.instance || "unknown";
        const registryInfo = getRegistryEntry(fiName, instanceDisplay);
        const meta = {
          fi: fiName,
          instance: instanceDisplay,
          instances: [instanceDisplay],
          integration: normalizeIntegrationLabel(
            perFiRow.integration_type ||
              registryInfo?.integration ||
              registryInfo?.integration_type ||
              "UNKNOWN"
          ),
          partner: perFiRow.partner || registryInfo?.partner || "Unknown",
          cardholders: perFiRow.cardholders,
          cardholder_source: perFiRow.cardholder_source || null,
          cardholder_as_of: perFiRow.cardholder_as_of || null,
        };

        const dailyRows = buildDailyRowsForFi(fiName, startDate, endDate, meta);
        const weeklyRows = buildWeeklyRowsForFi(dailyRows, startDate, endDate, meta);
        const monthlyRows = buildMonthlyRowsForFi(dailyRows, startDate, endDate, meta);
        const quarterlyRows = buildQuarterlyRowsForFi(dailyRows, startDate, endDate, meta);
        latestSingleFiBreakdowns = {
          summary: visibleRows,
          daily: dailyRows,
          weekly: weeklyRows,
          monthly: monthlyRows,
          quarterly: quarterlyRows,
        };

        const sections = [];
        sections.push({
          key: "summary",
          title: `Summary (${startDate} → ${endDate})`,
          rows: visibleRows,
        });

        if (quarterlyRows.length) {
          sections.push({
            key: "quarterly",
            title: "Quarterly",
            rows: quarterlyRows,
          });
        }

        if (monthlyRows.length) {
          sections.push({
            key: "monthly",
            title: "Monthly (Full Calendar Months)",
            rows: monthlyRows,
          });
        }

        if (weeklyRows.length) {
          sections.push({
            key: "weekly",
            title: "Weekly (Sunday → Saturday)",
            rows: weeklyRows,
          });
        }

        if (dailyRows.length) {
          sections.push({ key: "daily", title: "Daily", rows: dailyRows });
        }

        const availableSections = sections.filter((section) => section.rows && section.rows.length);
        if (!availableSections.length) {
          const div = document.createElement("div");
          div.className = "muted";
          div.textContent = "No full periods available for this FI within the selected dates.";
          singleFiView.appendChild(div);
          return;
        }

        const tabBar = document.createElement("div");
        tabBar.className = "tab-bar";
        const panelsWrap = document.createElement("div");

        availableSections.forEach((section, idx) => {
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = `tab-button ${idx === 0 ? "active" : ""}`;
          btn.dataset.tab = section.key;
          btn.textContent = section.title;
          tabBar.appendChild(btn);

          const panel = document.createElement("div");
          panel.className = `tab-panel ${idx === 0 ? "active" : ""}`;
          panel.dataset.tab = section.key;
          const heading = document.createElement("h3");
          heading.textContent = section.title;
          panel.appendChild(heading);
          panel.appendChild(createSingleFiTable(section.rows, section.key));
          panelsWrap.appendChild(panel);
        });

        const activateTab = (key) => {
          tabBar.querySelectorAll(".tab-button").forEach((btn) => {
            btn.classList.toggle("active", btn.dataset.tab === key);
          });
          panelsWrap.querySelectorAll(".tab-panel").forEach((panel) => {
            panel.classList.toggle("active", panel.dataset.tab === key);
          });
        };

        tabBar.addEventListener("click", (ev) => {
          const btn = ev.target.closest(".tab-button");
          if (!btn) return;
          activateTab(btn.dataset.tab);
        });

        singleFiView.appendChild(tabBar);
        singleFiView.appendChild(panelsWrap);
        activateTab(availableSections[0].key);
        applyColumnTitles(singleFiView);
      }

      function createSingleFiTable(rows, key) {
        const table = document.createElement("table");
        table.innerHTML = `
          <thead>
            <tr>
              <th data-sort-key="period"${columnAttr("period")}>Period</th>
              <th data-sort-key="fi"${columnAttr("fi")}>FI</th>
              <th data-sort-key="instances"${columnAttr("instances")}>instances</th>
              <th data-sort-key="integration"${columnAttr("integration")}>integration</th>
              <th data-sort-key="ga_select"${columnAttr("ga_select")}>GA select</th>
              <th data-sort-key="ga_user"${columnAttr("ga_user")}>GA user</th>
              <th data-sort-key="ga_cred"${columnAttr("ga_cred")}>GA cred</th>
              <th data-sort-key="reach"${columnAttr("reach")}>monthly reach %</th>
              <th data-sort-key="sel_user_pct"${columnAttr("sel_user_pct")}>sel→user %</th>
              <th data-sort-key="sel_cred_pct"${columnAttr("sel_cred_pct")}>sel→cred %</th>
              <th data-sort-key="sel_success_pct"${columnAttr("sel_success_pct")}>sel→success %</th>
              <th data-sort-key="sessions"${columnAttr("sessions")}>sessions</th>
              <th data-sort-key="sess_with_jobs"${columnAttr("sess_with_jobs")}>sess w/jobs</th>
              <th data-sort-key="sess_jobs_pct"${columnAttr("sess_jobs_pct")}>sess→jobs %</th>
              <th data-sort-key="sess_with_success"${columnAttr("sess_with_success")}>sess w/success</th>
              <th data-sort-key="sess_success_pct"${columnAttr("sess_success_pct")}>sess→success %</th>
              <th data-sort-key="placements"${columnAttr("placements")}>placements</th>
              <th data-sort-key="sources_missing"${columnAttr("sources_missing")}>sources missing</th>
            </tr>
          </thead>
        `;
        const tbody = document.createElement("tbody");
        const tableId = `single-${sanitizeKey(key)}`;
        const sortedRows = sortRowsForTable(rows, tableId, "single");
        sortedRows.forEach((row) => {
          tbody.appendChild(renderSingleFiRow(row));
        });
        table.appendChild(tbody);
        table.id = tableId;
        attachSortHandlers(table, tableId, "single");
        return table;
      }

      function renderSingleFiRow(row) {
        const tr = document.createElement("tr");
        tr.dataset.fi = row.fi || "";
        tr.dataset.partner = row.partner || "Unknown";
        tr.dataset.integration = row.integration_type || "";
        tr.dataset.instance = row.instance || (Array.isArray(row.instances) ? row.instances[0] : "");
        const selUserPct = row.ga_select
          ? ((row.ga_user / row.ga_select) * 100).toFixed(1) + "%"
          : "";
        const selCredPct = row.ga_select
          ? ((row.ga_cred / row.ga_select) * 100).toFixed(1) + "%"
          : "";
        const selSuccessPct = formatSelectToSuccessPct(row);
        const reachPct = formatMonthlyReachPct(row);
        const sessJobsPct = formatSessJobsPct(row);
        const sessSuccessPct = formatSessSuccessPct(row);
        const instancesText = row.instance
          ? row.instance
          : Array.isArray(row.instances) && row.instances.length
          ? row.instances.join(", ")
          : "";
        const missing = (row.sources_missing || []).join(" | ");
        tr.innerHTML = `
          <td${columnAttr("period")}>${row.periodLabel}</td>
          <td${columnAttr("fi")}>${row.fi}</td>
          <td${columnAttr("instances")}>${instancesText}</td>
          <td${columnAttr("integration")}>${row.integration_type || ""}</td>
          <td${columnAttr("ga_select")}>${row.ga_select}</td>
          <td${columnAttr("ga_user")}>${row.ga_user}</td>
          <td${columnAttr("ga_cred")}>${row.ga_cred}</td>
          <td${columnAttr("reach")}>${reachPct}</td>
          <td${columnAttr("sel_user_pct")}>${selUserPct}</td>
          <td${columnAttr("sel_cred_pct")}>${selCredPct}</td>
          <td${columnAttr("sel_success_pct")}>${selSuccessPct}</td>
          <td${columnAttr("sessions")}>${row.sessions || 0}</td>
          <td${columnAttr("sess_with_jobs")}>${row.sess_with_jobs || 0}</td>
          <td${columnAttr("sess_jobs_pct")}>${sessJobsPct}</td>
          <td${columnAttr("sess_with_success")}>${row.sess_with_success || 0}</td>
          <td${columnAttr("sess_success_pct")}>${sessSuccessPct}</td>
          <td${columnAttr("placements")}>${row.placements || 0}</td>
          <td${columnAttr("sources_missing")}>${missing}</td>
        `;
        return tr;
      }

      function renderTables(visibleRows, startDate, endDate, daySpan) {
        startLoading();
        latestVisibleRows = visibleRows.slice();
        const monthlyFactor = 30 / Math.max(daySpan || 1, 1);
        visibleRows.forEach((row) => {
          row.periodStart = startDate;
          row.periodEnd = endDate;
          row.dayCount = row.dayCount || daySpan;
        });
        const singleFiMode = isSingleFiSelected();
        const shared = window.__FILTER_STATE;
        const partnerValue =
          shared && shared.page === "funnel"
            ? shared.partner || PARTNER_ALL_VALUE
            : partnerSelect?.value || PARTNER_ALL_VALUE;
        latestPartnerSummary = !singleFiMode
          ? buildPartnerSummaryData(visibleRows, daySpan, partnerValue)
          : null;
        renderPartnerSummary(latestPartnerSummary);

        // Quarter summary when past 4 quarters preset is selected
        const presetVal = document.getElementById("datePreset")?.value || "";
        if (presetVal === "last4q") {
          const ranges = buildLast4QuarterRanges(endDate);
          latestQuarterSummary = summarizeQuarterRanges(ranges, includeTests, cardholderMap);
          renderQuarterSummary(latestQuarterSummary);
        } else {
          latestQuarterSummary = null;
          renderQuarterSummary(null);
        }
        latestSingleFiBreakdowns = null;
        if (singleFiMode) {
          singleFiView.style.display = "";
          multiFiView.style.display = "none";
          singleFiView.innerHTML = "";
          totalsBar.style.display = "none";
          renderSingleFiSections(visibleRows, startDate, endDate, daySpan);
          return;
        }

        singleFiView.style.display = "none";
        singleFiView.innerHTML = "";
        multiFiView.style.display = "";

        Object.values(tableBodies).forEach((tbody) => {
          tbody.innerHTML = "";
        });

        const bucketed = {
          SSO: [],
          "NON-SSO": [],
          CardSavr: [],
          TEST: [],
          UNKNOWN: [],
        };
        visibleRows.forEach((row) => {
            const integration = row.integration_type || "UNKNOWN";
          const normalizedIntegration = normalizeIntegrationLabel(integration);
          row.integration_type = normalizedIntegration;
          const bucketKey = bucketed[normalizedIntegration]
            ? normalizedIntegration
            : "UNKNOWN";
          bucketed[bucketKey].push(row);
        });

        const sumMetrics = (rows) =>
          rows.reduce(
            (acc, row) => {
              acc.ga_select += row.ga_select || 0;
              acc.ga_user += row.ga_user || 0;
              acc.ga_cred += row.ga_cred || 0;
              acc.sessions += row.sessions || 0;
              acc.sess_with_jobs += row.sess_with_jobs || 0;
              acc.sess_with_success += row.sess_with_success || 0;
              acc.placements += row.placements || 0;
              return acc;
            },
            {
              ga_select: 0,
              ga_user: 0,
              ga_cred: 0,
              sessions: 0,
              sess_with_jobs: 0,
              sess_with_success: 0,
              placements: 0,
            }
          );

        const buildTotalsRow = (rows, integration) => {
          if (!rows.length) return null;
          const totals = sumMetrics(rows);
          const selUserPct = totals.ga_select
            ? ((totals.ga_user / totals.ga_select) * 100).toFixed(1) + "%"
            : "";
          const selCredPct = totals.ga_select
            ? ((totals.ga_cred / totals.ga_select) * 100).toFixed(1) + "%"
            : "";
          const selSuccessPct = totals.ga_select
            ? ((totals.sess_with_success / totals.ga_select) * 100).toFixed(1) + "%"
            : "";
          const sessJobsPct = totals.sessions
            ? ((totals.sess_with_jobs / totals.sessions) * 100).toFixed(1) + "%"
            : "";
          const sessSuccessPct = totals.sessions
            ? ((totals.sess_with_success / totals.sessions) * 100).toFixed(1) + "%"
            : "";
          const reachPct = "";
          const tr = document.createElement("tr");
          tr.className = "totals-row";
          tr.innerHTML = `
            <td${columnAttr("fi")}>Total</td>
            <td${columnAttr("instances")}>—</td>
            <td${columnAttr("integration")}>${integration}</td>
            <td${columnAttr("ga_select")}>${totals.ga_select}</td>
            <td${columnAttr("ga_user")}>${totals.ga_user}</td>
            <td${columnAttr("ga_cred")}>${totals.ga_cred}</td>
            <td${columnAttr("reach")}>${reachPct}</td>
            <td${columnAttr("sel_user_pct")}>${selUserPct}</td>
            <td${columnAttr("sel_cred_pct")}>${selCredPct}</td>
            <td${columnAttr("sel_success_pct")}>${selSuccessPct}</td>
            <td${columnAttr("sessions")}>${totals.sessions}</td>
            <td${columnAttr("sess_with_jobs")}>${totals.sess_with_jobs}</td>
            <td${columnAttr("sess_jobs_pct")}>${sessJobsPct}</td>
            <td${columnAttr("sess_with_success")}>${totals.sess_with_success}</td>
            <td${columnAttr("sess_success_pct")}>${sessSuccessPct}</td>
            <td${columnAttr("placements")}>${totals.placements}</td>
            <td${columnAttr("sources_missing")}></td>
          `;
          return tr;
        };

        const renderRow = (row, integration) => {
          const instancesText = row.instance
            ? row.instance
            : Array.isArray(row.instances) && row.instances.length
            ? row.instances.join(", ")
            : "";
          const selUserPct = row.ga_select
            ? ((row.ga_user / row.ga_select) * 100).toFixed(1) + "%"
            : "";
          const selCredPct = row.ga_select
            ? ((row.ga_cred / row.ga_select) * 100).toFixed(1) + "%"
            : "";
          const selSuccessPct = formatSelectToSuccessPct(row);
          const reachPct = formatMonthlyReachPct(row);
          const sessJobsPct = formatSessJobsPct(row);
          const sessSuccessPct = formatSessSuccessPct(row);

          const missing = (row.sources_missing || [])
            .map((entry) => `${entry.date}: ${entry.missing.join(",")}`)
            .join(" | ");

          const tr = document.createElement("tr");
          tr.innerHTML = `
            <td${columnAttr("fi")}>${row.fi}</td>
            <td${columnAttr("instances")}>${instancesText}</td>
            <td${columnAttr("integration")}>${integration}</td>
            <td${columnAttr("ga_select")}>${row.ga_select}</td>
            <td${columnAttr("ga_user")}>${row.ga_user}</td>
            <td${columnAttr("ga_cred")}>${row.ga_cred}</td>
            <td${columnAttr("reach")}>${reachPct}</td>
            <td${columnAttr("sel_user_pct")}>${selUserPct}</td>
            <td${columnAttr("sel_cred_pct")}>${selCredPct}</td>
            <td${columnAttr("sel_success_pct")}>${selSuccessPct}</td>
            <td${columnAttr("sessions")}>${row.sessions}</td>
            <td${columnAttr("sess_with_jobs")}>${row.sess_with_jobs}</td>
            <td${columnAttr("sess_jobs_pct")}>${sessJobsPct}</td>
            <td${columnAttr("sess_with_success")}>${row.sess_with_success}</td>
            <td${columnAttr("sess_success_pct")}>${sessSuccessPct}</td>
            <td${columnAttr("placements")}>${row.placements}</td>
            <td class="sources-missing"${columnAttr("sources_missing")}>${missing}</td>
          `;

          return tr;
        };

        Object.entries(bucketed).forEach(([integration, rows]) => {
          const tbody = tableBodies[integration] || tableBodies.UNKNOWN;
          tbody.innerHTML = "";
          const tableId = `table-${integration}`;
          const sortedRows = sortRowsForTable(rows, tableId, "multi");
          sortedRows.forEach((row) => tbody.appendChild(renderRow(row, integration)));
          const totalsRow = buildTotalsRow(rows, integration);
          if (totalsRow) {
            tbody.appendChild(totalsRow);
          }
          const block = groupBlocks[integration] || groupBlocks.UNKNOWN;
          if (block) {
            block.style.display = rows.length ? "" : "none";
          }
          const headerEl = groupHeaders[integration] || groupHeaders.UNKNOWN;
          if (headerEl) {
            const baseLabel = GROUP_LABELS[integration] || integration;
            headerEl.textContent = rows.length ? `${baseLabel} (${rows.length})` : baseLabel;
          }
          const tableEl = tbody.closest("table");
          attachSortHandlers(tableEl, tableId, "multi");
        });
        applyColumnTitles(multiFiView);

        const visibleCount = visibleRows.length;
        dateWindowLabel.textContent = `Date window: ${startDate} → ${endDate} (${visibleCount} FIs)`;

        if (visibleCount > 1) {
          const totals = sumMetrics(visibleRows);
          const selUserPct = totals.ga_select
            ? ((totals.ga_user / totals.ga_select) * 100).toFixed(1) + "%"
            : "";
          const selCredPct = totals.ga_select
            ? ((totals.ga_cred / totals.ga_select) * 100).toFixed(1) + "%"
            : "";
          const selSuccessPct = totals.ga_select
            ? ((totals.sess_with_success / totals.ga_select) * 100).toFixed(1) + "%"
            : "";
          const sessJobsPct =
            totals.sessions && totals.sess_with_jobs
              ? ((totals.sess_with_jobs / totals.sessions) * 100).toFixed(1) + "%"
              : "";
          totalsBar.textContent =
            `Totals (${visibleCount} FIs): sel ${totals.ga_select} | user ${totals.ga_user}` +
            ` | cred ${totals.ga_cred} | sel→user ${selUserPct || "—"} | sel→cred ${selCredPct || "—"}` +
            ` | sel→success ${selSuccessPct || "—"}` +
            ` | sessions ${totals.sessions} (jobs ${totals.sess_with_jobs}, success ${totals.sess_with_success})` +
            ` | sess→jobs ${sessJobsPct || "—"} | placements ${totals.placements}`;
          totalsBar.style.display = "block";
        } else {
          totalsBar.style.display = "none";
        }
        stopLoading();
      }

      async function applyFilters() {
        startLoading();
        try {
          const startDate = startDateInput.value || defaultStartDateStr;
          const endDate = endDateInput.value || defaultEndDateStr;
          const startDt = new Date(`${startDate}T00:00:00Z`);
          const endDt = new Date(`${endDate}T00:00:00Z`);
          const daySpan = Math.max(1, Math.floor((endDt - startDt) / (1000 * 60 * 60 * 24)) + 1);
          const monthlyFactor = 30 / daySpan;
          const cardholderMap = getCardholderMap();
          const perFi = aggregateData(startDate, endDate, cardholderMap);
          lastAggregated = perFi;
          updatePartnerOptions(perFi);
          updateFiOptions(perFi);
          const visibleRows = getVisibleRows(perFi);
          const singleFiMode = isSingleFiSelected();
          const best = computeBestWindows(startDate, endDate, perFi, visibleRows, monthlyFactor, {
            allowLowVolume: singleFiMode,
          });
          latestHighlights = best;
          renderBestWindows(best, visibleRows);
          renderTables(visibleRows, startDate, endDate, daySpan);

          lastRenderContext = {
            perFi,
            startDate,
            endDate,
            daySpan,
            best,
          };
          lastFilterSnapshot = {
            fi: fiFilterSelect?.value || FI_ALL_VALUE,
            integration: integrationSelect?.value || "(all)",
            partner: partnerSelect?.value || PARTNER_ALL_VALUE,
            includeTest: includeTestCheckbox?.checked,
          };
        } finally {
          stopLoading();
        }
      }

      function rerenderFromCache() {
        if (!lastRenderContext) return;
        const snapshotChanged =
          !lastFilterSnapshot ||
          lastFilterSnapshot.fi !== fiFilterSelect.value ||
          lastFilterSnapshot.integration !== (integrationSelect?.value || "(all)") ||
          lastFilterSnapshot.partner !== (partnerSelect?.value || PARTNER_ALL_VALUE) ||
          lastFilterSnapshot.includeTest !== includeTestCheckbox.checked;
        if (snapshotChanged) {
          applyFilters();
          return;
        }

        const { perFi, startDate, endDate, daySpan, best } = lastRenderContext;
        const visibleRows = getVisibleRows(perFi);
        renderBestWindows(best, visibleRows);
        renderTables(visibleRows, startDate, endDate, daySpan);
      }

      async function init() {
        try {
          try {
            registryMap = await fetchRegistry();
            updateRegistryLookups(registryMap);
          } catch (err) {
            console.error("Failed to load fi_registry:", err);
            registryMap = {};
          }

          try {
            const fetched = await fetchDailyList();
            dailyFiles = Array.isArray(fetched) ? fetched : [];
            if (dailyFiles.length) {
              const sortedDates = dailyFiles
                .map((file) => file.replace(".json", ""))
                .filter((d) => /^\d{4}-\d{2}-\d{2}$/.test(d))
                .sort();
              earliestDailyDate = sortedDates[0] || null;
              latestDailyDate = sortedDates[sortedDates.length - 1] || null;
              const baseIso = getLatestUsableDateIso();
              if (endDateInput && (!endDateInput.value || endDateInput.value > baseIso)) {
                endDateInput.value = baseIso;
              }
              if (startDateInput && startDateInput.value > (endDateInput?.value || baseIso)) {
                startDateInput.value = endDateInput.value || baseIso;
              }
              renderDateWarning();
            }
            for (const file of dailyFiles) {
              const date = file.replace(".json", "");
              const data = await fetchDaily(date);
              if (data) {
                dailyData[date] = data;
              }
            }
          } catch (err) {
            console.error("Failed to load daily data:", err);
          }

          safeApplyFilters();
        } catch (err) {
          console.error("Init failed", err);
          stopLoading();
        }
      }

      applyBtn.addEventListener("click", () => {
        // Force a full recompute for new date ranges
        lastRenderContext = null;
        lastFilterSnapshot = null;
        safeApplyFilters();
      });

      endDateInput?.addEventListener("change", renderDateWarning);
      startDateInput?.addEventListener("change", renderDateWarning);

      includeTestCheckbox.addEventListener("change", () => {
        applyFilters();
      });

      exportCsvBtn.addEventListener("click", () => {
        const monthlyRows =
          isSingleFiSelected() && latestSingleFiBreakdowns?.monthly?.length
            ? latestSingleFiBreakdowns.monthly
            : [];
        const quarterlyRows =
          isSingleFiSelected() && latestSingleFiBreakdowns?.quarterly?.length
            ? latestSingleFiBreakdowns.quarterly
            : [];
        const weeklyRows =
          isSingleFiSelected() && latestSingleFiBreakdowns?.weekly?.length
            ? latestSingleFiBreakdowns.weekly
            : [];
        const dailyRows =
          isSingleFiSelected() && latestSingleFiBreakdowns?.daily?.length
            ? latestSingleFiBreakdowns.daily
            : [];
        const summaryRows =
          latestVisibleRows && latestVisibleRows.length
            ? latestVisibleRows
            : lastRenderContext?.perFi
            ? Object.values(lastRenderContext.perFi)
            : [];

        const csv = buildCsvDocument({
          summary: summaryRows,
          monthly: monthlyRows,
          quarterly: quarterlyRows,
          weekly: weeklyRows,
          daily: dailyRows,
          highlights: latestHighlights,
          partnerSummary: latestPartnerSummary,
          quarterSummary: latestQuarterSummary,
          start: lastRenderContext?.startDate || startDateInput.value || defaultStartDateStr,
          end: lastRenderContext?.endDate || endDateInput.value || defaultEndDateStr,
        });
        const start = ((startDateInput.value || lastRenderContext?.startDate || "start")).replace(/[^0-9-]/g, "");
        const end = ((endDateInput.value || lastRenderContext?.endDate || "end")).replace(/[^0-9-]/g, "");
        downloadCsv(`sis-funnel-${start}-to-${end}.csv`, csv);
      });

      fiFilterSelect?.addEventListener("change", () => {
        if (lastAggregated) {
          updateInstanceOptions(lastAggregated);
        }
        rerenderFromCache();
      });

      integrationSelect?.addEventListener("change", () => {
        if (lastAggregated) {
          updatePartnerOptions(lastAggregated);
          updateFiOptions(lastAggregated);
        } else if (fiFilterSelect) {
          fiFilterSelect.value = FI_ALL_VALUE;
        }
        rerenderFromCache();
      });

      partnerSelect?.addEventListener("change", () => {
        if (lastAggregated) {
          updateFiOptions(lastAggregated);
        } else if (fiFilterSelect) {
          fiFilterSelect.value = FI_ALL_VALUE;
        }
        rerenderFromCache();
      });

      instanceSelect?.addEventListener("change", () => {
        if (!instanceSelect) return;
        const selectedValues = Array.from(instanceSelect.selectedOptions).map(
          (opt) => opt.value
        );
        const hasAll = selectedValues.includes(INSTANCE_ALL_VALUE);
        if (hasAll && selectedValues.length > 1) {
          const allOption = instanceSelect.querySelector(
            `option[value="${INSTANCE_ALL_VALUE}"]`
          );
          if (allOption) {
            allOption.selected = false;
          }
        } else if (!hasAll && selectedValues.length === 0) {
          const allOption = instanceSelect.querySelector(
            `option[value="${INSTANCE_ALL_VALUE}"]`
          );
          if (allOption) {
            allOption.selected = true;
          }
        }
        rerenderFromCache();
      });

      init().catch((err) => {
        console.error("Init failed", err);
      });

      const presetSelect = document.getElementById("datePreset");
      if (presetSelect) {
        presetSelect.addEventListener("change", () => {
          const val = presetSelect.value || "last7";
          if (val) {
            applyPresetRange(val);
            safeApplyFilters();
          }
        });
      }

      applyDefaultDateRange(true);
      applyColumnTitles();
      (function ensureFilters(pageId){
        const run = () => {
          if (window.initFilters) {
            console.log("[filters] invoking initFilters for", pageId);
            window.initFilters(pageId);
          }
        };
        if (window.initFilters) return run();
        const candidates = [
          "/assets/js/filters.js?v=shared-fallback",
          "/public/assets/js/filters.js?v=shared-fallback",
        ];
        const loadNext = (idx) => {
          if (idx >= candidates.length) {
            console.error("[filters] unable to load shared filters script");
            return;
          }
          const s = document.createElement("script");
          s.src = candidates[idx] + "&ts=" + Date.now();
          s.onload = () => {
            console.log("[filters] loaded fallback script", candidates[idx]);
            run();
          };
          s.onerror = () => {
            console.warn("[filters] failed to load", candidates[idx]);
            loadNext(idx + 1);
          };
          document.head.appendChild(s);
        };
        loadNext(0);
      })("funnel");
    </script>
  </body>
</html>
