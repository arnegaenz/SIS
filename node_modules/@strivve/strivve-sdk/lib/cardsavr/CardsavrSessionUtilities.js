"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.localStorageAvailable = exports.get_host_config = exports.getCardBrand = exports.generateRandomPar = exports.generateUniqueUsername = exports.createMetaKey = exports.formatPath = exports.generateTraceValue = exports.generateHydrationHeader = void 0;
var CardsavrSDKError_1 = __importDefault(require("./CardsavrSDKError"));
var crypto = __importStar(require("crypto"));
var generateHydrationHeader = function (hydrationArray) {
    var stringifiedHeader = JSON.stringify(hydrationArray);
    return { "x-cardsavr-hydration": stringifiedHeader };
};
exports.generateHydrationHeader = generateHydrationHeader;
var _stringReplaceAll = function (string, find, replace) {
    if (!string) {
        return string;
    }
    var replaced_string = string;
    while (replaced_string.includes(find)) {
        replaced_string = replaced_string.replace(find, replace);
    }
    return replaced_string;
};
var generateTraceValue = function (bytes) {
    if (!bytes) {
        bytes = 16;
    }
    var rb64 = crypto.randomBytes(bytes).toString("base64");
    var traceValue = rb64;
    traceValue = _stringReplaceAll(traceValue, "+", "-");
    traceValue = _stringReplaceAll(traceValue, "/", "_");
    traceValue = _stringReplaceAll(traceValue, "=", "");
    return traceValue;
};
exports.generateTraceValue = generateTraceValue;
var stringIdPaths = ["/card_placement_results", "/merchant_sites"];
var formatPath = function (path, filter) {
    var validationErrors = [];
    if (!path.startsWith("/")) {
        path = "/" + path;
    }
    if (path.endsWith("/")) {
        path = path.substring(0, path.length - 1);
    }
    if (filter) {
        // runtime check
        if (typeof filter === "number") {
            path = "".concat(path, "/").concat(filter);
        }
        else if (typeof filter === "object" && !Array.isArray(filter)) {
            path += "?" + Object.keys(filter).map(function (k) {
                return Array.isArray(filter[k]) ?
                    filter[k].map(function (o) { return "".concat(k, "=").concat(o); }).join("&") :
                    "".concat(k, "=").concat(filter[k]);
            })
                .join("&");
        }
        else {
            validationErrors.push("Valid ID or filter not found in provided path: " + filter + " type: " + (typeof filter));
            throw new CardsavrSDKError_1.default(validationErrors);
        }
    }
    return path;
};
exports.formatPath = formatPath;
var createMetaKey = function (first_name, last_name, pan, postal_code) {
    var validationErrors = [];
    if (!first_name || first_name.length === 0) {
        validationErrors.push("Can't create meta_key, no first name on card");
    }
    if (!last_name || last_name.length === 0) {
        validationErrors.push("Can't create meta_key, no last name on card");
    }
    if (!postal_code || postal_code.length < 5) {
        validationErrors.push("Can't create meta_key, invalid postal code");
    }
    if (!pan || pan.length === 0) {
        validationErrors.push("Can't create meta_key, no pan on card");
    }
    if (validationErrors.length > 0) {
        throw new CardsavrSDKError_1.default(validationErrors);
    }
    return first_name[0] + last_name[0] + postal_code.substring(0, 5) + pan.slice(-2);
};
exports.createMetaKey = createMetaKey;
var generateUniqueUsername = function () {
    var length = 20;
    return __spreadArray([], Array(length), true).map(function () { return (~~(Math.random() * 36)).toString(36); }).join("");
};
exports.generateUniqueUsername = generateUniqueUsername;
var generateRandomPar = function (pan, exp_month, exp_year, salt) {
    var paramsArray = { "pan": pan, "exp_month": exp_month, "exp_year": exp_year, "salt": salt };
    var validationErrors = [];
    Object.entries(paramsArray).filter(function (param) { return !param[1]; }).forEach(function (param) { return validationErrors.push("Missing required parameter: " + param[0]); });
    if (exp_month && (exp_month.length != 2) || isNaN(+exp_month) || (+exp_month > 12)) {
        validationErrors.push("Invalid expiration month received: " + exp_month);
    }
    if (exp_year && (exp_year.length != 2) || isNaN(+exp_year)) {
        validationErrors.push("Invalid expiration year received: " + exp_year);
    }
    if (validationErrors.length > 0) {
        throw new CardsavrSDKError_1.default(validationErrors);
    }
    // Hash up the salt for use as salt
    var hashS = crypto.createHash("sha256");
    hashS.update(salt + exp_month + exp_year);
    var salt_buffer = hashS.digest();
    // Hashup the PAN into 128bits
    var hashP = crypto.createHash("md5");
    hashP.update(pan);
    var panHash = hashP.digest();
    var PARHash = crypto.pbkdf2Sync(panHash.toString("utf8"), salt_buffer, 5000, 20, "sha1");
    var PAR = "C" + PARHash.toString("base64");
    return PAR;
};
exports.generateRandomPar = generateRandomPar;
var getCardBrand = function (pan) {
    var validationErrors = [];
    pan = pan.toString();
    var brandRegexes = {
        "visa": /^4[0-9]{12}(?:[0-9]{3})?$/,
        "mastercard": /^5[1-5][0-9]{14}$/,
        "amex": /^3[47][0-9]{5,}$/,
        "discover": /^6(?:011|5[0-9]{2})[0-9]{12}$/
    };
    var brands = Object.keys(brandRegexes);
    for (var _i = 0, brands_1 = brands; _i < brands_1.length; _i++) {
        var brand = brands_1[_i];
        var regex = brandRegexes[brand];
        if (pan.match(regex)) {
            return brand;
        }
    }
    validationErrors.push("Card number could not be matched to a recognized brand.");
    throw new CardsavrSDKError_1.default(validationErrors);
};
exports.getCardBrand = getCardBrand;
var get_host_config = function get_host_config(fi_override, api_port_override, api_instance_override) {
    var hostname = window.location.hostname;
    var fi_lookup;
    var instance_root;
    var instance;
    if (!hostname.endsWith(".cardupdatr.app")) {
        //varomoney garbage which we don't even use anymore -- csapi.varomoney.com and updatecard.varomoney.com
        instance_root = hostname.replace(/^\w+\./, "");
        fi_lookup = hostname;
    }
    else {
        var nodes = hostname.split(".");
        if (nodes.length === 4) {
            fi_lookup = fi_override !== null && fi_override !== void 0 ? fi_override : nodes[0];
            nodes.shift();
        }
        else {
            fi_lookup = fi_override !== null && fi_override !== void 0 ? fi_override : "default";
        }
        instance = nodes[0] = api_instance_override || nodes[0];
        instance_root = nodes.join(".");
    }
    return { api_url: "https://csapi.".concat(instance_root).concat(api_port_override ? ":".concat(api_port_override) : "", "/"), instance: instance, fi_lookup: fi_lookup };
};
exports.get_host_config = get_host_config;
var localStorageAvailable = function () {
    if (typeof window === "undefined") {
        return false;
    }
    var storage;
    try {
        storage = window["sessionStorage"];
        var x = "__storage_test__";
        storage.setItem(x, x);
        storage.removeItem(x);
        return true;
    }
    catch (e) {
        return e instanceof DOMException && (
        // everything except Firefox
        e.code === 22 ||
            // Firefox
            e.code === 1014 ||
            // test name field too, because code might not be present
            // everything except Firefox
            e.name === "QuotaExceededError" ||
            // Firefox
            e.name === "NS_ERROR_DOM_QUOTA_REACHED") &&
            // acknowledge QuotaExceededError only if there's something already stored
            (storage !== undefined && storage.length !== 0);
    }
};
exports.localStorageAvailable = localStorageAvailable;
//# sourceMappingURL=CardsavrSessionUtilities.js.map